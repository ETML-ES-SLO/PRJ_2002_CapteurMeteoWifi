Disassembly Listing for 2002_CapteurMeteoWifi
Generated From:
C:/microchip/harmony/v2_06/apps/PROJ/2002_CapteurMeteoWifi/firmware/2002_CapteurMeteoWifi.X/dist/default/debug/2002_CapteurMeteoWifi.X.debug.elf
5 sept. 2022 14:19:26

---  c:/microchip/harmony/v2_06/framework/system/int/src/sys_int_pic32.c  -------------------------------
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int_pic32.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "system/int/sys_int.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Function Definitions
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  /******************************************************************************
53:                  
54:                    Function:
55:                      void SYS_INT_Initialize ( void )
56:                  
57:                    Summary:
58:                      Configures and initializes the interrupt sub-system.
59:                  
60:                    Description:
61:                      This function appropriately configures and initializes the interrupt sub-system
62:                      for the current system design.
63:                  
64:                    Precondition:
65:                      None.
66:                  
67:                    Parameters:
68:                      None.
69:                  
70:                    Returns:
71:                      None.
72:                  
73:                    Example:
74:                    <code>
75:                    SYS_INT_Initialize();
76:                    </code>
77:                  
78:                    Remarks:
79:                      This function is not implemented in the System Interrupt library.  It is
80:                      implemented by the board support package (using the processor-specific
81:                      interrupt peripheral library) because it requires knowledge of the specific
82:                      interrupt requirements for each system.
83:                  */
84:                  
85:                  void SYS_INT_Initialize ( void )
86:                  
87:                  {
9D00DC2C  27BDFFE8   ADDIU SP, SP, -24
9D00DC30  AFBF0014   SW RA, 20(SP)
9D00DC34  AFBE0010   SW FP, 16(SP)
9D00DC38  03A0F021   ADDU FP, SP, ZERO
88:                      /* enable the multi vector */
89:                      PLIB_INT_MultiVectorSelect( INT_ID_0 );
9D00DC3C  00002021   ADDU A0, ZERO, ZERO
9D00DC40  0F403867   JAL PLIB_INT_MultiVectorSelect
9D00DC44  00000000   NOP
90:                  }
9D00DC48  03C0E821   ADDU SP, FP, ZERO
9D00DC4C  8FBF0014   LW RA, 20(SP)
9D00DC50  8FBE0010   LW FP, 16(SP)
9D00DC54  27BD0018   ADDIU SP, SP, 24
9D00DC58  03E00008   JR RA
9D00DC5C  00000000   NOP
91:                  
92:                  //*******************************************************************************
93:                  /*  Function:
94:                       SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
95:                  
96:                    Summary:
97:                      Disables interrupts to the processor and return the previois status.
98:                      
99:                    Description:
100:                     This function disables interrupts to the processor at the top level. This
101:                     function can be called to prevent any source from being able to generate an
102:                     interrupt. It returns the processor status (which includes global interrupt
103:                     status and Interrupt Priority status) before disabling the interrupts.
104:                 
105:                   Remarks:
106:                     See sys_int.h file for more details.
107:                 */
108:                 
109:                 SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
110:                 {
00000000  00000000   NOP
111:                     SYS_INT_PROCESSOR_STATUS processorStatus;
112:                 
113:                     /* Save the processor status and then Disable the global interrupt */
114:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
00000010  00000000   NOP
115:                 
116:                     /* return the processor status */
117:                     return processorStatus;
00000020  00000000   NOP
118:                 }
00000024  00000000   NOP
119:                 
120:                 //*******************************************************************************
121:                 /* Function:
122:                     void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
123:                 
124:                   Summary:
125:                     Restores the processor status.
126:                 
127:                   Description:
128:                     This function sets the processor status based on the 32 bit value passed as 
129:                     a parameter. 0th bit of the status is for Master Interrupt status.
130:                 
131:                   Remarks:
132:                     See sys_int.h file for more details.
133:                 */
134:                 
135:                 void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
136:                 {
00000000  00000000   NOP
137:                     __builtin_mtc0(12, 0, processorStatus);
00000014  00000000   NOP
138:                 }
00000020  00000000   NOP
139:                 
140:                 // *****************************************************************************
141:                 /*  Disable the generation of interrupts to the CPU
142:                 
143:                   Summary:
144:                      Disables all interrupts
145:                 
146:                   Description:
147:                      This function disables all interrupts.
148:                 
149:                   Remarks:
150:                     This API will be depricated soon. Use "SYS_INT_StatusGetAndDisable" instead.
151:                  */
152:                 
153:                 bool SYS_INT_Disable( void )
154:                 {
00000000  00000000   NOP
155:                     SYS_INT_PROCESSOR_STATUS processorStatus;
156:                 
157:                     /* Save the processor status and then Disable the global interrupt */
158:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
00000010  00000000   NOP
159:                 
160:                     /* return the interrupt status */
161:                     return (bool)(processorStatus & 0x01);
00000020  00000000   NOP
162:                 }
00000030  00000000   NOP
163:                 
164:                 // *****************************************************************************
165:                 /* Function:
166:                     bool SYS_INT_SourceDisable ( INT_SOURCE source )
167:                 
168:                   Summary:
169:                     Disables the interrupt source.
170:                 
171:                   Description:
172:                     This routine disables the given source from generating interrupts the 
173:                     processor when events occur.It returns the interrupt source enable/disable 
174:                 	status before disabling the interrupt source.
175:                 
176:                   Remarks:
177:                     See sys_int.h file for more details.
178:                  */
179:                 
180:                 
181:                 bool SYS_INT_SourceDisable ( INT_SOURCE source )
182:                 {
00000000  00000000   NOP
183:                     bool intSrcStatus;
184:                     SYS_INT_PROCESSOR_STATUS processorStatus;
185:                 
186:                     /* Save the processor status and then Disable the global interrupt */
187:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
00000014  00000000   NOP
188:                     
189:                     /* get the interrupt status of this source before disable is called */
190:                     intSrcStatus = PLIB_INT_SourceIsEnabled (INT_ID_0 , source);
00000024  00000000   NOP
191:                 
192:                     /* disable the interrupts */
193:                     PLIB_INT_SourceDisable (INT_ID_0 , source);
00000038  00000000   NOP
194:                 
195:                     /* restore the state of CP0 Status register before the disable occurred*/
196:                     __builtin_mtc0(12, 0, processorStatus);
00000048  00000000   NOP
197:                 
198:                     /* return the source status */
199:                     return intSrcStatus;
00000054  00000000   NOP
200:                 }
00000058  00000000   NOP
201:                 
202:                 
203:                 // *****************************************************************************
204:                 /* Sets the external interrupt trigger type.
205:                 
206:                   Summary:
207:                     Sets the external interrupt trigger type.
208:                 
209:                   Description:
210:                     This function sets the External interrupt trigger type.
211:                 
212:                   Remarks:
213:                     Refer the datasheet to know the external interrupt sources supported.
214:                  */
215:                 
216:                 void SYS_INT_ExternalInterruptTriggerSet ( 	INT_EXTERNAL_SOURCES source,
217:                 										INT_EXTERNAL_EDGE_TRIGGER edgeTrigger )
218:                 {
00000000  00000000   NOP
219:                 	if ( edgeTrigger == INT_EDGE_TRIGGER_RISING )
00000018  00000000   NOP
220:                 	{
221:                 		PLIB_INT_ExternalRisingEdgeSelect ( INT_ID_0, source );
00000028  00000000   NOP
222:                 	}
223:                 	else
224:                 	{
225:                 		PLIB_INT_ExternalFallingEdgeSelect ( INT_ID_0, source );
00000040  00000000   NOP
226:                 	}
227:                 }
00000050  00000000   NOP
228:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/system_tasks.c
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       system_tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled state
9:                       machines.
10:                  
11:                    Description:
12:                      This file contains source code necessary to maintain system's polled state
13:                      machines.  It implements the "SYS_Tasks" function that calls the individual
14:                      "Tasks" functions for all polled MPLAB Harmony modules in the system.
15:                  
16:                    Remarks:
17:                      This file requires access to the systemObjects global data structure that
18:                      contains the object handles to all MPLAB Harmony module objects executing
19:                      polled in the system.  These handles are passed into the individual module
20:                      "Tasks" functions to identify the instance of the module to maintain.
21:                   *******************************************************************************/
22:                  
23:                  // DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: Included Files
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: System "Tasks" Routine
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  /*******************************************************************************
65:                    Function:
66:                      void SYS_Tasks ( void )
67:                  
68:                    Remarks:
69:                      See prototype in system/common/sys_module.h.
70:                  */
71:                  
72:                  void SYS_Tasks ( void )
73:                  {
9D00DC60  27BDFFE8   ADDIU SP, SP, -24
9D00DC64  AFBF0014   SW RA, 20(SP)
9D00DC68  AFBE0010   SW FP, 16(SP)
9D00DC6C  03A0F021   ADDU FP, SP, ZERO
74:                      /* Maintain system services */
75:                  
76:                      /* Maintain Device Drivers */
77:                  
78:                      /* Maintain Middleware & Other Libraries */
79:                  
80:                      /* Maintain the application's state machine. */
81:                      APP_Tasks();
9D00DC70  0F401FEC   JAL APP_Tasks
9D00DC74  00000000   NOP
82:                  }
9D00DC78  03C0E821   ADDU SP, FP, ZERO
9D00DC7C  8FBF0014   LW RA, 20(SP)
9D00DC80  8FBE0010   LW FP, 16(SP)
9D00DC84  27BD0018   ADDIU SP, SP, 24
9D00DC88  03E00008   JR RA
9D00DC8C  00000000   NOP
83:                  
84:                  
85:                  /*******************************************************************************
86:                   End of File
87:                   */
88:                  
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/system_interrupt.c
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     File Name:
5:                       system_interrupt.c
6:                   
7:                     Summary:
8:                       Raw ISR definitions.
9:                   
10:                    Description:
11:                      This file contains a definitions of the raw ISRs required to support the
12:                      interrupt sub-system.
13:                  
14:                    Summary:
15:                      This file contains source code for the interrupt vector functions in the
16:                      system.
17:                  
18:                    Description:
19:                      This file contains source code for the interrupt vector functions in the
20:                      system.  It implements the system and part specific vector "stub" functions
21:                      from which the individual "Tasks" functions are called for any modules
22:                      executing interrupt-driven in the MPLAB Harmony system.
23:                  
24:                    Remarks:
25:                      This file requires access to the systemObjects global data structure that
26:                      contains the object handles to all MPLAB Harmony module objects executing
27:                      interrupt-driven in the system.  These handles are passed into the individual
28:                      module "Tasks" functions to identify the instance of the module to maintain.
29:                   *******************************************************************************/
30:                  
31:                  // DOM-IGNORE-BEGIN
32:                  /*******************************************************************************
33:                  Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
34:                  
35:                  Microchip licenses to you the right to use, modify, copy and distribute
36:                  Software only when embedded on a Microchip microcontroller or digital signal
37:                  controller that is integrated into your product or third party product
38:                  (pursuant to the sublicense terms in the accompanying license agreement).
39:                  
40:                  You should refer to the license agreement accompanying this Software for
41:                  additional information regarding your rights and obligations.
42:                  
43:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
44:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
45:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
46:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
47:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
48:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
49:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
50:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
51:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
52:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
53:                   *******************************************************************************/
54:                  // DOM-IGNORE-END
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  
62:                  #include "system/common/sys_common.h"
63:                  #include "app.h"
64:                  #include "system_definitions.h"
65:                  
66:                  #include "app.h"
67:                  #include "BME280.h"
68:                  #include "ESP8266.h"
69:                  #include "MenuGen.h"
70:                  #include "Mc32Delays.h"
71:                  #include "Mc32NVMUtil.h"
72:                  #include "Mc32gest_RS232.h"
73:                  #include "Mc32gestI2cSensor.h"
74:                  
75:                  
76:                  // *****************************************************************************
77:                  // *****************************************************************************
78:                  // Section: System Interrupt Vector Functions
79:                  // *****************************************************************************
80:                  // *****************************************************************************
81:                  
82:                  //((50ms/20MHz)/16)-1 = 62499 -> 50ms (16bits)
83:                  void __ISR(_TIMER_2_VECTOR, ipl1AUTO) IntHandlerDrvTmrInstance1(void)
84:                  {
9D008668  415DE800   RDPGPR SP, SP
9D00866C  401B7000   MFC0 K1, EPC
9D008670  401A6002   MFC0 K0, SRSCtl
9D008674  27BDFF88   ADDIU SP, SP, -120
9D008678  AFBB0074   SW K1, 116(SP)
9D00867C  401B6000   MFC0 K1, Status
9D008680  AFBA006C   SW K0, 108(SP)
9D008684  AFBB0070   SW K1, 112(SP)
9D008688  7C1B7844   INS K1, ZERO, 1, 15
9D00868C  377B0400   ORI K1, K1, 1024
9D008690  409B6000   MTC0 K1, Status
9D008694  AFA3001C   SW V1, 28(SP)
9D008698  AFA20018   SW V0, 24(SP)
9D00869C  8FA3006C   LW V1, 108(SP)
9D0086A0  3063000F   ANDI V1, V1, 15
9D0086A4  14600012   BNE V1, ZERO, 0x9D0086F0
9D0086A8  00000000   NOP
9D0086AC  AFBF005C   SW RA, 92(SP)
9D0086B0  AFBE0058   SW FP, 88(SP)
9D0086B4  AFB90054   SW T9, 84(SP)
9D0086B8  AFB80050   SW T8, 80(SP)
9D0086BC  AFAF004C   SW T7, 76(SP)
9D0086C0  AFAE0048   SW T6, 72(SP)
9D0086C4  AFAD0044   SW T5, 68(SP)
9D0086C8  AFAC0040   SW T4, 64(SP)
9D0086CC  AFAB003C   SW T3, 60(SP)
9D0086D0  AFAA0038   SW T2, 56(SP)
9D0086D4  AFA90034   SW T1, 52(SP)
9D0086D8  AFA80030   SW T0, 48(SP)
9D0086DC  AFA7002C   SW A3, 44(SP)
9D0086E0  AFA60028   SW A2, 40(SP)
9D0086E4  AFA50024   SW A1, 36(SP)
9D0086E8  AFA40020   SW A0, 32(SP)
9D0086EC  AFA10014   SW AT, 20(SP)
9D0086F0  00000000   NOP
9D0086F4  00001012   MFLO V0
9D0086F8  AFA20064   SW V0, 100(SP)
9D0086FC  00001810   MFHI V1
9D008700  AFA30060   SW V1, 96(SP)
9D008704  03A0F021   ADDU FP, SP, ZERO
85:                      PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_TIMER_2);
9D008708  00002021   ADDU A0, ZERO, ZERO
9D00870C  24050009   ADDIU A1, ZERO, 9
9D008710  0F403790   JAL PLIB_INT_SourceFlagClear
9D008714  00000000   NOP
86:                     
87:                      static uint16_t countLED = 0, countInterval = 0, countMenu = 0;
88:                      
89:                      APP_UpdateState(APP_STATE_WAIT);
9D008718  24040001   ADDIU A0, ZERO, 1
9D00871C  0F403724   JAL APP_UpdateState
9D008720  00000000   NOP
90:                      
91:                      if(countMenu >= 1)
9D008724  9782801C   LHU V0, -32740(GP)
9D008728  10400007   BEQ V0, ZERO, 0x9D008748
9D00872C  00000000   NOP
92:                      {
93:                          countMenu = 0;
9D008730  A780801C   SH ZERO, -32740(GP)
94:                          APP_UpdateState(APP_STATE_MENU);
9D008734  24040004   ADDIU A0, ZERO, 4
9D008738  0F403724   JAL APP_UpdateState
9D00873C  00000000   NOP
9D008740  0B4021D6   J 0x9D008758
9D008744  00000000   NOP
95:                      }
96:                      else
97:                      {
98:                          countMenu++;
9D008748  9782801C   LHU V0, -32740(GP)
9D00874C  24420001   ADDIU V0, V0, 1
9D008750  3042FFFF   ANDI V0, V0, -1
9D008754  A782801C   SH V0, -32740(GP)
99:                      }
100:                     
101:                     if(countLED >= 9 && MenuStatus == Enter_Menu_Get)
9D008758  9782801E   LHU V0, -32738(GP)
9D00875C  2C420009   SLTIU V0, V0, 9
9D008760  1440000A   BNE V0, ZERO, 0x9D00878C
9D008764  00000000   NOP
9D008768  8F838034   LW V1, -32716(GP)
9D00876C  24020001   ADDIU V0, ZERO, 1
9D008770  14620006   BNE V1, V0, 0x9D00878C
9D008774  00000000   NOP
102:                     {
103:                         countLED = 0;
9D008778  A780801E   SH ZERO, -32738(GP)
104:                         LED_Signal();
9D00877C  0F402554   JAL LED_Signal
9D008780  00000000   NOP
9D008784  0B4021E7   J 0x9D00879C
9D008788  00000000   NOP
105:                     }
106:                     else
107:                     {
108:                         countLED++;
9D00878C  9782801E   LHU V0, -32738(GP)
9D008790  24420001   ADDIU V0, V0, 1
9D008794  3042FFFF   ANDI V0, V0, -1
9D008798  A782801E   SH V0, -32738(GP)
109:                     }
110:                     
111:                     if(countInterval >= ESP8266.Interval)
9D00879C  97828020   LHU V0, -32736(GP)
9D0087A0  00401821   ADDU V1, V0, ZERO
9D0087A4  3C02A000   LUI V0, -24576
9D0087A8  24420244   ADDIU V0, V0, 580
9D0087AC  8C420020   LW V0, 32(V0)
9D0087B0  0062102B   SLTU V0, V1, V0
9D0087B4  14400007   BNE V0, ZERO, 0x9D0087D4
9D0087B8  00000000   NOP
112:                     {
113:                         countInterval = 0;
9D0087BC  A7808020   SH ZERO, -32736(GP)
114:                         APP_UpdateState(APP_STATE_DO_MEASURE);
9D0087C0  24040002   ADDIU A0, ZERO, 2
9D0087C4  0F403724   JAL APP_UpdateState
9D0087C8  00000000   NOP
9D0087CC  0B4021F9   J 0x9D0087E4
9D0087D0  00000000   NOP
115:                     }
116:                     else
117:                     {
118:                         countInterval++;
9D0087D4  97828020   LHU V0, -32736(GP)
9D0087D8  24420001   ADDIU V0, V0, 1
9D0087DC  3042FFFF   ANDI V0, V0, -1
9D0087E0  A7828020   SH V0, -32736(GP)
119:                     }    
120:                 }
9D0087E4  03C0E821   ADDU SP, FP, ZERO
9D0087E8  8FA20064   LW V0, 100(SP)
9D0087EC  00400013   MTLO V0
9D0087F0  8FA30060   LW V1, 96(SP)
9D0087F4  00600011   MTHI V1
9D0087F8  8FA2006C   LW V0, 108(SP)
9D0087FC  3042000F   ANDI V0, V0, 15
9D008800  14400014   BNE V0, ZERO, 0x9D008854
9D008804  00000000   NOP
9D008808  8FBF005C   LW RA, 92(SP)
9D00880C  8FBE0058   LW FP, 88(SP)
9D008810  8FB90054   LW T9, 84(SP)
9D008814  8FB80050   LW T8, 80(SP)
9D008818  8FAF004C   LW T7, 76(SP)
9D00881C  8FAE0048   LW T6, 72(SP)
9D008820  8FAD0044   LW T5, 68(SP)
9D008824  8FAC0040   LW T4, 64(SP)
9D008828  8FAB003C   LW T3, 60(SP)
9D00882C  8FAA0038   LW T2, 56(SP)
9D008830  8FA90034   LW T1, 52(SP)
9D008834  8FA80030   LW T0, 48(SP)
9D008838  8FA7002C   LW A3, 44(SP)
9D00883C  8FA60028   LW A2, 40(SP)
9D008840  8FA50024   LW A1, 36(SP)
9D008844  8FA40020   LW A0, 32(SP)
9D008848  8FA3001C   LW V1, 28(SP)
9D00884C  8FA20018   LW V0, 24(SP)
9D008850  8FA10014   LW AT, 20(SP)
9D008854  00000000   NOP
9D008858  41606000   DI ZERO
9D00885C  000000C0   EHB
9D008860  8FBA0074   LW K0, 116(SP)
9D008864  8FBB0070   LW K1, 112(SP)
9D008868  409A7000   MTC0 K0, EPC
9D00886C  8FBA006C   LW K0, 108(SP)
9D008870  27BD0078   ADDIU SP, SP, 120
9D008874  409A6002   MTC0 K0, SRSCtl
9D008878  41DDE800   WRPGPR SP, SP
9D00887C  409B6000   MTC0 K1, Status
9D008880  42000018   ERET
121:                  /*******************************************************************************
122:                  End of File
123:                 */
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/system_init.c
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       system_init.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits,
13:                      and allocates any necessary global system resources, such as the
14:                      sysObj structure that contains the object handles to all the MPLAB Harmony
15:                      module objects in the system.
16:                   *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system_config.h"
50:                  #include "system_definitions.h"
51:                  
52:                  
53:                  // ****************************************************************************
54:                  // ****************************************************************************
55:                  // Section: Configuration Bits
56:                  // ****************************************************************************
57:                  // ****************************************************************************
58:                  // <editor-fold defaultstate="collapsed" desc="Configuration Bits">
59:                  
60:                  /*** DEVCFG0 ***/
61:                  
62:                  #pragma config DEBUG =      ON
63:                  #pragma config JTAGEN =     OFF
64:                  #pragma config ICESEL =     ICS_PGx1
65:                  #pragma config PWP =        OFF
66:                  #pragma config BWP =        OFF
67:                  #pragma config CP =         OFF
68:                  
69:                  /*** DEVCFG1 ***/
70:                  
71:                  #pragma config FNOSC =      FRCPLL
72:                  #pragma config FSOSCEN =    OFF
73:                  #pragma config IESO =       OFF
74:                  #pragma config POSCMOD =    OFF
75:                  #pragma config OSCIOFNC =   OFF
76:                  #pragma config FPBDIV =     DIV_1
77:                  #pragma config FCKSM =      CSDCMD
78:                  #pragma config WDTPS =      PS1048576
79:                  #pragma config FWDTEN =     OFF
80:                  #pragma config WINDIS =     OFF
81:                  #pragma config FWDTWINSZ =  WINSZ_50
82:                  /*** DEVCFG2 ***/
83:                  
84:                  #pragma config FPLLIDIV =   DIV_2
85:                  #pragma config FPLLMUL =    MUL_20
86:                  #pragma config FPLLODIV =   DIV_4
87:                  /*** DEVCFG3 ***/
88:                  
89:                  #pragma config USERID =     0xffff
90:                  #pragma config PMDL1WAY =   ON
91:                  #pragma config IOL1WAY =    ON
92:                  // </editor-fold>
93:                  
94:                  // *****************************************************************************
95:                  // *****************************************************************************
96:                  // Section: Driver Initialization Data
97:                  // *****************************************************************************
98:                  // *****************************************************************************
99:                  // <editor-fold defaultstate="collapsed" desc="DRV_USART Initialization Data">
100:                 // </editor-fold>
101:                 
102:                 // *****************************************************************************
103:                 // *****************************************************************************
104:                 // Section: System Data
105:                 // *****************************************************************************
106:                 // *****************************************************************************
107:                 
108:                 /* Structure to hold the object handles for the modules in the system. */
109:                 SYSTEM_OBJECTS sysObj;
110:                 
111:                 // *****************************************************************************
112:                 // *****************************************************************************
113:                 // Section: Module Initialization Data
114:                 // *****************************************************************************
115:                 // *****************************************************************************
116:                 
117:                 // *****************************************************************************
118:                 // *****************************************************************************
119:                 // Section: Library/Stack Initialization Data
120:                 // *****************************************************************************
121:                 // *****************************************************************************
122:                 
123:                 // *****************************************************************************
124:                 // *****************************************************************************
125:                 // Section: System Initialization
126:                 // *****************************************************************************
127:                 // *****************************************************************************
128:                 
129:                 /*******************************************************************************
130:                   Function:
131:                     void SYS_Initialize ( void *data )
132:                 
133:                   Summary:
134:                     Initializes the board, services, drivers, application and other modules.
135:                 
136:                   Remarks:
137:                     See prototype in system/common/sys_module.h.
138:                  */
139:                 
140:                 void SYS_Initialize ( void* data )
141:                 {
9D00AA78  27BDFFE8   ADDIU SP, SP, -24
9D00AA7C  AFBF0014   SW RA, 20(SP)
9D00AA80  AFBE0010   SW FP, 16(SP)
9D00AA84  03A0F021   ADDU FP, SP, ZERO
9D00AA88  AFC40018   SW A0, 24(FP)
142:                     /* Core Processor Initialization */
143:                     SYS_CLK_Initialize( NULL );
9D00AA8C  00002021   ADDU A0, ZERO, ZERO
9D00AA90  0F4033CA   JAL SYS_CLK_Initialize
9D00AA94  00000000   NOP
144:                     SYS_DEVCON_Initialize(SYS_DEVCON_INDEX_0, (SYS_MODULE_INIT*)NULL);
9D00AA98  00002021   ADDU A0, ZERO, ZERO
9D00AA9C  00002821   ADDU A1, ZERO, ZERO
9D00AAA0  0F4036DF   JAL SYS_DEVCON_Initialize
9D00AAA4  00000000   NOP
145:                     SYS_DEVCON_PerformanceConfig(SYS_CLK_SystemFrequencyGet());
9D00AAA8  0F40377C   JAL SYS_CLK_SystemFrequencyGet
9D00AAAC  00000000   NOP
9D00AAB0  00402021   ADDU A0, V0, ZERO
9D00AAB4  0F403263   JAL SYS_DEVCON_PerformanceConfig
9D00AAB8  00000000   NOP
146:                 
147:                     /* Initialize Drivers */
148:                     /*Initialize TMR1 */
149:                     DRV_TMR1_Initialize();
9D00AABC  0F4030B3   JAL DRV_TMR1_Initialize
9D00AAC0  00000000   NOP
150:                  
151:                      sysObj.drvUsart0 = DRV_USART_Initialize(DRV_USART_INDEX_0, (SYS_MODULE_INIT *)NULL);
9D00AAC4  00002021   ADDU A0, ZERO, ZERO
9D00AAC8  00002821   ADDU A1, ZERO, ZERO
9D00AACC  0F403321   JAL DRV_USART_Initialize
9D00AAD0  00000000   NOP
9D00AAD4  00401821   ADDU V1, V0, ZERO
9D00AAD8  3C02A000   LUI V0, -24576
9D00AADC  24420CE0   ADDIU V0, V0, 3296
9D00AAE0  AC430004   SW V1, 4(V0)
152:                     sysObj.drvUsart1 = DRV_USART_Initialize(DRV_USART_INDEX_1, (SYS_MODULE_INIT *)NULL);
9D00AAE4  24040001   ADDIU A0, ZERO, 1
9D00AAE8  00002821   ADDU A1, ZERO, ZERO
9D00AAEC  0F403321   JAL DRV_USART_Initialize
9D00AAF0  00000000   NOP
9D00AAF4  00401821   ADDU V1, V0, ZERO
9D00AAF8  3C02A000   LUI V0, -24576
9D00AAFC  24420CE0   ADDIU V0, V0, 3296
9D00AB00  AC430008   SW V1, 8(V0)
153:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART2, INT_PRIORITY_LEVEL3);
9D00AB04  00002021   ADDU A0, ZERO, ZERO
9D00AB08  24050025   ADDIU A1, ZERO, 37
9D00AB0C  24060003   ADDIU A2, ZERO, 3
9D00AB10  0F4035E5   JAL .LFE8, PLIB_INT_VectorPrioritySet
9D00AB14  00000000   NOP
154:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART2, INT_SUBPRIORITY_LEVEL0);
9D00AB18  00002021   ADDU A0, ZERO, ZERO
9D00AB1C  24050025   ADDIU A1, ZERO, 37
9D00AB20  00003021   ADDU A2, ZERO, ZERO
9D00AB24  0F403623   JAL .LFE1152, PLIB_INT_VectorSubPrioritySet
9D00AB28  00000000   NOP
155:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART1, INT_PRIORITY_LEVEL3);
9D00AB2C  00002021   ADDU A0, ZERO, ZERO
9D00AB30  24050020   ADDIU A1, ZERO, 32
9D00AB34  24060003   ADDIU A2, ZERO, 3
9D00AB38  0F4035E5   JAL .LFE8, PLIB_INT_VectorPrioritySet
9D00AB3C  00000000   NOP
156:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART1, INT_SUBPRIORITY_LEVEL0);
9D00AB40  00002021   ADDU A0, ZERO, ZERO
9D00AB44  24050020   ADDIU A1, ZERO, 32
9D00AB48  00003021   ADDU A2, ZERO, ZERO
9D00AB4C  0F403623   JAL .LFE1152, PLIB_INT_VectorSubPrioritySet
9D00AB50  00000000   NOP
157:                 
158:                     /* Initialize System Services */
159:                     SYS_PORTS_Initialize();
9D00AB54  0F4022A3   JAL SYS_PORTS_Initialize
9D00AB58  00000000   NOP
160:                 
161:                     /*** Interrupt Service Initialization Code ***/
162:                     SYS_INT_Initialize();
9D00AB5C  0F40370B   JAL SYS_INT_Initialize
9D00AB60  00000000   NOP
163:                 
164:                     /* Initialize Middleware */
165:                 
166:                     /* Enable Global Interrupts */
167:                     SYS_INT_Enable();
9D00AB64  40026000   MFC0 V0, Status
9D00AB68  34420001   ORI V0, V0, 1
9D00AB6C  40826000   MTC0 V0, Status
9D00AB70  000000C0   EHB
168:                 
169:                     /* Initialize the Application */
170:                     APP_Initialize();
9D00AB74  0F4037D6   JAL APP_Initialize
9D00AB78  00000000   NOP
171:                 }
9D00AB7C  03C0E821   ADDU SP, FP, ZERO
9D00AB80  8FBF0014   LW RA, 20(SP)
9D00AB84  8FBE0010   LW FP, 16(SP)
9D00AB88  27BD0018   ADDIU SP, SP, 24
9D00AB8C  03E00008   JR RA
9D00AB90  00000000   NOP
172:                 
173:                 
174:                 /*******************************************************************************
175:                  End of File
176:                 */
177:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/system_exceptions.c
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       system_exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the deafult _weak_ exception
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occured.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013-2017 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  
45:                  #include <xc.h>                 /* Defines special function registers, CP0 regs  */
46:                  #include "system_config.h"
47:                  #include "system_definitions.h"
48:                  #include "system/debug/sys_debug.h"
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data Definitions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /*******************************************************************************
58:                    Exception Reason Data
59:                  
60:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
61:                  
62:                    Remarks:
63:                      These global static items are used instead of local variables in the
64:                      _general_exception_handler function because the stack may not be available
65:                      if an exception has occured.
66:                  */
67:                  
68:                  /* Code identifying the cause of the exception (CP0 Cause register). */
69:                  static unsigned int _excep_code;
70:                  
71:                  /* Address of instruction that caused the exception. */
72:                  static unsigned int _excep_addr;
73:                  
74:                  /* Pointer to the string describing the cause of the exception. */
75:                  static char *_cause_str;
76:                  
77:                  /* Array identifying the cause (indexed by _exception_code). */
78:                  static char *cause[] =
79:                  {
80:                      "Interrupt",
81:                      "Undefined",
82:                      "Undefined",
83:                      "Undefined",
84:                      "Load/fetch address error",
85:                      "Store address error",
86:                      "Instruction bus error",
87:                      "Data bus error",
88:                      "Syscall",
89:                      "Breakpoint",
90:                      "Reserved instruction",
91:                      "Coprocessor unusable",
92:                      "Arithmetic overflow",
93:                      "Trap",
94:                      "Reserved",
95:                      "Reserved",
96:                      "Reserved",
97:                      "Reserved",
98:                      "Reserved"
99:                  };
100:                 
101:                 // </editor-fold>
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Exception Handling
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void _general_exception_handler ( void )
113:                 
114:                   Summary:
115:                     Overrides the XC32 _weak_ _generic_exception_handler.
116:                 
117:                   Description:
118:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
119:                 
120:                   Remarks:
121:                     Refer to the XC32 User's Guide for additional information.
122:                  */
123:                 
124:                 
125:                 void _general_exception_handler ( void )
126:                 {
9D00D83C  27BDFFF8   ADDIU SP, SP, -8
9D00D840  AFBF0004   SW RA, 4(SP)
9D00D844  AFBE0000   SW FP, 0(SP)
9D00D848  03A0F021   ADDU FP, SP, ZERO
127:                     /* Mask off Mask of the ExcCode Field from the Cause Register
128:                     Refer to the MIPs Software User's manual */
129:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D00D84C  40026800   MFC0 V0, Cause
9D00D850  3042007C   ANDI V0, V0, 124
9D00D854  00021082   SRL V0, V0, 2
9D00D858  AF828024   SW V0, -32732(GP)
130:                     _excep_addr = _CP0_GET_EPC();
9D00D85C  40027000   MFC0 V0, EPC
9D00D860  AF828028   SW V0, -32728(GP)
131:                     _cause_str  = cause[_excep_code];
9D00D864  8F838024   LW V1, -32732(GP)
9D00D868  3C02A000   LUI V0, -24576
9D00D86C  00031880   SLL V1, V1, 2
9D00D870  24421184   ADDIU V0, V0, 4484
9D00D874  00621021   ADDU V0, V1, V0
9D00D878  8C420000   LW V0, 0(V0)
9D00D87C  AF82802C   SW V0, -32724(GP)
132:                     SYS_DEBUG_PRINT(SYS_ERROR_FATAL, "\n\rGeneral Exception %s (cause=%d, addr=%x).\n\r",
133:                                     _cause_str, _excep_code, _excep_addr);
134:                 
135:                     while (1)
136:                     {
137:                         SYS_DEBUG_BreakPoint();
9D00D880  7000003F   SDBBP 0
138:                     }
9D00D884  0B403620   J 0x9D00D880
9D00D888  00000000   NOP
139:                 }
140:                 
141:                 /*******************************************************************************
142:                  End of File
143:                 */
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/system/ports/src/sys_ports_static.c
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_ports_static.c
9:                   
10:                    Summary:
11:                      SYS PORTS static function implementations for the Ports System Service.
12:                  
13:                    Description:
14:                      The Ports System Service provides a simple interface to manage the ports
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Ports System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system ports configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                  
24:                  *******************************************************************************/
25:                  
26:                  //DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                  *******************************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  #include "system_config.h"
52:                  #include "system/ports/sys_ports.h"
53:                  #include "peripheral/devcon/plib_devcon.h"
54:                  #include "peripheral/ports/plib_ports.h"
55:                  #include "peripheral/int/plib_int.h"
56:                  
57:                  /******************************************************************************
58:                    Function:
59:                      SYS_PORTS_Initialize(void)
60:                  
61:                    Summary:
62:                      Initializes Ports System Service
63:                  
64:                    Description:
65:                      This function initializes different port pins/channels to the desired state.
66:                      It also remaps the pins to the desired specific function.
67:                  
68:                    Remarks:
69:                      None.
70:                  */
71:                  void SYS_PORTS_Initialize(void)
72:                  {
9D008A8C  27BDFFE8   ADDIU SP, SP, -24
9D008A90  AFBF0014   SW RA, 20(SP)
9D008A94  AFBE0010   SW FP, 16(SP)
9D008A98  03A0F021   ADDU FP, SP, ZERO
73:                  
74:                      /* PORT A Initialization */
75:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_ODC);
9D008A9C  00002021   ADDU A0, ZERO, ZERO
9D008AA0  00002821   ADDU A1, ZERO, ZERO
9D008AA4  00003021   ADDU A2, ZERO, ZERO
9D008AA8  0F40381C   JAL PLIB_PORTS_OpenDrainEnable
9D008AAC  00000000   NOP
76:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_LAT);
9D008AB0  00002021   ADDU A0, ZERO, ZERO
9D008AB4  00002821   ADDU A1, ZERO, ZERO
9D008AB8  00003021   ADDU A2, ZERO, ZERO
9D008ABC  0F40380C   JAL PLIB_PORTS_Write
9D008AC0  00000000   NOP
77:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_TRIS ^ 0xFFFF);
9D008AC4  00002021   ADDU A0, ZERO, ZERO
9D008AC8  00002821   ADDU A1, ZERO, ZERO
9D008ACC  00003021   ADDU A2, ZERO, ZERO
9D008AD0  0F403814   JAL PLIB_PORTS_DirectionOutputSet
9D008AD4  00000000   NOP
78:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_A);
9D008AD8  00002021   ADDU A0, ZERO, ZERO
9D008ADC  00002821   ADDU A1, ZERO, ZERO
9D008AE0  0F403803   JAL PLIB_PORTS_ChangeNoticePerPortTurnOn
9D008AE4  00000000   NOP
79:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
9D008AE8  00002021   ADDU A0, ZERO, ZERO
9D008AEC  00002821   ADDU A1, ZERO, ZERO
9D008AF0  2406001F   ADDIU A2, ZERO, 31
9D008AF4  24070001   ADDIU A3, ZERO, 1
9D008AF8  0F4036B0   JAL .LFE497, PLIB_PORTS_ChannelModeSelect
9D008AFC  00000000   NOP
80:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNEN);
9D008B00  00002021   ADDU A0, ZERO, ZERO
9D008B04  00002821   ADDU A1, ZERO, ZERO
9D008B08  00003021   ADDU A2, ZERO, ZERO
9D008B0C  0F403834   JAL PLIB_PORTS_ChannelChangeNoticeEnable
9D008B10  00000000   NOP
81:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNPU);
9D008B14  00002021   ADDU A0, ZERO, ZERO
9D008B18  00002821   ADDU A1, ZERO, ZERO
9D008B1C  00003021   ADDU A2, ZERO, ZERO
9D008B20  0F40382C   JAL PLIB_PORTS_ChannelChangeNoticePullUpEnable
9D008B24  00000000   NOP
82:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNPD);
9D008B28  00002021   ADDU A0, ZERO, ZERO
9D008B2C  00002821   ADDU A1, ZERO, ZERO
9D008B30  00003021   ADDU A2, ZERO, ZERO
9D008B34  0F403824   JAL PLIB_PORTS_ChannelChangeNoticePullDownEnable
9D008B38  00000000   NOP
83:                      
84:                      /* PORT B Initialization */
85:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ODC);
9D008B3C  00002021   ADDU A0, ZERO, ZERO
9D008B40  24050001   ADDIU A1, ZERO, 1
9D008B44  00003021   ADDU A2, ZERO, ZERO
9D008B48  0F40381C   JAL PLIB_PORTS_OpenDrainEnable
9D008B4C  00000000   NOP
86:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_LAT);
9D008B50  00002021   ADDU A0, ZERO, ZERO
9D008B54  24050001   ADDIU A1, ZERO, 1
9D008B58  240670C0   ADDIU A2, ZERO, 28864
9D008B5C  0F40380C   JAL PLIB_PORTS_Write
9D008B60  00000000   NOP
87:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_TRIS ^ 0xFFFF);
9D008B64  00002021   ADDU A0, ZERO, ZERO
9D008B68  24050001   ADDIU A1, ZERO, 1
9D008B6C  240670C0   ADDIU A2, ZERO, 28864
9D008B70  0F403814   JAL PLIB_PORTS_DirectionOutputSet
9D008B74  00000000   NOP
88:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_B);
9D008B78  00002021   ADDU A0, ZERO, ZERO
9D008B7C  24050001   ADDIU A1, ZERO, 1
9D008B80  0F403803   JAL PLIB_PORTS_ChangeNoticePerPortTurnOn
9D008B84  00000000   NOP
89:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
9D008B88  00002021   ADDU A0, ZERO, ZERO
9D008B8C  24050001   ADDIU A1, ZERO, 1
9D008B90  24067FFC   ADDIU A2, ZERO, 32764
9D008B94  24070001   ADDIU A3, ZERO, 1
9D008B98  0F4036B0   JAL .LFE497, PLIB_PORTS_ChannelModeSelect
9D008B9C  00000000   NOP
90:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNEN);
9D008BA0  00002021   ADDU A0, ZERO, ZERO
9D008BA4  24050001   ADDIU A1, ZERO, 1
9D008BA8  00003021   ADDU A2, ZERO, ZERO
9D008BAC  0F403834   JAL PLIB_PORTS_ChannelChangeNoticeEnable
9D008BB0  00000000   NOP
91:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPU);
9D008BB4  00002021   ADDU A0, ZERO, ZERO
9D008BB8  24050001   ADDIU A1, ZERO, 1
9D008BBC  00003021   ADDU A2, ZERO, ZERO
9D008BC0  0F40382C   JAL PLIB_PORTS_ChannelChangeNoticePullUpEnable
9D008BC4  00000000   NOP
92:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPD);
9D008BC8  00002021   ADDU A0, ZERO, ZERO
9D008BCC  24050001   ADDIU A1, ZERO, 1
9D008BD0  00003021   ADDU A2, ZERO, ZERO
9D008BD4  0F403824   JAL PLIB_PORTS_ChannelChangeNoticePullDownEnable
9D008BD8  00000000   NOP
93:                  
94:                  
95:                      /* PPS Input Remapping */
96:                      PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_U1RX, INPUT_PIN_RPA4 );
9D008BDC  00002021   ADDU A0, ZERO, ZERO
9D008BE0  24050013   ADDIU A1, ZERO, 19
9D008BE4  24060002   ADDIU A2, ZERO, 2
9D008BE8  0F40375B   JAL PLIB_PORTS_RemapInput
9D008BEC  00000000   NOP
97:                      PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_U1CTS, INPUT_PIN_RPB5 );
9D008BF0  00002021   ADDU A0, ZERO, ZERO
9D008BF4  24050014   ADDIU A1, ZERO, 20
9D008BF8  24060001   ADDIU A2, ZERO, 1
9D008BFC  0F40375B   JAL PLIB_PORTS_RemapInput
9D008C00  00000000   NOP
98:                      PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_U2RX, INPUT_PIN_RPB8 );
9D008C04  00002021   ADDU A0, ZERO, ZERO
9D008C08  24050015   ADDIU A1, ZERO, 21
9D008C0C  24060004   ADDIU A2, ZERO, 4
9D008C10  0F40375B   JAL PLIB_PORTS_RemapInput
9D008C14  00000000   NOP
99:                  
100:                     /* PPS Output Remapping */
101:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_U1TX, OUTPUT_PIN_RPB4 );
9D008C18  00002021   ADDU A0, ZERO, ZERO
9D008C1C  24050001   ADDIU A1, ZERO, 1
9D008C20  2406000F   ADDIU A2, ZERO, 15
9D008C24  0F403766   JAL PLIB_PORTS_RemapOutput
9D008C28  00000000   NOP
102:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_U1RTS, OUTPUT_PIN_RPA3 );
9D008C2C  00002021   ADDU A0, ZERO, ZERO
9D008C30  24050001   ADDIU A1, ZERO, 1
9D008C34  24060003   ADDIU A2, ZERO, 3
9D008C38  0F403766   JAL PLIB_PORTS_RemapOutput
9D008C3C  00000000   NOP
103:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_U2TX, OUTPUT_PIN_RPB9 );
9D008C40  00002021   ADDU A0, ZERO, ZERO
9D008C44  24050002   ADDIU A1, ZERO, 2
9D008C48  24060014   ADDIU A2, ZERO, 20
9D008C4C  0F403766   JAL PLIB_PORTS_RemapOutput
9D008C50  00000000   NOP
104:                 
105:                     
106:                 }
9D008C54  03C0E821   ADDU SP, FP, ZERO
9D008C58  8FBF0014   LW RA, 20(SP)
9D008C5C  8FBE0010   LW FP, 16(SP)
9D008C60  27BD0018   ADDIU SP, SP, 24
9D008C64  03E00008   JR RA
9D008C68  00000000   NOP
107:                 
108:                 /******************************************************************************
109:                   Function:
110:                     PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
111:                 
112:                   Summary:
113:                     Reads the data from the I/O port.
114:                 
115:                   Description:
116:                     This function reads the data from the I/O port.
117:                 
118:                   Remarks:
119:                     None.
120:                 */
121:                 
122:                 PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
123:                 {
00000000  00000000   NOP
124:                     return PLIB_PORTS_Read( index, channel );
00000018  00000000   NOP
125:                 }
00000028  00000000   NOP
126:                 
127:                 
128:                 /******************************************************************************
129:                   Function:
130:                     void SYS_PORTS_Write( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
131:                                       		PORTS_DATA_TYPE value )
132:                 
133:                   Summary:
134:                     Writes the data from the I/O port.
135:                 
136:                   Description:
137:                     This function writes the data to the I/O port.
138:                 
139:                   Remarks:
140:                     None.
141:                 */
142:                 
143:                 void SYS_PORTS_Write( PORTS_MODULE_ID index,
144:                                       PORTS_CHANNEL channel,
145:                                       PORTS_DATA_TYPE value )
146:                 {
00000000  00000000   NOP
147:                     PLIB_PORTS_Write( index, channel, value );
0000001C  00000000   NOP
148:                 }
00000030  00000000   NOP
149:                 
150:                 /******************************************************************************
151:                   Function:
152:                     PORTS_DATA_TYPE SYS_PORTS_LatchedGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
153:                 
154:                   Summary:
155:                     Reads the data driven on the I/O port.
156:                 
157:                   Description:
158:                     This function reads the data driven on the I/O port.
159:                 
160:                   Remarks:
161:                     None.
162:                 */
163:                 
164:                 PORTS_DATA_TYPE SYS_PORTS_LatchedGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
165:                 {
00000000  00000000   NOP
166:                     SYS_ASSERT(false, "This API is not supported on this device");
167:                     /* TODO: Call corresponding PLIB API */
168:                     return 0;
00000014  00000000   NOP
169:                 }
00000018  00000000   NOP
170:                 
171:                 /******************************************************************************
172:                   Function:
173:                     void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
174:                 	                         PORTS_DATA_TYPE value,
175:                                          PORTS_DATA_MASK mask )
176:                 
177:                   Summary:
178:                     Sets the selected digital port/latch based on the mask.
179:                 
180:                   Description:
181:                     This function sets the selected digital port/latch relative to the mask.
182:                 
183:                   Remarks:
184:                     None.
185:                 */
186:                 
187:                 void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
188:                                     PORTS_DATA_TYPE value,
189:                                     PORTS_DATA_MASK mask )
190:                 {
00000000  00000000   NOP
191:                     PLIB_PORTS_Set( index, channel, value, mask );
00000024  00000000   NOP
192:                 }
00000040  00000000   NOP
193:                 
194:                 
195:                 /******************************************************************************
196:                   Function:
197:                     void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
198:                                            PORTS_DATA_MASK clearMask )
199:                 
200:                   Summary:
201:                     Clears the selected digital port.
202:                 
203:                   Description:
204:                     This function clears the selected digital port.
205:                 
206:                   Remarks:
207:                     None.
208:                 */
209:                 
210:                 void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
211:                                            PORTS_DATA_MASK clearMask )
212:                 {
00000000  00000000   NOP
213:                     PLIB_PORTS_Clear ( index, channel, clearMask );
00000020  00000000   NOP
214:                 }
00000038  00000000   NOP
215:                 
216:                 
217:                 /******************************************************************************
218:                   Function:
219:                     void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
220:                 								SYS_PORTS_PIN_DIRECTION pinDir,
221:                 								PORTS_CHANNEL channel,
222:                 								PORTS_DATA_MASK mask )
223:                   Summary:
224:                     Enables the direction for the selected port.
225:                 
226:                   Description:
227:                     This function enables the direction for the selected port.
228:                 
229:                   Remarks:
230:                     None.
231:                 */
232:                 
233:                 void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
234:                                              SYS_PORTS_PIN_DIRECTION pinDir,
235:                                              PORTS_CHANNEL channel,
236:                                              PORTS_DATA_MASK mask )
237:                 {
00000000  00000000   NOP
238:                     if (pinDir == SYS_PORTS_DIRECTION_INPUT)
00000024  00000000   NOP
239:                     {
240:                         PLIB_PORTS_DirectionInputSet(index, channel, mask);
00000034  00000000   NOP
241:                     }
242:                     else
243:                     {
244:                         PLIB_PORTS_DirectionOutputSet(index, channel, mask);
00000054  00000000   NOP
245:                     }
246:                 }
0000006C  00000000   NOP
247:                 
248:                 
249:                 /******************************************************************************
250:                   Function:
251:                     PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index,
252:                                                             PORTS_CHANNEL channel )
253:                 
254:                   Summary:
255:                     Reads the port direction for the selected port.
256:                 
257:                   Description:
258:                     This function reads the port direction for the selected port.
259:                 
260:                   Remarks:
261:                     None.
262:                 */
263:                 
264:                 PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
265:                 {
00000000  00000000   NOP
266:                     return PLIB_PORTS_DirectionGet( index, channel );
00000018  00000000   NOP
267:                 }
00000028  00000000   NOP
268:                 
269:                 
270:                 /******************************************************************************
271:                   Function:
272:                     void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
273:                                            PORTS_DATA_MASK toggleMask )
274:                 
275:                   Summary:
276:                     Toggles the selected digital port pins.
277:                 
278:                   Description:
279:                     This function toggles the selected digital port pins.
280:                 
281:                   Remarks:
282:                     None.
283:                 */
284:                 
285:                 void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
286:                                        PORTS_DATA_MASK toggleMask )
287:                 {
00000000  00000000   NOP
288:                     PLIB_PORTS_Toggle( index, channel, toggleMask );
00000020  00000000   NOP
289:                 }
00000038  00000000   NOP
290:                 
291:                 
292:                 /******************************************************************************
293:                   Function:
294:                     void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
295:                                                      PORTS_DATA_MASK mask )
296:                 
297:                   Summary:
298:                     Enables the open drain functionality for the selected port.
299:                 
300:                   Description:
301:                     This function enables the open drain functionality for the selected port.
302:                 
303:                   Remarks:
304:                     None.
305:                 */
306:                 
307:                 void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
308:                                                 PORTS_DATA_MASK mask )
309:                 {
00000000  00000000   NOP
310:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
311:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
00000020  00000000   NOP
312:                     {
313:                         PLIB_PORTS_OpenDrainEnable( index, channel, mask );
00000034  00000000   NOP
314:                     }
315:                 #endif
316:                 }
0000004C  00000000   NOP
317:                 
318:                 
319:                 /******************************************************************************
320:                   Function:
321:                     void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
322:                                                      PORTS_DATA_MASK mask )
323:                 
324:                   Summary:
325:                     Disables the open drain functionality for the selected port.
326:                 
327:                   Description:
328:                     This function disables the open drain functionality for the selected port.
329:                 
330:                   Remarks:
331:                     None.
332:                 */
333:                 
334:                 void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
335:                                                  PORTS_DATA_MASK mask )
336:                 {
00000000  00000000   NOP
337:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
338:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
00000020  00000000   NOP
339:                     {
340:                         PLIB_PORTS_OpenDrainDisable( index, channel, mask );
00000034  00000000   NOP
341:                     }
342:                 #endif
343:                 }
0000004C  00000000   NOP
344:                 
345:                 // *****************************************************************************
346:                 /* Function:
347:                     PORTS_DATA_TYPE SYS_PORTS_InterruptStatusGet
348:                     ( 
349:                         PORTS_MODULE_ID index, 
350:                         PORTS_CHANNEL channel 
351:                     )
352:                 
353:                   Summary:
354:                     Reads the data from the I/O port.
355:                 	<p><b>Implementation:</b> Dynamic</p>
356:                 
357:                   Description:
358:                     This function reads the data from the I/O port.
359:                 
360:                 */
361:                 
362:                 PORTS_DATA_TYPE SYS_PORTS_InterruptStatusGet
363:                 ( 
364:                     PORTS_MODULE_ID index, 
365:                     PORTS_CHANNEL channel 
366:                 )
367:                 {
00000000  00000000   NOP
368:                     SYS_ASSERT(false, "This API is not supported on this device");
369:                     return 0;
00000014  00000000   NOP
370:                 }
00000018  00000000   NOP
371:                 
372:                 // *****************************************************************************
373:                 // *****************************************************************************
374:                 // Section: SYS Change Notification Pins Routines
375:                 // *****************************************************************************
376:                 // *****************************************************************************
377:                 
378:                 /******************************************************************************
379:                   Function:
380:                     void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
381:                 
382:                   Summary:
383:                     Globally enables the change notification.
384:                 
385:                   Description:
386:                     This function globally enables the change notification.
387:                 
388:                   Remarks:
389:                     None.
390:                 */
391:                 
392:                 void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
393:                 {
00000000  00000000   NOP
394:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
395:                     if(PLIB_PORTS_ExistsChangeNotice(index))
396:                     {
397:                         PLIB_PORTS_ChangeNoticeEnable( index );
398:                     }
399:                 #endif
400:                 }
00000010  00000000   NOP
401:                 
402:                 /******************************************************************************
403:                   Function:
404:                     void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
405:                 
406:                   Summary:
407:                     Globally disables the change notification.
408:                 
409:                   Description:
410:                     This function globally disables the change notification.
411:                 
412:                   Remarks:
413:                     None.
414:                 */
415:                 
416:                 void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
417:                 {
00000000  00000000   NOP
418:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
419:                     if(PLIB_PORTS_ExistsChangeNotice(index))
420:                     {
421:                         PLIB_PORTS_ChangeNoticeDisable( index );
422:                     }
423:                 #endif
424:                 }
00000010  00000000   NOP
425:                 
426:                 /******************************************************************************
427:                   Function:
428:                     void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
429:                 
430:                   Summary:
431:                     Globally disables the change notification for the selected port.
432:                 
433:                   Description:
434:                     This function globally disables the change notification for the selected port.
435:                 
436:                   Remarks:
437:                     None.
438:                 */
439:                 
440:                 void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
441:                 {
00000000  00000000   NOP
442:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
443:                     if(PLIB_PORTS_ExistsChangeNotice(index))
444:                     {
445:                         PLIB_PORTS_ChangeNoticeDisable( index );
446:                     }
447:                 #endif
448:                 }
00000010  00000000   NOP
449:                 
450:                 
451:                 /******************************************************************************
452:                   Function:
453:                     void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
454:                                                              PORTS_CHANGE_NOTICE_PIN pinNum,
455:                                                              SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
456:                 
457:                   Summary:
458:                     Enables the change notification for the selected port.
459:                 
460:                   Description:
461:                     This function enables the change notification for the selected port.
462:                 
463:                   Remarks:
464:                     None.
465:                 */
466:                 
467:                 void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
468:                                                          PORTS_CHANGE_NOTICE_PIN pinNum,
469:                                                          SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
470:                 {
00000000  00000000   NOP
471:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
472:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
473:                     {
474:                         switch(value)
475:                         {
476:                             case SYS_PORTS_PULLUP_DISABLE:
477:                                 PLIB_PORTS_ChangeNoticePullUpDisable(index, pinNum);
478:                                 break;
479:                             case SYS_PORTS_PULLUP_ENABLE:
480:                                 PLIB_PORTS_ChangeNoticePullUpEnable(index, pinNum);
481:                                 break;
482:                         }
483:                     }
484:                 #endif
485:                 
486:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
487:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
488:                     {
489:                         PLIB_PORTS_PinChangeNoticeEnable( index, pinNum );
490:                     }
491:                 #endif
492:                 }
00000018  00000000   NOP
493:                 
494:                 
495:                 /******************************************************************************
496:                   Function:
497:                     void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
498:                                                               PORTS_CHANGE_NOTICE_PIN pinNum )
499:                 
500:                   Summary:
501:                     Disables the change notification for the selected port.
502:                 
503:                   Description:
504:                     This function disables the change notification for the selected port.
505:                 
506:                   Remarks:
507:                     None.
508:                 */
509:                 
510:                 void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
511:                                                           PORTS_CHANGE_NOTICE_PIN pinNum )
512:                 {
00000000  00000000   NOP
513:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
514:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
515:                     {
516:                         PLIB_PORTS_PinChangeNoticeDisable( index, pinNum );
517:                     }
518:                 #endif
519:                 }
00000014  00000000   NOP
520:                 
521:                 
522:                 /******************************************************************************
523:                   Function:
524:                     void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
525:                 
526:                   Summary:
527:                     Enables the change notification for the selected port in Sleep or Idle mode.
528:                 
529:                   Description:
530:                     This function enables the change notification for the selected port in Sleep
531:                     or Idle mode.
532:                 
533:                   Remarks:
534:                     None.
535:                 */
536:                 
537:                 void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
538:                 {
00000000  00000000   NOP
539:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
540:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
541:                     {
542:                         PLIB_PORTS_ChangeNoticeInIdleEnable( index );
543:                     }
544:                 #endif
545:                 }
00000010  00000000   NOP
546:                 
547:                 
548:                 // *****************************************************************************
549:                 /* Function:
550:                     void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index)
551:                 
552:                   Summary:
553:                     Disables the change notification for the selected port in Sleep or Idle mode.
554:                 
555:                   Description:
556:                     This function disables the change notification for the selected port in Sleep
557:                     or Idle mode.
558:                 
559:                   Remarks:
560:                     None.
561:                 */
562:                 
563:                 void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index )
564:                 {
00000000  00000000   NOP
565:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
566:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
567:                     {
568:                         PLIB_PORTS_ChangeNoticeInIdleDisable( index );
569:                     }
570:                 #endif
571:                 }
00000010  00000000   NOP
572:                 
573:                 
574:                 // *****************************************************************************
575:                 /* Function:
576:                     void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
577:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
578:                 
579:                   Summary:
580:                     Enables weak pull-up on change notification pin.
581:                 
582:                   Description:
583:                     This function enables weak pull-up on change notification pin.
584:                 
585:                   Remarks:
586:                     None.
587:                 */
588:                 
589:                 void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
590:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
591:                 {
00000000  00000000   NOP
592:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
593:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
594:                     {
595:                         PLIB_PORTS_ChangeNoticePullUpEnable ( index, pinNum );
596:                     }
597:                 #endif
598:                 }
00000014  00000000   NOP
599:                 
600:                 
601:                 // *****************************************************************************
602:                 /* Function:
603:                     void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
604:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
605:                 
606:                   Summary:
607:                     Disables pull-up on input change.
608:                 
609:                   Description:
610:                     This function disables pull-up on input change.
611:                 
612:                   Remarks:
613:                     None.
614:                 */
615:                 
616:                 void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
617:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
618:                 {
00000000  00000000   NOP
619:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
620:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
621:                     {
622:                         PLIB_PORTS_ChangeNoticePullUpDisable ( index, pinNum );
623:                     }
624:                 #endif
625:                 }
00000014  00000000   NOP
626:                 
627:                 
628:                 // *****************************************************************************
629:                 // *****************************************************************************
630:                 // Section: SYS PORT PINS Control Routines
631:                 // *****************************************************************************
632:                 // *****************************************************************************
633:                 
634:                 // *****************************************************************************
635:                 /* Function:
636:                     void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
637:                     								PORTS_PIN_MODE mode)
638:                 
639:                   Summary:
640:                     Enables the selected pin as analog or digital.
641:                 
642:                   Description:
643:                     This function enables the selected pin as analog or digital.
644:                 
645:                  Remarks:
646:                     None.
647:                 */
648:                 
649:                 void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
650:                 								PORTS_PIN_MODE mode)
651:                 {
00000000  00000000   NOP
652:                 #if defined(PLIB_PORTS_ExistsPinMode)
653:                     if(PLIB_PORTS_ExistsPinMode(index))
0000001C  00000000   NOP
654:                     {
655:                         PLIB_PORTS_PinModeSelect ( index, pin, mode);
00000030  00000000   NOP
656:                     }
657:                 #endif
658:                 }
00000044  00000000   NOP
659:                 
660:                 
661:                 // *****************************************************************************
662:                 /* Function:
663:                     void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
664:                                               PORTS_CHANNEL channel,
665:                                               PORTS_BIT_POS bitPos
666:                                               bool value )
667:                   Summary:
668:                     Writes the selected digital pin.
669:                 
670:                   Description:
671:                     This function writes the selected digital pin.
672:                 
673:                   Remarks:
674:                     None.
675:                 */
676:                 
677:                 void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
678:                                           PORTS_CHANNEL channel,
679:                                           PORTS_BIT_POS bitPos,
680:                                           bool value )
681:                 {
00000000  00000000   NOP
682:                     PLIB_PORTS_PinWrite ( index, channel, bitPos, value );
00000024  00000000   NOP
683:                 }
00000040  00000000   NOP
684:                 
685:                 
686:                 // *****************************************************************************
687:                 /* Function:
688:                     bool SYS_PORTS_PinLatchedGet ( PORTS_MODULE_ID index,
689:                                              PORTS_CHANNEL channel,
690:                                              PORTS_BIT_POS bitPos )
691:                 
692:                   Summary:
693:                     Reads the data driven on selected digital pin.
694:                 
695:                   Description:
696:                     This function reads the driven data on selected digital pin.
697:                 
698:                   Remarks:
699:                     None.
700:                 */
701:                 
702:                 bool SYS_PORTS_PinLatchedGet ( PORTS_MODULE_ID index,
703:                                          PORTS_CHANNEL channel,
704:                                          PORTS_BIT_POS bitPos )
705:                 {
00000000  00000000   NOP
706:                     SYS_ASSERT(false, "This API is not supported on this device");
707:                     /* TODO: Call corresponding PLIB API */
708:                     return false;
00000018  00000000   NOP
709:                 }
0000001C  00000000   NOP
710:                 
711:                 
712:                 // *****************************************************************************
713:                 /* Function:
714:                     bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
715:                                              PORTS_CHANNEL channel,
716:                                              PORTS_BIT_POS bitPos )
717:                 
718:                   Summary:
719:                     Reads the selected digital pin.
720:                 
721:                   Description:
722:                     This function reads the selected digital pin.
723:                 
724:                   Remarks:
725:                     None.
726:                 */
727:                 
728:                 bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
729:                                          PORTS_CHANNEL channel,
730:                                          PORTS_BIT_POS bitPos )
731:                 {
00000000  00000000   NOP
732:                     return PLIB_PORTS_PinGet ( index, channel, bitPos );
0000001C  00000000   NOP
733:                 }
00000030  00000000   NOP
734:                 
735:                 
736:                 // *****************************************************************************
737:                 /* Function:
738:                     void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
739:                                                PORTS_CHANNEL channel,
740:                                                PORTS_BIT_POS bitPos )
741:                 
742:                   Summary:
743:                     Toggles the selected digital pin.
744:                 
745:                   Description:
746:                     This function toggles the selected digital pin.
747:                 
748:                   Remarks:
749:                     None.
750:                 */
751:                 
752:                 void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
753:                                            PORTS_CHANNEL channel,
754:                                            PORTS_BIT_POS bitPos )
755:                 {
00000000  00000000   NOP
756:                     PLIB_PORTS_PinToggle ( index, channel, bitPos );
0000001C  00000000   NOP
757:                 }
00000030  00000000   NOP
758:                 
759:                 
760:                 // *****************************************************************************
761:                 /* Function:
762:                     void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
763:                                            PORTS_CHANNEL channel,
764:                                            PORTS_BIT_POS bitPos )
765:                 
766:                   Summary:
767:                     Sets the selected digital pin/latch.
768:                 
769:                   Description:
770:                     This function sets the selected digital pin/latch.
771:                 
772:                   Remarks:
773:                     None.
774:                 */
775:                 
776:                 void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
777:                                        PORTS_CHANNEL channel,
778:                                        PORTS_BIT_POS bitPos )
779:                 {
00000000  00000000   NOP
780:                     PLIB_PORTS_PinSet( index, channel, bitPos );
0000001C  00000000   NOP
781:                 }
00000030  00000000   NOP
782:                 
783:                 
784:                 // *****************************************************************************
785:                 /* Function:
786:                     void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
787:                                               PORTS_CHANNEL channel,
788:                                               PORTS_BIT_POS bitPos )
789:                 
790:                   Summary:
791:                     Clears the selected digital pin.
792:                 
793:                   Description:
794:                     This function clears the selected digital pin.
795:                 
796:                   Remarks:
797:                     None.
798:                 */
799:                 
800:                 void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
801:                                           PORTS_CHANNEL channel,
802:                                           PORTS_BIT_POS bitPos )
803:                 {
00000000  00000000   NOP
804:                     PLIB_PORTS_PinClear ( index, channel, bitPos );
0000001C  00000000   NOP
805:                 }
00000030  00000000   NOP
806:                 
807:                 
808:                 // *****************************************************************************
809:                 /* Function:
810:                     void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
811:                                                      SYS_PORTS_PIN_DIRECTION pinDir,
812:                                                      PORTS_CHANNEL channel,
813:                                                      PORTS_BIT_POS bitPos )
814:                   Summary:
815:                     Enables the direction for the selected pin.
816:                 
817:                   Description:
818:                     This function enables the direction for the selected pin.
819:                 
820:                   Remarks:
821:                     None.
822:                 */
823:                 
824:                 void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
825:                                                  SYS_PORTS_PIN_DIRECTION pinDir,
826:                                                  PORTS_CHANNEL channel,
827:                                                  PORTS_BIT_POS bitPos )
828:                 {
00000000  00000000   NOP
829:                     if (pinDir == SYS_PORTS_DIRECTION_OUTPUT)
00000020  00000000   NOP
830:                     {
831:                         PLIB_PORTS_PinDirectionOutputSet(index, channel, bitPos);
0000002C  00000000   NOP
832:                     }
833:                     else
834:                     {
835:                         PLIB_PORTS_PinDirectionInputSet(index, channel, bitPos);
00000048  00000000   NOP
836:                     }
837:                 }
0000005C  00000000   NOP
838:                 
839:                 
840:                 // *****************************************************************************
841:                 /* Function:
842:                     void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
843:                                                         PORTS_CHANNEL channel,
844:                                                         PORTS_BIT_POS bitPos )
845:                 
846:                   Summary:
847:                     Enables the open-drain functionality for the selected pin.
848:                 
849:                   Description:
850:                     This function enables the open-drain functionality for the selected pin.
851:                 
852:                   Remarks:
853:                     None.
854:                 */
855:                 
856:                 void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
857:                                                     PORTS_CHANNEL channel,
858:                                                     PORTS_BIT_POS bitPos )
859:                 {
00000000  00000000   NOP
860:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
861:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
0000001C  00000000   NOP
862:                     {
863:                         PLIB_PORTS_PinOpenDrainEnable ( index, channel, bitPos );
00000030  00000000   NOP
864:                     }
865:                 #endif
866:                 }
00000044  00000000   NOP
867:                 
868:                 
869:                 // *****************************************************************************
870:                 /* Function:
871:                     void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
872:                                                          PORTS_CHANNEL channel,
873:                                                          PORTS_BIT_POS bitPos )
874:                 
875:                   Summary:
876:                     Disables the open-drain functionality for the selected pin.
877:                 
878:                   Description:
879:                     This function disables the open-drain functionality for the selected pin.
880:                 
881:                   Remarks:
882:                     None.
883:                 */
884:                 
885:                 void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
886:                                                      PORTS_CHANNEL channel,
887:                                                      PORTS_BIT_POS bitPos )
888:                 {
00000000  00000000   NOP
889:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
890:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
0000001C  00000000   NOP
891:                     {
892:                         PLIB_PORTS_PinOpenDrainDisable ( index, channel, bitPos );
00000030  00000000   NOP
893:                     }
894:                 #endif
895:                 }
00000044  00000000   NOP
896:                 
897:                 
898:                 // *****************************************************************************
899:                 /* Function:
900:                     void SYS_PORTS_PinPullUpEnable ( PORTS_MODULE_ID index, 
901:                                                         PORTS_CHANNEL channel,
902:                                                         PORTS_BIT_POS bitPos )
903:                 
904:                   Summary:
905:                     Enables the pull-up functionality for the selected pin.
906:                 	<p><b>Implementation:</b> Dynamic</p>
907:                 
908:                   Description:
909:                     This function enables the pull-up functionality for the selected pin.
910:                 
911:                   Remarks:
912:                     Not all features are available on all devices. Refer to the specific device
913:                     data sheet for availability.
914:                 */
915:                 
916:                 void SYS_PORTS_PinPullUpEnable ( PORTS_MODULE_ID index, 
917:                                                     PORTS_CHANNEL channel,
918:                                                     PORTS_BIT_POS bitPos )
919:                 {
00000000  00000000   NOP
920:                     SYS_ASSERT(false, "This API is not supported on this device");
921:                     return;
00000018  00000000   NOP
922:                 }
0000001C  00000000   NOP
923:                 
924:                 
925:                 // *****************************************************************************
926:                 /* Function:
927:                     void SYS_PORTS_PinPullUpDisable ( PORTS_MODULE_ID index, 
928:                                                          PORTS_CHANNEL channel,
929:                                                          PORTS_BIT_POS bitPos )
930:                 
931:                   Summary:
932:                     Disables the pull-up functionality for the selected pin.
933:                 	<p><b>Implementation:</b> Dynamic</p>
934:                 
935:                   Description:
936:                     This function disables the pull-up functionality for the selected pin.
937:                 
938:                   Remarks:
939:                     Not all features are available on all devices. Refer to the specific device
940:                     data sheet for availability.
941:                 */
942:                 
943:                 void SYS_PORTS_PinPullUpDisable ( PORTS_MODULE_ID index, 
944:                                                      PORTS_CHANNEL channel,
945:                                                      PORTS_BIT_POS bitPos )
946:                 {
00000000  00000000   NOP
947:                     SYS_ASSERT(false, "This API is not supported on this device");
948:                     return;
00000018  00000000   NOP
949:                 }
0000001C  00000000   NOP
950:                 
951:                 
952:                 // *****************************************************************************
953:                 /* Function:
954:                     void SYS_PORTS_PinPullDownEnable ( PORTS_MODULE_ID index, 
955:                                                         PORTS_CHANNEL channel,
956:                                                         PORTS_BIT_POS bitPos )
957:                 
958:                   Summary:
959:                     Enables the pull-down functionality for the selected pin.
960:                 	<p><b>Implementation:</b> Dynamic</p>
961:                 
962:                   Description:
963:                     This function enables the pull-down functionality for the selected pin.
964:                 
965:                   Remarks:
966:                     Not all features are available on all devices. Refer to the specific device
967:                     data sheet for availability.
968:                 */
969:                 
970:                 void SYS_PORTS_PinPullDownEnable ( PORTS_MODULE_ID index, 
971:                                                     PORTS_CHANNEL channel,
972:                                                     PORTS_BIT_POS bitPos )
973:                 {
00000000  00000000   NOP
974:                     SYS_ASSERT(false, "This API is not supported on this device");
975:                     return;
00000018  00000000   NOP
976:                 }
0000001C  00000000   NOP
977:                 
978:                 
979:                 // *****************************************************************************
980:                 /* Function:
981:                     void SYS_PORTS_PinPullDownDisable ( PORTS_MODULE_ID index, 
982:                                                          PORTS_CHANNEL channel,
983:                                                          PORTS_BIT_POS bitPos )
984:                 
985:                   Summary:
986:                     Disables the pull-down functionality for the selected pin.
987:                 	<p><b>Implementation:</b> Dynamic</p>
988:                 
989:                   Description:
990:                     This function disables the pull-down functionality for the selected pin.
991:                 
992:                   Remarks:
993:                     Not all features are available on all devices. Refer to the specific device
994:                     data sheet for availability.
995:                 */
996:                 
997:                 void SYS_PORTS_PinPullDownDisable ( PORTS_MODULE_ID index, 
998:                                                      PORTS_CHANNEL channel,
999:                                                      PORTS_BIT_POS bitPos )
1000:                {
00000000  00000000   NOP
1001:                    SYS_ASSERT(false, "This API is not supported on this device");
1002:                    return;
00000018  00000000   NOP
1003:                }
0000001C  00000000   NOP
1004:                                                     
1005:                                                     
1006:                /******************************************************************************
1007:                  Function:
1008:                    void SYS_PORTS_InterruptEnable
1009:                    (
1010:                        PORTS_MODULE_ID index,
1011:                        PORTS_CHANNEL channel,
1012:                        PORTS_BIT_POS bitPos,
1013:                        PORTS_PIN_INTERRUPT_TYPE pinInterruptType
1014:                    )
1015:                
1016:                  Summary:
1017:                    Enables the change notification interrupt for the selected port pin.
1018:                
1019:                  Description:
1020:                    This function enables the change notification interrupt of selected type
1021:                    for the selected port pin.
1022:                
1023:                  Remarks:
1024:                    None.
1025:                */
1026:                void SYS_PORTS_InterruptEnable
1027:                (
1028:                    PORTS_MODULE_ID index,
1029:                    PORTS_CHANNEL channel,
1030:                    PORTS_BIT_POS bitPos,
1031:                    PORTS_PIN_INTERRUPT_TYPE pinInterruptType
1032:                )
1033:                {
00000000  00000000   NOP
1034:                    SYS_ASSERT(false, "This API is not supported on this device");
1035:                    return;
0000001C  00000000   NOP
1036:                }
00000020  00000000   NOP
1037:                
1038:                
1039:                // *****************************************************************************
1040:                /* Function:
1041:                    void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
1042:                							  PORTS_REMAP_INPUT_FUNCTION function,
1043:                							  PORTS_REMAP_INPUT_PIN      remapPin )
1044:                
1045:                  Summary:
1046:                    Input/Output (I/O) function remapping.
1047:                
1048:                  Description:
1049:                    This function controls the I/O function remapping.
1050:                
1051:                  Precondition:
1052:                    None.
1053:                */	
1054:                void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
1055:                						   PORTS_REMAP_INPUT_FUNCTION function,
1056:                						   PORTS_REMAP_INPUT_PIN      remapPin )
1057:                {
00000000  00000000   NOP
1058:                #if defined(PLIB_PORTS_ExistsRemapInput)
1059:                    if(PLIB_PORTS_ExistsRemapInput(index))
0000001C  00000000   NOP
1060:                    {
1061:                        PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
00000030  00000000   NOP
1062:                        PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
0000003C  00000000   NOP
1063:                        PLIB_PORTS_RemapInput( index, function, remapPin);
0000004C  00000000   NOP
1064:                    }
1065:                #endif
1066:                }
00000060  00000000   NOP
1067:                
1068:                // *****************************************************************************
1069:                /* Function:
1070:                    void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
1071:                                                      PORTS_REMAP_OUTPUT_FUNCTION function,
1072:                                                      PORTS_REMAP_OUTPUT_PIN      remapPin )
1073:                
1074:                  Summary:
1075:                    Input/Output (I/O) function remapping.
1076:                
1077:                  Description:
1078:                    This function controls the I/O function remapping.
1079:                
1080:                  Precondition:
1081:                    None.
1082:                */
1083:                void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
1084:                						    PORTS_REMAP_OUTPUT_FUNCTION function,
1085:                						    PORTS_REMAP_OUTPUT_PIN      remapPin )
1086:                {
00000000  00000000   NOP
1087:                #if defined(PLIB_PORTS_ExistsRemapOutput)
1088:                    if(PLIB_PORTS_ExistsRemapOutput(index))
0000001C  00000000   NOP
1089:                    {
1090:                        PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
00000030  00000000   NOP
1091:                        PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
0000003C  00000000   NOP
1092:                        PLIB_PORTS_RemapOutput( index, function, remapPin);
0000004C  00000000   NOP
1093:                    }
1094:                #endif
1095:                }
00000060  00000000   NOP
1096:                
1097:                /*******************************************************************************
1098:                 End of File
1099:                */
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon_pic32mx.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/osc/plib_osc.h"
55:                  #include "peripheral/pcache/plib_pcache.h"
56:                  #include "peripheral/bmx/plib_bmx.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  //
70:                  #ifndef PLIB_PCACHE_PREFETCH_ENABLE_ALL
71:                  #define PLIB_PCACHE_PREFETCH_ENABLE_ALL 3
72:                  #endif
73:                  
74:                  // *****************************************************************************
75:                  /* Function:
76:                      void SYS_DEVCON_PerformanceConfig( void )
77:                  
78:                    Summary:
79:                      Configures the PFM wait states and prefetch (cache) module for maximum 
80:                      performance.
81:                  
82:                    Description:
83:                      This function configures the PFM wait states and prefetch (cache) module 
84:                      for maximum performance.
85:                  
86:                    Remarks:
87:                      None.
88:                  */
89:                  
90:                  void __attribute__((nomips16)) SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
91:                  {
9D00C98C  27BDFFE0   ADDIU SP, SP, -32
9D00C990  AFBF001C   SW RA, 28(SP)
9D00C994  AFBE0018   SW FP, 24(SP)
9D00C998  03A0F021   ADDU FP, SP, ZERO
9D00C99C  AFC40020   SW A0, 32(FP)
92:                      bool int_flag = false;
9D00C9A0  A3C00010   SB ZERO, 16(FP)
93:                      register unsigned long tmp = 0;
9D00C9A4  0000F821   ADDU RA, ZERO, ZERO
94:                  
95:                      /* Set kseg0 coherency algorithm to "cacheable, non-coherent, write-back, 
96:                       * write-allocate. This is needed for the prefetch buffer */
97:                      asm("mfc0 %0,$16,0" :  "=r"(tmp));
9D00C9A8  40028000   MFC0 V0, Config
9D00C9AC  0040F821   ADDU RA, V0, ZERO
98:                      tmp = (tmp & ~7) | 3;
9D00C9B0  2403FFF8   ADDIU V1, ZERO, -8
9D00C9B4  03E31024   AND V0, RA, V1
9D00C9B8  345F0003   ORI RA, V0, 3
99:                      asm("mtc0 %0,$16,0" :: "r" (tmp));
9D00C9BC  409F8000   MTC0 RA, Config
100:                 
101:                     /* Set the PFM wait states based on the system clock */
102:                     #if defined(PLIB_PCACHE_ExistsWaitState)
103:                     if (PLIB_PCACHE_ExistsWaitState(PCACHE_ID_0))
104:                     {
105:                         int ws; /* number of wait states */
106:                         if (sysclk <= 30000000)
107:                             ws = 0;
108:                         else if (sysclk <= 60000000)
109:                             ws = 1;
110:                         else if (sysclk <= 80000000)
111:                             ws = 2;
112:                         else
113:                             ws = 3;
114:                         /* Interrupts must be disabled when changing wait states */
115:                         int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
116:                 
117:                         PLIB_PCACHE_WaitStateSet(PCACHE_ID_0, ws);
118:                 
119:                         if (int_flag)
120:                         {
121:                             PLIB_INT_Enable(INT_ID_0);
122:                             int_flag = false;
123:                         }
124:                     }
125:                     #endif // defined(PLIB_PCACHE_ExistsWaitState)
126:                 
127:                     /* Interrupts must be disabled when enabling the Prefetch Cache Module */
128:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00C9C0  00002021   ADDU A0, ZERO, ZERO
9D00C9C4  0F40383C   JAL PLIB_INT_GetStateAndDisable
9D00C9C8  00000000   NOP
9D00C9CC  30420001   ANDI V0, V0, 1
9D00C9D0  0002102B   SLTU V0, ZERO, V0
9D00C9D4  A3C20010   SB V0, 16(FP)
129:                 
130:                     /* Enable Prefetch Cache Module */
131:                     #if defined(PLIB_PCACHE_ExistsPrefetchEnable)
132:                     if (PLIB_PCACHE_ExistsPrefetchEnable(PCACHE_ID_0))
133:                     {
134:                         PLIB_PCACHE_PrefetchEnableSet(PCACHE_ID_0, PLIB_PCACHE_PREFETCH_ENABLE_ALL);
135:                     }
136:                     #endif
137:                 
138:                     /* Set the SRAM wait states to zero */
139:                     #if defined (PLIB_BMX_ExistsDataRamWaitState)
140:                     if (PLIB_BMX_ExistsDataRamWaitState(BMX_ID_0))
9D00C9D8  3C02BF88   LUI V0, -16504
9D00C9DC  0F40392A   JAL PLIB_BMX_ExistsDataRamWaitState
9D00C9E0  34442000   ORI A0, V0, 8192
9D00C9E4  10400005   BEQ V0, ZERO, .LVL11
9D00C9E8  00000000   NOP
141:                     {
142:                         PLIB_BMX_DataRamWaitStateSet(BMX_ID_0, PLIB_BMX_DATA_RAM_WAIT_ZERO);
9D00C9EC  3C02BF88   LUI V0, -16504
9D00C9F0  34442000   ORI A0, V0, 8192
9D00C9F4  0F403862   JAL PLIB_BMX_DataRamWaitStateSet
9D00C9F8  00002821   ADDU A1, ZERO, ZERO
143:                     }            
144:                     #endif
145:                     if (int_flag)
9D00C9FC  93C20010   LBU V0, 16(FP)
9D00CA00  10400003   BEQ V0, ZERO, .LVL12
9D00CA04  00000000   NOP
146:                     {
147:                         PLIB_INT_Enable(INT_ID_0);
9D00CA08  0F4037FA   JAL PLIB_INT_Enable
9D00CA0C  00002021   ADDU A0, ZERO, ZERO
148:                     }
149:                 }
9D00CA10  03C0E821   ADDU SP, FP, ZERO
9D00CA14  8FBF001C   LW RA, 28(SP)
9D00CA18  8FBE0018   LW FP, 24(SP)
9D00CA1C  27BD0020   ADDIU SP, SP, 32
9D00CA20  03E00008   JR RA
9D00CA24  00000000   NOP
150:                 
151:                 /*******************************************************************************
152:                  End of File
153:                 */
154:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on PIC32M Microchip microcontrollers. This file Implements 
16:                      the core interface routines for the Device Control system service.  While 
17:                      building the system service from source, ALWAYS include this file in the 
18:                      build for PIC32M devices.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Included Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "system/devcon/src/sys_devcon_local.h"
54:                  #include "peripheral/int/plib_int.h"
55:                  #include "peripheral/devcon/plib_devcon.h"
56:                  #include "peripheral/osc/plib_osc.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  /* System Device Control Instance */
71:                  SYS_DEVCON_OBJECT sysDevconObj;
72:                  
73:                  
74:                  // *****************************************************************************
75:                  // *****************************************************************************
76:                  // Section: SYS DEVCON Module Initialization Routines
77:                  // *****************************************************************************
78:                  // *****************************************************************************
79:                  
80:                  // *****************************************************************************
81:                  /* Function:
82:                      SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX           index,
83:                                                         const SYS_MODULE_INIT * const    init )
84:                  
85:                    Summary:
86:                      Initializes data for the instance of the Device Control module and opens
87:                      the specific module instance.
88:                  
89:                    Description:
90:                      This function initializes the instance of the Device Control module,
91:                      using the specified initialization data. It also initializes any
92:                      internal data structures.
93:                  
94:                    Remarks:
95:                      This routine should only be called once during system initialization
96:                      unless SYS_DEVCON_Deinitialize is first called to deinitialize the device
97:                      instance before reinitializing it. If the system was already initialized
98:                      it safely returns without causing any disturbance.
99:                  */
100:                 
101:                 SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX index,
102:                                                    const SYS_MODULE_INIT * const init )
103:                 {
9D00DB7C  27BDFFF8   ADDIU SP, SP, -8
9D00DB80  AFBE0004   SW FP, 4(SP)
9D00DB84  03A0F021   ADDU FP, SP, ZERO
9D00DB88  00801021   ADDU V0, A0, ZERO
9D00DB8C  AFC5000C   SW A1, 12(FP)
9D00DB90  A7C20008   SH V0, 8(FP)
104:                     sysDevconObj.status = SYS_STATUS_READY;
9D00DB94  24020002   ADDIU V0, ZERO, 2
9D00DB98  AF828050   SW V0, -32688(GP)
105:                 
106:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
9D00DB9C  AF80804C   SW ZERO, -32692(GP)
107:                 
108:                     return (SYS_MODULE_OBJ)SYS_DEVCON_INDEX_0;
9D00DBA0  00001021   ADDU V0, ZERO, ZERO
109:                 }
9D00DBA4  03C0E821   ADDU SP, FP, ZERO
9D00DBA8  8FBE0004   LW FP, 4(SP)
9D00DBAC  27BD0008   ADDIU SP, SP, 8
9D00DBB0  03E00008   JR RA
9D00DBB4  00000000   NOP
110:                 
111:                 
112:                 // *****************************************************************************
113:                 /* Function:
114:                     void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ                  object,
115:                                                const SYS_MODULE_INIT * const   init )
116:                 
117:                    Summary:
118:                     Reinitializes and refreshes the hardware for the instance of the Device 
119:                     Control module.
120:                 
121:                    Description:
122:                     This function reinitializes the instance of the Device Control module using 
123:                     the supplied data. It modifies the internal data structure.
124:                 
125:                    Remarks:
126:                     This operation uses the same initialization data structure as the
127:                     SYS_DEVCON_Initialize operation. This operation can be used to change the
128:                     power state of a DEVCON module. This function can be called multiple times
129:                     to reinitialize the module. This operation uses the same initialization
130:                     data structure as the Initialize operation. This operation can also be
131:                     used to refresh the hardware registers as defined by the initialization
132:                     data.
133:                 */
134:                 
135:                 void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ object,
136:                                            const SYS_MODULE_INIT * const init )
137:                 {
00000000  00000000   NOP
138:                     sysDevconObj.status = SYS_STATUS_READY;
00000014  00000000   NOP
139:                 
140:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
0000001C  00000000   NOP
141:                 }
00000020  00000000   NOP
142:                 
143:                 
144:                 // *****************************************************************************
145:                 /* Function:
146:                     void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
147:                 
148:                   Summary:
149:                     Deinitializes the specific module instance of the DEVCON module
150:                 
151:                   Description:
152:                     This function deinitializes the specific module instance disabling its operation 
153:                     (and any hardware for driver modules). Resets all of the internal data
154:                     structures and fields for the specified instance to the default settings.
155:                 
156:                   Remarks:
157:                     Once the Initialize operation has been called, the Deinitialize
158:                     operation must be called before the Initialize operation can be called
159:                     again.
160:                 */
161:                 
162:                 void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
163:                 {
00000000  00000000   NOP
164:                     sysDevconObj.status = SYS_STATUS_UNINITIALIZED;
00000010  00000000   NOP
165:                 }
00000014  00000000   NOP
166:                 
167:                 
168:                 // *****************************************************************************
169:                 /* Function:
170:                     SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
171:                 
172:                   Summary:
173:                     Returns status of the specific instance of the Device Control module.
174:                 
175:                   Description:
176:                     This function returns the status of the specific module instance.
177:                 
178:                   Remarks:
179:                     None.
180:                 */
181:                 
182:                 SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
183:                 {
00000000  00000000   NOP
184:                     return sysDevconObj.status; 
00000010  00000000   NOP
185:                 }
00000014  00000000   NOP
186:                 
187:                 
188:                 // *****************************************************************************
189:                 /* Function:
190:                     void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
191:                 
192:                   Summary:
193:                     Maintains the system Device Control state machine.
194:                 
195:                   Description:
196:                     This function is used to maintain the system Device Control internal state machine.
197:                 
198:                   Remarks:
199:                     This function is normally not called directly by an application.  It is
200:                     called by the system's Tasks routine (SYS_Tasks) or by the appropriate raw
201:                     ISR.
202:                 */
203:                 
204:                 void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
205:                 {
00000000  00000000   NOP
206:                     switch (sysDevconObj.state)
207:                     {
208:                         case SYS_DEVCON_STATE_INIT:
209:                         case SYS_DEVCON_STATE_BUSY:
210:                         case SYS_DEVCON_STATE_READY:
211:                         default:
212:                             break;
00000010  00000000   NOP
213:                     }
214:                 }
00000014  00000000   NOP
215:                 
216:                     
217:                 // *****************************************************************************
218:                 // *****************************************************************************
219:                 // Section: SYS DEVCON Client Setup Routines
220:                 // *****************************************************************************
221:                 // *****************************************************************************
222:                 
223:                 // *****************************************************************************
224:                 /* Function:
225:                     void SYS_DEVCON_SystemUnlock( void )
226:                 
227:                   Summary:
228:                     Performs a system unlock sequence by writing to the SYSKEY register.
229:                 
230:                   Description:
231:                     Performs a system unlock sequence by writing to the SYSKEY register. A 
232:                     system unlock sequence is required before performing certain actions such
233:                     as changing a clock frequency or IO unlocking.
234:                 
235:                   Remarks:
236:                     None.
237:                 */
238:                 
239:                 void SYS_DEVCON_SystemUnlock( void )
240:                 {
9D00D35C  27BDFFE0   ADDIU SP, SP, -32
9D00D360  AFBF001C   SW RA, 28(SP)
9D00D364  AFBE0018   SW FP, 24(SP)
9D00D368  03A0F021   ADDU FP, SP, ZERO
241:                     bool int_flag = false;
9D00D36C  A3C00010   SB ZERO, 16(FP)
242:                 
243:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00D370  00002021   ADDU A0, ZERO, ZERO
9D00D374  0F40383C   JAL PLIB_INT_GetStateAndDisable
9D00D378  00000000   NOP
9D00D37C  30420001   ANDI V0, V0, 1
9D00D380  0002102B   SLTU V0, ZERO, V0
9D00D384  A3C20010   SB V0, 16(FP)
244:                 
245:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
9D00D388  00002021   ADDU A0, ZERO, ZERO
9D00D38C  0F403786   JAL .LFE1153, PLIB_DEVCON_SystemUnlock
9D00D390  00000000   NOP
246:                 
247:                     if (int_flag)
9D00D394  93C20010   LBU V0, 16(FP)
9D00D398  10400004   BEQ V0, ZERO, .LVL9
9D00D39C  00000000   NOP
248:                     {
249:                         PLIB_INT_Enable(INT_ID_0);
9D00D3A0  00002021   ADDU A0, ZERO, ZERO
9D00D3A4  0F4037FA   JAL PLIB_INT_Enable
9D00D3A8  00000000   NOP
250:                     }
251:                 }
9D00D3AC  03C0E821   ADDU SP, FP, ZERO
9D00D3B0  8FBF001C   LW RA, 28(SP)
9D00D3B4  8FBE0018   LW FP, 24(SP)
9D00D3B8  27BD0020   ADDIU SP, SP, 32
9D00D3BC  03E00008   JR RA
9D00D3C0  00000000   NOP
252:                 
253:                 
254:                 // *****************************************************************************
255:                 /* Function:
256:                     void SYS_DEVCON_SystemLock( void )
257:                 
258:                   Summary:
259:                     Performs a system lock sequence by writing to the SYSKEY register.
260:                 
261:                   Description:
262:                     Performs a system lock sequence by writing to the SYSKEY register. A 
263:                     system lock sequence is required after performing the action that required
264:                     a system lock sequence.
265:                 
266:                   Remarks:
267:                     None.
268:                 */
269:                 
270:                 void SYS_DEVCON_SystemLock( void )
271:                 {
9D00D3C4  27BDFFE0   ADDIU SP, SP, -32
9D00D3C8  AFBF001C   SW RA, 28(SP)
9D00D3CC  AFBE0018   SW FP, 24(SP)
9D00D3D0  03A0F021   ADDU FP, SP, ZERO
272:                     bool int_flag = false;
9D00D3D4  A3C00010   SB ZERO, 16(FP)
273:                    
274:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00D3D8  00002021   ADDU A0, ZERO, ZERO
9D00D3DC  0F40383C   JAL PLIB_INT_GetStateAndDisable
9D00D3E0  00000000   NOP
9D00D3E4  30420001   ANDI V0, V0, 1
9D00D3E8  0002102B   SLTU V0, ZERO, V0
9D00D3EC  A3C20010   SB V0, 16(FP)
275:                 
276:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
9D00D3F0  00002021   ADDU A0, ZERO, ZERO
9D00D3F4  0F40384A   JAL PLIB_DEVCON_SystemLock
9D00D3F8  00000000   NOP
277:                 
278:                     if (int_flag)
9D00D3FC  93C20010   LBU V0, 16(FP)
9D00D400  10400004   BEQ V0, ZERO, .LVL16
9D00D404  00000000   NOP
279:                     {
280:                         PLIB_INT_Enable(INT_ID_0);
9D00D408  00002021   ADDU A0, ZERO, ZERO
9D00D40C  0F4037FA   JAL PLIB_INT_Enable
9D00D410  00000000   NOP
281:                     }
282:                 }
9D00D414  03C0E821   ADDU SP, FP, ZERO
9D00D418  8FBF001C   LW RA, 28(SP)
9D00D41C  8FBE0018   LW FP, 24(SP)
9D00D420  27BD0020   ADDIU SP, SP, 32
9D00D424  03E00008   JR RA
9D00D428  00000000   NOP
283:                 
284:                 
285:                 // *****************************************************************************
286:                 /* Function:
287:                     void SYS_DEVCON_JTAGEnable( void )
288:                 
289:                   Summary:
290:                     Enables the JTAG port on the device.
291:                 
292:                   Description:
293:                     Enables the JTAG port on the device.
294:                 
295:                   Remarks:
296:                     None.
297:                 */
298:                 
299:                 void SYS_DEVCON_JTAGEnable( void )
300:                 {
00000000  00000000   NOP
301:                     PLIB_DEVCON_JTAGPortEnable(DEVCON_ID_0);
00000010  00000000   NOP
302:                 }
0000001C  00000000   NOP
303:                 
304:                 
305:                 // *****************************************************************************
306:                 /* Function:
307:                     void SYS_DEVCON_JTAGDisable( void )
308:                 
309:                   Summary:
310:                     Disables the JTAG port on the device.
311:                 
312:                   Description:
313:                     Disables the JTAG port on the device.
314:                 
315:                   Remarks:
316:                     None.
317:                 */
318:                 
319:                 void SYS_DEVCON_JTAGDisable( void )
320:                 {
00000000  00000000   NOP
321:                     PLIB_DEVCON_JTAGPortDisable(DEVCON_ID_0);
00000010  00000000   NOP
322:                 }
0000001C  00000000   NOP
323:                 
324:                 
325:                 // *****************************************************************************
326:                 /* Function:
327:                     void SYS_DEVCON_TraceEnable( void )
328:                 
329:                   Summary:
330:                     Enables the Trace output port on the device.
331:                 
332:                   Description:
333:                     Enables the Trace output port on the device.
334:                 
335:                   Remarks:
336:                     None.
337:                 */
338:                 
339:                 void SYS_DEVCON_TraceEnable( void )
340:                 {
00000000  00000000   NOP
341:                     #if defined PLIB_DEVCON_ExistsTraceOutput
342:                         if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
343:                         {
344:                             PLIB_DEVCON_TraceOutputEnable(DEVCON_ID_0);
345:                         }
346:                     #endif
347:                 }
0000000C  00000000   NOP
348:                 
349:                 
350:                 // *****************************************************************************
351:                 /* Function:
352:                     void SYS_DEVCON_TraceDisable( void )
353:                 
354:                   Summary:
355:                     Disables the Trace output port on the device.
356:                 
357:                   Description:
358:                     Disables the Trace output port on the device.
359:                 
360:                   Remarks:
361:                     None.
362:                 */
363:                 
364:                 void SYS_DEVCON_TraceDisable( void )
365:                 {
00000000  00000000   NOP
366:                     #if defined PLIB_DEVCON_ExistsTraceOutput
367:                     if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
368:                     {
369:                         PLIB_DEVCON_TraceOutputDisable(DEVCON_ID_0);
370:                     }
371:                     #endif
372:                 }
0000000C  00000000   NOP
373:                 
374:                 
375:                 // *****************************************************************************
376:                 /* Function:
377:                     void SYS_DEVCON_PowerModeEnter(SYS_POWER_MODE pwrMode)
378:                 
379:                   Summary:
380:                     Puts the device in a low-power state.
381:                 
382:                   Description:
383:                     This function puts the device in a low-power state.
384:                 
385:                   Remarks:
386:                     None.
387:                 */
388:                 
389:                 void __attribute__((nomips16)) SYS_DEVCON_PowerModeEnter( SYS_POWER_MODE pwrMode )
390:                 {
00000000  00000000   NOP
391:                     OSC_OPERATION_ON_WAIT op = SYS_POWER_MODE_IDLE;
00000014  00000000   NOP
392:                 
393:                     switch (pwrMode)
00000018  00000000   NOP
394:                     {
395:                         case SYS_POWER_MODE_IDLE:
396:                             op = OSC_ON_WAIT_IDLE;
397:                             break;
00000038  00000000   NOP
398:                         case SYS_POWER_MODE_SLEEP:
399:                             op = OSC_ON_WAIT_SLEEP;
00000040  00000000   NOP
400:                             break;
00000048  00000000   NOP
401:                         default:
402:                             break;
00000030  00000000   NOP
403:                     }
404:                 
405:                     
406:                     #if defined PLIB_OSC_ExistsOnWaitAction
407:                     if(PLIB_OSC_ExistsOnWaitAction(OSC_ID_0))
0000004C  00000000   NOP
408:                     {
409:                         SYS_DEVCON_SystemUnlock();
00000060  00000000   NOP
410:                         PLIB_OSC_OnWaitActionSet (OSC_ID_0, op);
00000068  00000000   NOP
411:                         SYS_DEVCON_SystemLock();
00000074  00000000   NOP
412:                     }
413:                     #endif
414:                     asm volatile ( "wait" );
0000007C  00000000   NOP
415:                 }
00000080  00000000   NOP
416:                 
417:                 
418:                 /*******************************************************************************
419:                  End of File
420:                 */
421:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/system/clk/src/sys_clk_pic32mx.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_clk_static.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the oscillators
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Clock System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                      
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  //DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include "system_config.h"
59:                  #include "system_definitions.h"
60:                  #include "peripheral/osc/plib_osc.h"
61:                  #include "system/devcon/sys_devcon.h"
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: File Scope Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  /* Function:
71:                      void SYS_CLK_Static_Initialize ( const SYS_CLK_INIT const * clkInit )
72:                  
73:                    Summary:
74:                      Initializes hardware and internal data structure of the System Clock.
75:                  
76:                    Description:
77:                      This function initializes the hardware and internal data structure of System
78:                      Clock Service.
79:                  
80:                    Remarks:
81:                      This is configuration values for the static version of the Clock System Service 
82:                      module is determined by the user via the Microchip Harmony Configurator GUI.
83:                      This template will build a sys_clk_static.h and sys_clk_static.c file with 
84:                      the configuration per the user's choice.
85:                  
86:                      The objective is to eliminate the user's need to be knowledgeable in the function of
87:                      the 'configuration bits' to configure the system oscillators. 
88:                  */
89:                  
90:                  void SYS_CLK_Initialize( const SYS_CLK_INIT const * clkInit )
91:                  {
9D00CF28  27BDFFE8   ADDIU SP, SP, -24
9D00CF2C  AFBF0014   SW RA, 20(SP)
9D00CF30  AFBE0010   SW FP, 16(SP)
9D00CF34  03A0F021   ADDU FP, SP, ZERO
9D00CF38  AFC40018   SW A0, 24(FP)
92:                      SYS_DEVCON_SystemUnlock ( );
9D00CF3C  0F4034D7   JAL SYS_DEVCON_SystemUnlock
9D00CF40  00000000   NOP
93:                      
94:                      PLIB_OSC_FRCDivisorSelect( OSC_ID_0, OSC_FRC_DIV_2);
9D00CF44  00002021   ADDU A0, ZERO, ZERO
9D00CF48  24050001   ADDIU A1, ZERO, 1
9D00CF4C  0F403850   JAL PLIB_OSC_FRCDivisorSelect
9D00CF50  00000000   NOP
95:                  
96:                  
97:                  
98:                  
99:                      /* Enable Peripheral Bus 1 */
100:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 0, 1 );
9D00CF54  00002021   ADDU A0, ZERO, ZERO
9D00CF58  00002821   ADDU A1, ZERO, ZERO
9D00CF5C  24060001   ADDIU A2, ZERO, 1
9D00CF60  0F4035A0   JAL .LFE1154, PLIB_OSC_PBClockDivisorSet
9D00CF64  00000000   NOP
101:                 
102:                  
103:                     /* Disable REFCLKO1*/
104:                     PLIB_OSC_ReferenceOscDisable ( OSC_ID_0, OSC_REFERENCE_1 );
9D00CF68  00002021   ADDU A0, ZERO, ZERO
9D00CF6C  00002821   ADDU A1, ZERO, ZERO
9D00CF70  0F40388A   JAL PLIB_OSC_ReferenceOscDisable
9D00CF74  00000000   NOP
105:                     /* Disable REFCLK1_OE*/
106:                     PLIB_OSC_ReferenceOutputDisable ( OSC_ID_0, OSC_REFERENCE_1 );
9D00CF78  00002021   ADDU A0, ZERO, ZERO
9D00CF7C  00002821   ADDU A1, ZERO, ZERO
9D00CF80  0F403885   JAL PLIB_OSC_ReferenceOutputDisable
9D00CF84  00000000   NOP
107:                 
108:                     SYS_DEVCON_SystemLock ( );
9D00CF88  0F4034F1   JAL SYS_DEVCON_SystemLock
9D00CF8C  00000000   NOP
109:                 }
9D00CF90  03C0E821   ADDU SP, FP, ZERO
9D00CF94  8FBF0014   LW RA, 20(SP)
9D00CF98  8FBE0010   LW FP, 16(SP)
9D00CF9C  27BD0018   ADDIU SP, SP, 24
9D00CFA0  03E00008   JR RA
9D00CFA4  00000000   NOP
110:                 
111:                 //******************************************************************************
112:                 /* Function:
113:                     inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
114:                 
115:                   Summary:
116:                     Gets the system clock frequency in Hertz.
117:                 
118:                   Description:
119:                     This function gets the System clock frequency in Hertz.
120:                 
121:                   Precondition:
122:                     None.
123:                 
124:                   Parameters:
125:                     None.
126:                 
127:                   Returns:
128:                     System clock frequency in Hertz.
129:                 
130:                   Example:
131:                     <code>
132:                     uint32_t sysClockHz;
133:                 
134:                     sysClockHz = SYS_CLK_SystemFrequencyGet ( );
135:                     </code>
136:                 
137:                   Remarks:
138:                  */
139:                 
140:                 inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
141:                 {
9D00DDF0  27BDFFF8   ADDIU SP, SP, -8
9D00DDF4  AFBE0004   SW FP, 4(SP)
9D00DDF8  03A0F021   ADDU FP, SP, ZERO
142:                     return SYS_CLK_FREQ;
9D00DDFC  3C020131   LUI V0, 305
9D00DE00  34422D00   ORI V0, V0, 11520
143:                 }
9D00DE04  03C0E821   ADDU SP, FP, ZERO
9D00DE08  8FBE0004   LW FP, 4(SP)
9D00DE0C  27BD0008   ADDIU SP, SP, 8
9D00DE10  03E00008   JR RA
9D00DE14  00000000   NOP
144:                 
145:                 //******************************************************************************
146:                 /* Function:
147:                     inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
148:                 
149:                   Summary:
150:                     Gets the selected clock peripheral bus frequency in Hertz.
151:                 
152:                   Description:
153:                     This function gets the selected peripheral bus clock frequency in Hertz.
154:                 
155:                   Precondition:
156:                     None.
157:                 
158:                   Parameters:
159:                 	peripheralBus - Reference clock bus selection. One of the possible value from
160:                 				CLK_BUSES_PERIPHERAL enum. For devices that do not have multiple
161:                 				clock channels for Reference clock, CLK_BUS_PERIPHERAL_1 should be
162:                 				the selection.
163:                 
164:                   Returns:
165:                     Clock frequency in Hertz.
166:                 
167:                   Example:
168:                     <code>
169:                     unsigned long peripheralClockHz;
170:                 
171:                     peripheralClockHz = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_5 );
172:                     </code>
173:                 
174:                   Remarks:
175:                 	Most of the devices doesn't have multiple Peripheral clock buses. In that case, 
176:                 	pass CLK_USB_PERIPHERAL_1 as the bus number.
177:                  */
178:                 
179:                 inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
180:                 {
9D00DD14  27BDFFF8   ADDIU SP, SP, -8
9D00DD18  AFBE0004   SW FP, 4(SP)
9D00DD1C  03A0F021   ADDU FP, SP, ZERO
9D00DD20  AFC40008   SW A0, 8(FP)
181:                     return SYS_CLK_BUS_PERIPHERAL_1;
9D00DD24  3C020131   LUI V0, 305
9D00DD28  34422D00   ORI V0, V0, 11520
182:                 }
9D00DD2C  03C0E821   ADDU SP, FP, ZERO
9D00DD30  8FBE0004   LW FP, 4(SP)
9D00DD34  27BD0008   ADDIU SP, SP, 8
9D00DD38  03E00008   JR RA
9D00DD3C  00000000   NOP
183:                 
184:                 
185:                 //******************************************************************************
186:                 /* Function:
187:                     inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
188:                 
189:                   Summary:
190:                     Gets the selected Reference clock bus frequency in Hertz.
191:                 
192:                   Description:
193:                     This function gets frequency of the selected Reference clock bus in Hertz.
194:                 
195:                   Precondition:
196:                     None.
197:                 
198:                   Parameters:
199:                 	peripheralBus - Reference clock bus selection. One of the possible value from
200:                 				CLK_BUSES_REFERENCE enum. For devices that do not have multiple
201:                 				clock channels for Reference clock, CLK_BUS_REFERENCE_1 should be
202:                 				the selection.
203:                 
204:                   Returns:
205:                     Clock frequency in Hz.
206:                 
207:                   Example:
208:                     <code>
209:                     unsigned long sysClockOutputHz;
210:                 
211:                     sysClockOutputHz = SYS_CLK_ReferenceFrequencyGet ( CLK_BUS_REFERENCE_3 );
212:                     </code>
213:                 
214:                   Remarks:
215:                     None.
216:                  */
217:                 
218:                 inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
219:                 {
00000000  00000000   NOP
220:                 	return 0;
00000010  00000000   NOP
221:                 
222:                 }
00000014  00000000   NOP
223:                 
224:                 /******************************************************************************
225:                   Function:
226:                     void SYS_CLK_SecondaryOscillatorEnable ( void )
227:                 
228:                   Summary:
229:                     Enables the secondary oscillator.
230:                 
231:                   Description:
232:                     This function enables the secondary oscillator.
233:                 
234:                   Remarks:
235:                     For more details refer sys_clk.h.
236:                 */
237:                 
238:                 void SYS_CLK_SecondaryOscillatorEnable ( void )
239:                 {
00000000  00000000   NOP
240:                     /* Check for secondary oscillator status */
241:                     if (!PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
00000010  00000000   NOP
242:                     {    
243:                         /* Unlock and enable secondary oscillator */
244:                         SYS_DEVCON_SystemUnlock();
0000002C  00000000   NOP
245:                         
246:                         PLIB_OSC_SecondaryEnable(OSC_ID_0);
00000034  00000000   NOP
247:                         
248:                         SYS_DEVCON_SystemLock();
00000040  00000000   NOP
249:                     }
250:                 }
00000048  00000000   NOP
251:                 
252:                 /******************************************************************************
253:                   Function:
254:                     void SYS_CLK_SecondaryOscillatorDisable ( void )
255:                 
256:                   Summary:
257:                     Disables the secondary oscillator.
258:                 
259:                   Description:
260:                     This function disables the secondary oscillator.
261:                 
262:                   Remarks:
263:                     For more details refer sys_clk.h.
264:                 */
265:                 
266:                 void SYS_CLK_SecondaryOscillatorDisable ( void )
267:                 {
00000000  00000000   NOP
268:                     /* Check for secondary oscillator status */
269:                     if (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
00000010  00000000   NOP
270:                     {    
271:                         /* Unlock and disable secondary oscillator*/
272:                         SYS_DEVCON_SystemUnlock();
00000024  00000000   NOP
273:                         
274:                         PLIB_OSC_SecondaryDisable(OSC_ID_0);
0000002C  00000000   NOP
275:                         
276:                         SYS_DEVCON_SystemLock();
00000038  00000000   NOP
277:                     }
278:                 }
00000040  00000000   NOP
279:                 
280:                 /******************************************************************************
281:                   Function:
282:                     bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
283:                 
284:                   Summary:
285:                     Identifies whether secondary oscillator is enabled or disabled.
286:                 
287:                   Description:
288:                     This function identifies whether the secondary oscillator is enabled or 
289:                     disabled.
290:                     
291:                   Remarks:
292:                     For more details refer sys_clk.h.
293:                 */
294:                 
295:                 bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
296:                 {
00000000  00000000   NOP
297:                     return (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0));
00000010  00000000   NOP
298:                 }
0000001C  00000000   NOP
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/driver/usart/src/drv_usart_static_byte_model.c
1:                   /*******************************************************************************
2:                     USART driver static implementation of Byte model.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart_static_byte_model.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver static implementation of Byte model.
12:                  
13:                    Description:
14:                      This file contains the source code for the static implementation of the
15:                      USART driver Byte model.
16:                  
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                  
21:                      Static single-open interfaces also eliminate the need for the open handle.
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  //DOM-IGNORE-END
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: Included Files
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  #include "system_config.h"
54:                  #include "system_definitions.h"
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Global Data
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  extern DRV_USART_OBJ  gDrvUSART0Obj ;
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: Instance 0 static driver functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  uint8_t DRV_USART0_ReadByte(void)
70:                  {
00000000  00000000   NOP
71:                      uint8_t readValue;
72:                  	
73:                      /* Receive one byte */
74:                      readValue = PLIB_USART_ReceiverByteReceive(USART_ID_2);
00000010  00000000   NOP
75:                  
76:                      return readValue;
00000024  00000000   NOP
77:                  }
00000028  00000000   NOP
78:                  
79:                  void DRV_USART0_WriteByte(const uint8_t byte)
80:                  {
00000000  00000000   NOP
81:                      /* Wait till TX buffer is available as blocking operation is selected */
82:                      while(PLIB_USART_TransmitterBufferIsFull(USART_ID_2));
00000018  00000000   NOP
83:                      /* Send one byte */
84:                      PLIB_USART_TransmitterByteSend(USART_ID_2, byte);
00000034  00000000   NOP
85:                      SYS_INT_SourceEnable(INT_SOURCE_USART_2_TRANSMIT);
0000004C  00000000   NOP
86:                  }
0000005C  00000000   NOP
87:                  
88:                  unsigned int DRV_USART0_ReceiverBufferSizeGet(void)
89:                  {
00000000  00000000   NOP
90:                      return 8;
0000000C  00000000   NOP
91:                  }
00000010  00000000   NOP
92:                  
93:                  unsigned int DRV_USART0_TransmitBufferSizeGet(void)
94:                  {
00000000  00000000   NOP
95:                      return 8;
0000000C  00000000   NOP
96:                  }
00000010  00000000   NOP
97:                  
98:                  bool DRV_USART0_ReceiverBufferIsEmpty( void )
99:                  {
00000000  00000000   NOP
100:                     /* Check the status of receiver buffer */
101:                     return(!PLIB_USART_ReceiverDataIsAvailable(USART_ID_2));
00000010  00000000   NOP
102:                 }
00000038  00000000   NOP
103:                 
104:                 bool DRV_USART0_TransmitBufferIsFull(void)
105:                 {
00000000  00000000   NOP
106:                     /* Check the status of transmitter buffer */
107:                     return(PLIB_USART_TransmitterBufferIsFull(USART_ID_2));
00000010  00000000   NOP
108:                 }
00000020  00000000   NOP
109:                 
110:                 extern DRV_USART_OBJ  gDrvUSART1Obj ;
111:                 
112:                 // *****************************************************************************
113:                 // *****************************************************************************
114:                 // Section: Instance 1 static driver functions
115:                 // *****************************************************************************
116:                 // *****************************************************************************
117:                 
118:                 uint8_t DRV_USART1_ReadByte(void)
119:                 {
00000000  00000000   NOP
120:                     uint8_t readValue;
121:                 	
122:                     /* Receive one byte */
123:                     readValue = PLIB_USART_ReceiverByteReceive(USART_ID_1);
00000010  00000000   NOP
124:                 
125:                     return readValue;
00000024  00000000   NOP
126:                 }
00000028  00000000   NOP
127:                 
128:                 void DRV_USART1_WriteByte(const uint8_t byte)
129:                 {
00000000  00000000   NOP
130:                     /* Wait till TX buffer is available as blocking operation is selected */
131:                     while(PLIB_USART_TransmitterBufferIsFull(USART_ID_1));
00000018  00000000   NOP
132:                     /* Send one byte */
133:                     PLIB_USART_TransmitterByteSend(USART_ID_1, byte);
00000034  00000000   NOP
134:                     SYS_INT_SourceEnable(INT_SOURCE_USART_1_TRANSMIT);
0000004C  00000000   NOP
135:                 }
0000005C  00000000   NOP
136:                 
137:                 unsigned int DRV_USART1_ReceiverBufferSizeGet(void)
138:                 {
00000000  00000000   NOP
139:                     return 8;
0000000C  00000000   NOP
140:                 }
00000010  00000000   NOP
141:                 
142:                 unsigned int DRV_USART1_TransmitBufferSizeGet(void)
143:                 {
00000000  00000000   NOP
144:                     return 8;
0000000C  00000000   NOP
145:                 }
00000010  00000000   NOP
146:                 
147:                 bool DRV_USART1_ReceiverBufferIsEmpty( void )
148:                 {
00000000  00000000   NOP
149:                     /* Check the status of receiver buffer */
150:                     return(!PLIB_USART_ReceiverDataIsAvailable(USART_ID_1));
00000010  00000000   NOP
151:                 }
00000038  00000000   NOP
152:                 
153:                 bool DRV_USART1_TransmitBufferIsFull(void)
154:                 {
00000000  00000000   NOP
155:                     /* Check the status of transmitter buffer */
156:                     return(PLIB_USART_TransmitterBufferIsFull(USART_ID_1));
00000010  00000000   NOP
157:                 }
00000020  00000000   NOP
158:                 
159:                 /*******************************************************************************
160:                  End of File
161:                 */
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/driver/usart/src/drv_usart_static.c
1:                   /*******************************************************************************
2:                     USART Driver Static implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart_static.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver static implementation.
12:                  
13:                    Description:
14:                      The USART device driver provides a simple interface to manage the USART
15:                      modules on Microchip microcontrollers. This file contains static implementation
16:                      for the USART driver.
17:                  
18:                    Remarks:
19:                      Static interfaces incorporate the driver instance number within the names
20:                      of the routines, eliminating the need for an object ID or object handle.
21:                  
22:                      Static single-open interfaces also eliminate the need for the open handle.
23:                  *******************************************************************************/
24:                  
25:                  //DOM-IGNORE-BEGIN
26:                  /*******************************************************************************
27:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
28:                  
29:                  Microchip licenses to you the right to use, modify, copy and distribute
30:                  Software only when embedded on a Microchip microcontroller or digital signal
31:                  controller that is integrated into your product or third party product
32:                  (pursuant to the sublicense terms in the accompanying license agreement).
33:                  
34:                  You should refer to the license agreement accompanying this Software for
35:                  additional information regarding your rights and obligations.
36:                  
37:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
38:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
39:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
40:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
41:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
42:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
43:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
44:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
46:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                  *******************************************************************************/
48:                  //DOM-IGNORE-END
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "system_config.h"
57:                  #include "system_definitions.h"
58:                  
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: Global Data
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  
66:                  /* This is the driver static object . */
67:                  DRV_USART_OBJ  gDrvUSART0Obj ;
68:                  
69:                  // *****************************************************************************
70:                  // *****************************************************************************
71:                  // Section: Instance 0 static driver functions
72:                  // *****************************************************************************
73:                  // *****************************************************************************
74:                  
75:                  SYS_MODULE_OBJ DRV_USART0_Initialize(void)
76:                  {
9D00AB94  27BDFFD8   ADDIU SP, SP, -40
9D00AB98  AFBF0024   SW RA, 36(SP)
9D00AB9C  AFBE0020   SW FP, 32(SP)
9D00ABA0  03A0F021   ADDU FP, SP, ZERO
77:                      uint32_t clockSource;
78:                  
79:                      /* Disable the USART module to configure it*/
80:                      PLIB_USART_Disable (USART_ID_2);
9D00ABA4  3C02BF80   LUI V0, -16512
9D00ABA8  34446200   ORI A0, V0, 25088
9D00ABAC  0F4038EC   JAL PLIB_USART_Disable
9D00ABB0  00000000   NOP
81:                  
82:                      /* Initialize the USART based on configuration settings */
83:                      PLIB_USART_InitializeModeGeneral(USART_ID_2,
9D00ABB4  AFA00010   SW ZERO, 16(SP)
9D00ABB8  AFA00014   SW ZERO, 20(SP)
9D00ABBC  3C02BF80   LUI V0, -16512
9D00ABC0  34446200   ORI A0, V0, 25088
9D00ABC4  00002821   ADDU A1, ZERO, ZERO
9D00ABC8  00003021   ADDU A2, ZERO, ZERO
9D00ABCC  00003821   ADDU A3, ZERO, ZERO
9D00ABD0  0F403637   JAL PLIB_USART_InitializeModeGeneral
9D00ABD4  00000000   NOP
84:                              false,  /*Auto baud*/
85:                              false,  /*LoopBack mode*/
86:                              false,  /*Auto wakeup on start*/
87:                              false,  /*IRDA mode*/
88:                              false);  /*Stop In Idle mode*/
89:                  
90:                      /* Set the line control mode */
91:                      PLIB_USART_LineControlModeSelect(USART_ID_2, DRV_USART_LINE_CONTROL_8NONE1);
9D00ABD8  3C02BF80   LUI V0, -16512
9D00ABDC  34446200   ORI A0, V0, 25088
9D00ABE0  00002821   ADDU A1, ZERO, ZERO
9D00ABE4  0F4036C0   JAL PLIB_USART_LineControlModeSelect
9D00ABE8  00000000   NOP
92:                  
93:                      /* We set the receive interrupt mode to receive an interrupt whenever FIFO
94:                         is not empty */
95:                      PLIB_USART_InitializeOperation(USART_ID_2,
9D00ABEC  3C02BF80   LUI V0, -16512
9D00ABF0  34446200   ORI A0, V0, 25088
9D00ABF4  00002821   ADDU A1, ZERO, ZERO
9D00ABF8  24060001   ADDIU A2, ZERO, 1
9D00ABFC  00003821   ADDU A3, ZERO, ZERO
9D00AC00  0F4036EE   JAL .LFE507, PLIB_USART_InitializeOperation
9D00AC04  00000000   NOP
96:                              USART_RECEIVE_FIFO_ONE_CHAR,
97:                              USART_TRANSMIT_FIFO_IDLE,
98:                              USART_ENABLE_TX_RX_USED);
99:                  
100:                     /* Get the USART clock source value*/
101:                     clockSource = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_1 );
9D00AC08  00002021   ADDU A0, ZERO, ZERO
9D00AC0C  0F403745   JAL SYS_CLK_PeripheralFrequencyGet
9D00AC10  00000000   NOP
9D00AC14  AFC20018   SW V0, 24(FP)
102:                 
103:                     /* Set the baud rate and enable the USART */
104:                     PLIB_USART_BaudSetAndEnable(USART_ID_2,
9D00AC18  3C02BF80   LUI V0, -16512
9D00AC1C  34446200   ORI A0, V0, 25088
9D00AC20  8FC50018   LW A1, 24(FP)
9D00AC24  3C020001   LUI V0, 1
9D00AC28  3446C200   ORI A2, V0, -15872
9D00AC2C  0F4033EA   JAL .LFE1152, PLIB_USART_BaudSetAndEnable
9D00AC30  00000000   NOP
105:                             clockSource,
106:                             115200);  /*Desired Baud rate value*/
107:                 
108:                     /* Clear the interrupts to be on the safer side*/
109:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_2_TRANSMIT);
9D00AC34  00002021   ADDU A0, ZERO, ZERO
9D00AC38  24050037   ADDIU A1, ZERO, 55
9D00AC3C  0F403790   JAL PLIB_INT_SourceFlagClear
9D00AC40  00000000   NOP
110:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_2_RECEIVE);
9D00AC44  00002021   ADDU A0, ZERO, ZERO
9D00AC48  24050036   ADDIU A1, ZERO, 54
9D00AC4C  0F403790   JAL PLIB_INT_SourceFlagClear
9D00AC50  00000000   NOP
111:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_2_ERROR);
9D00AC54  00002021   ADDU A0, ZERO, ZERO
9D00AC58  24050035   ADDIU A1, ZERO, 53
9D00AC5C  0F403790   JAL PLIB_INT_SourceFlagClear
9D00AC60  00000000   NOP
112:                 
113:                     /* Enable the error interrupt source */
114:                     SYS_INT_SourceEnable(INT_SOURCE_USART_2_ERROR);
9D00AC64  00002021   ADDU A0, ZERO, ZERO
9D00AC68  24050035   ADDIU A1, ZERO, 53
9D00AC6C  0F40379A   JAL PLIB_INT_SourceEnable
9D00AC70  00000000   NOP
115:                 
116:                     /* Enable the Receive interrupt source */
117:                     SYS_INT_SourceEnable(INT_SOURCE_USART_2_RECEIVE);
9D00AC74  00002021   ADDU A0, ZERO, ZERO
9D00AC78  24050036   ADDIU A1, ZERO, 54
9D00AC7C  0F40379A   JAL PLIB_INT_SourceEnable
9D00AC80  00000000   NOP
118:                 
119:                     /* Return the driver instance value*/
120:                     return (SYS_MODULE_OBJ)DRV_USART_INDEX_0;
9D00AC84  00001021   ADDU V0, ZERO, ZERO
121:                 }
9D00AC88  03C0E821   ADDU SP, FP, ZERO
9D00AC8C  8FBF0024   LW RA, 36(SP)
9D00AC90  8FBE0020   LW FP, 32(SP)
9D00AC94  27BD0028   ADDIU SP, SP, 40
9D00AC98  03E00008   JR RA
9D00AC9C  00000000   NOP
122:                 
123:                 void  DRV_USART0_Deinitialize(void)
124:                 {
00000000  00000000   NOP
125:                     bool status;
126:                 
127:                     /* Disable the interrupts */
128:                     status = SYS_INT_SourceDisable(INT_SOURCE_USART_2_TRANSMIT) ;
00000010  00000000   NOP
129:                     status = SYS_INT_SourceDisable(INT_SOURCE_USART_2_RECEIVE) ;
00000020  00000000   NOP
130:                     status = SYS_INT_SourceDisable(INT_SOURCE_USART_2_ERROR);
00000030  00000000   NOP
131:                     /* Ignore the warning */
132:                     (void)status;
133:                 
134:                     /* Disable USART module */
135:                     PLIB_USART_Disable (USART_ID_2);
00000040  00000000   NOP
136:                 
137:                 }
00000050  00000000   NOP
138:                 
139:                 
140:                 SYS_STATUS DRV_USART0_Status(void)
141:                 {
00000000  00000000   NOP
142:                     /* Return the status as ready always */
143:                     return SYS_STATUS_READY;
0000000C  00000000   NOP
144:                 }
00000010  00000000   NOP
145:                 
146:                 
147:                 void DRV_USART0_TasksTransmit(void)
148:                 {
00000000  00000000   NOP
149:                     /* This is the USART Driver Transmit tasks routine.
150:                        In this function, the driver checks if a transmit
151:                        interrupt is active and performs respective action*/
152:                 
153:                     /* Reading the transmit interrupt flag */
154:                     if(SYS_INT_SourceStatusGet(INT_SOURCE_USART_2_TRANSMIT))
00000010  00000000   NOP
155:                     {
156:                         /* Disable the interrupt, to avoid calling ISR continuously*/
157:                         SYS_INT_SourceDisable(INT_SOURCE_USART_2_TRANSMIT);
00000028  00000000   NOP
158:                 
159:                         /* Clear up the interrupt flag */
160:                         SYS_INT_SourceStatusClear(INT_SOURCE_USART_2_TRANSMIT);
00000034  00000000   NOP
161:                     }
162:                 }
00000044  00000000   NOP
163:                 
164:                 void DRV_USART0_TasksReceive(void)
165:                 {
00000000  00000000   NOP
166:                     /* This is the USART Driver Receive tasks routine. If the receive
167:                        interrupt flag is set, the tasks routines are executed.
168:                      */
169:                 
170:                     /* Reading the receive interrupt flag */
171:                     if(SYS_INT_SourceStatusGet(INT_SOURCE_USART_2_RECEIVE))
00000010  00000000   NOP
172:                     {
173:                 
174:                         /* Clear up the interrupt flag */
175:                         SYS_INT_SourceStatusClear(INT_SOURCE_USART_2_RECEIVE);
00000028  00000000   NOP
176:                     }
177:                 }
00000038  00000000   NOP
178:                 
179:                 
180:                 void DRV_USART0_TasksError(void)
181:                 {
00000000  00000000   NOP
182:                     /* This is the USART Driver Error tasks routine. In this function, the
183:                      * driver checks if an error interrupt has occurred. If so the error
184:                      * condition is cleared.  */
185:                 
186:                     /* Reading the error interrupt flag */
187:                     if(SYS_INT_SourceStatusGet(INT_SOURCE_USART_2_ERROR))
00000010  00000000   NOP
188:                     {
189:                         /* This means an error has occurred */
190:                         /* Clear up the error interrupt flag */
191:                         SYS_INT_SourceStatusClear(INT_SOURCE_USART_2_ERROR);
00000028  00000000   NOP
192:                     }
193:                 }
00000038  00000000   NOP
194:                 
195:                 DRV_HANDLE DRV_USART0_Open(const SYS_MODULE_INDEX index, const DRV_IO_INTENT ioIntent)
196:                 {
00000000  00000000   NOP
197:                 
198:                     /* Return the driver instance value*/
199:                     return ((DRV_HANDLE)DRV_USART_INDEX_0 );
00000018  00000000   NOP
200:                 }
0000001C  00000000   NOP
201:                 
202:                 void DRV_USART0_Close(void)
203:                 {
00000000  00000000   NOP
204:                     return;
0000000C  00000000   NOP
205:                 }
00000010  00000000   NOP
206:                 
207:                 DRV_USART_CLIENT_STATUS DRV_USART0_ClientStatus(void)
208:                 {
00000000  00000000   NOP
209:                     /* Return the status as ready always*/
210:                     return DRV_USART_CLIENT_STATUS_READY;
0000000C  00000000   NOP
211:                 }
00000010  00000000   NOP
212:                 
213:                 DRV_USART_TRANSFER_STATUS DRV_USART0_TransferStatus( void )
214:                 {
00000000  00000000   NOP
215:                     DRV_USART_TRANSFER_STATUS result = 0;
00000010  00000000   NOP
216:                 
217:                     /* Check if RX data available */
218:                     if(PLIB_USART_ReceiverDataIsAvailable(USART_ID_2))
00000014  00000000   NOP
219:                     {
220:                         result|= DRV_USART_TRANSFER_STATUS_RECEIVER_DATA_PRESENT;
0000002C  00000000   NOP
221:                     }
222:                     else
223:                     {
224:                         result|= DRV_USART_TRANSFER_STATUS_RECEIVER_EMPTY;
00000040  00000000   NOP
225:                     }
226:                 
227:                     /* Check if TX Buffer is empty */
228:                     if(PLIB_USART_TransmitterIsEmpty(USART_ID_2))
0000004C  00000000   NOP
229:                     {
230:                         result|= DRV_USART_TRANSFER_STATUS_TRANSMIT_EMPTY;
00000064  00000000   NOP
231:                     }
232:                 
233:                     /* Check if the TX buffer is full */
234:                     if(PLIB_USART_TransmitterBufferIsFull(USART_ID_2))
00000070  00000000   NOP
235:                     {
236:                         result|= DRV_USART_TRANSFER_STATUS_TRANSMIT_FULL;
00000088  00000000   NOP
237:                     }
238:                 
239:                     return(result);
00000094  00000000   NOP
240:                 }
00000098  00000000   NOP
241:                 
242:                 DRV_USART_ERROR DRV_USART0_ErrorGet(void)
243:                 {
00000000  00000000   NOP
244:                     DRV_USART_ERROR error;
245:                     error = gDrvUSART0Obj.error;
0000000C  00000000   NOP
246:                 
247:                     /* Clear the error before returning */
248:                     gDrvUSART0Obj.error = DRV_USART_ERROR_NONE;
00000014  00000000   NOP
249:                 
250:                     /* Return the error*/
251:                     return(error);
00000018  00000000   NOP
252:                 }
0000001C  00000000   NOP
253:                 
254:                 
255:                 void _DRV_USART0_ErrorConditionClear()
256:                 {
00000000  00000000   NOP
257:                     uint8_t dummyData = 0u;
00000010  00000000   NOP
258:                     /* RX length = (FIFO level + RX register) */
259:                     uint8_t RXlength = _DRV_USART_RX_DEPTH;
00000014  00000000   NOP
260:                 
261:                     /* If it's a overrun error then clear it to flush FIFO */
262:                     if(USART_ERROR_RECEIVER_OVERRUN & PLIB_USART_ErrorsGet(USART_ID_2))
0000001C  00000000   NOP
263:                     {
264:                         PLIB_USART_ReceiverOverrunErrorClear(USART_ID_2);
00000038  00000000   NOP
265:                     }
266:                 
267:                     /* Read existing error bytes from FIFO to clear parity and framing error flags*/
268:                     while( (USART_ERROR_PARITY | USART_ERROR_FRAMING) & PLIB_USART_ErrorsGet(USART_ID_2) )
00000048  00000000   NOP
0000008C  00000000   NOP
269:                     {
270:                         dummyData = PLIB_USART_ReceiverByteReceive(USART_ID_2);
00000058  00000000   NOP
271:                         RXlength--;
0000006C  00000000   NOP
272:                 
273:                         /* Try to flush error bytes for one full FIFO and exit instead of
274:                          * blocking here if more error bytes are received*/
275:                         if(0u == RXlength)
00000078  00000000   NOP
276:                         {
277:                             break;
00000084  00000000   NOP
278:                         }
279:                     }
280:                 
281:                     /* Ignore the warning */
282:                     (void)dummyData;
283:                 
284:                     /* Clear error interrupt flag */
285:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_2_ERROR);
000000A8  00000000   NOP
286:                 
287:                     /* Clear up the receive interrupt flag so that RX interrupt is not
288:                      * triggered for error bytes*/
289:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_2_RECEIVE);
000000B8  00000000   NOP
290:                 }
000000C8  00000000   NOP
291:                 
292:                 
293:                 
294:                 DRV_USART_BAUD_SET_RESULT DRV_USART0_BaudSet(uint32_t baud)
295:                 {
00000000  00000000   NOP
296:                     uint32_t clockSource;
297:                     int32_t brgValueLow=0;
00000014  00000000   NOP
298:                     int32_t brgValueHigh=0;
00000018  00000000   NOP
299:                     DRV_USART_BAUD_SET_RESULT retVal = DRV_USART_BAUD_SET_SUCCESS;
0000001C  00000000   NOP
300:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
301:                     bool isEnabled = false;
302:                 #endif
303:                 
304:                     /* Get the USART clock source value*/
305:                     clockSource = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_1 );
00000020  00000000   NOP
306:                 
307:                     /* Calculate low and high baud values */
308:                     brgValueLow  = ( (clockSource/baud) >> 4 ) - 1;
00000030  00000000   NOP
309:                     brgValueHigh = ( (clockSource/baud) >> 2 ) - 1;
00000054  00000000   NOP
310:                 
311:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
312:                         isEnabled = PLIB_USART_ModuleIsBusy (USART_ID_2);
313:                         if (isEnabled)
314:                         {
315:                             PLIB_USART_Disable (USART_ID_2);
316:                             while (PLIB_USART_ModuleIsBusy (USART_ID_2));
317:                         }
318:                 #endif
319:                 
320:                     /* Check if the baud value can be set with high baud settings */
321:                     if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX))
00000078  00000000   NOP
322:                     {
323:                         PLIB_USART_BaudRateHighEnable(USART_ID_2);
00000098  00000000   NOP
324:                         PLIB_USART_BaudRateHighSet(USART_ID_2,clockSource,baud);
000000A8  00000000   NOP
325:                     }
326:                 
327:                     /* Check if the baud value can be set with low baud settings */
328:                     else if ((brgValueLow >= 0) && (brgValueLow <= UINT16_MAX))
000000C8  00000000   NOP
329:                     {
330:                         PLIB_USART_BaudRateHighDisable(USART_ID_2);
000000E8  00000000   NOP
331:                         PLIB_USART_BaudRateSet(USART_ID_2, clockSource, baud);
000000F8  00000000   NOP
332:                     }
333:                     else
334:                     {
335:                             retVal = DRV_USART_BAUD_SET_ERROR;
00000118  00000000   NOP
336:                     }
337:                 
338:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
339:                     if (isEnabled)
340:                     {
341:                         PLIB_USART_Enable (USART_ID_2);
342:                     }
343:                 #endif
344:                 
345:                     return retVal;
00000120  00000000   NOP
346:                 }
00000124  00000000   NOP
347:                 
348:                 
349:                 DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART0_LineControlSet(DRV_USART_LINE_CONTROL lineControlMode)
350:                 {
00000000  00000000   NOP
351:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
352:                     bool isEnabled = false;
353:                 #endif
354:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
355:                         isEnabled = PLIB_USART_ModuleIsBusy (USART_ID_2);
356:                         if (isEnabled)
357:                         {
358:                             PLIB_USART_Disable (USART_ID_2);
359:                             while (PLIB_USART_ModuleIsBusy (USART_ID_2));
360:                         }
361:                 #endif
362:                 
363:                     /* Set the Line Control Mode */
364:                     PLIB_USART_LineControlModeSelect(USART_ID_2, lineControlMode);
00000014  00000000   NOP
365:                 
366:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
367:                         if (isEnabled)
368:                         {
369:                             PLIB_USART_Enable (USART_ID_2);
370:                         }
371:                 #endif
372:                 
373:                     /* Return success */
374:                     return(DRV_USART_LINE_CONTROL_SET_SUCCESS);
00000028  00000000   NOP
375:                 }
0000002C  00000000   NOP
376:                 
377:                 
378:                 // *****************************************************************************
379:                 // *****************************************************************************
380:                 // Section: Global Data
381:                 // *****************************************************************************
382:                 // *****************************************************************************
383:                 
384:                 /* This is the driver static object . */
385:                 DRV_USART_OBJ  gDrvUSART1Obj ;
386:                 
387:                 // *****************************************************************************
388:                 // *****************************************************************************
389:                 // Section: Instance 1 static driver functions
390:                 // *****************************************************************************
391:                 // *****************************************************************************
392:                 
393:                 SYS_MODULE_OBJ DRV_USART1_Initialize(void)
394:                 {
9D00ACA0  27BDFFD8   ADDIU SP, SP, -40
9D00ACA4  AFBF0024   SW RA, 36(SP)
9D00ACA8  AFBE0020   SW FP, 32(SP)
9D00ACAC  03A0F021   ADDU FP, SP, ZERO
395:                     uint32_t clockSource;
396:                 
397:                     /* Disable the USART module to configure it*/
398:                     PLIB_USART_Disable (USART_ID_1);
9D00ACB0  3C02BF80   LUI V0, -16512
9D00ACB4  34446000   ORI A0, V0, 24576
9D00ACB8  0F4038EC   JAL PLIB_USART_Disable
9D00ACBC  00000000   NOP
399:                 
400:                     /* Initialize the USART based on configuration settings */
401:                     PLIB_USART_InitializeModeGeneral(USART_ID_1,
9D00ACC0  AFA00010   SW ZERO, 16(SP)
9D00ACC4  AFA00014   SW ZERO, 20(SP)
9D00ACC8  3C02BF80   LUI V0, -16512
9D00ACCC  34446000   ORI A0, V0, 24576
9D00ACD0  00002821   ADDU A1, ZERO, ZERO
9D00ACD4  00003021   ADDU A2, ZERO, ZERO
9D00ACD8  00003821   ADDU A3, ZERO, ZERO
9D00ACDC  0F403637   JAL PLIB_USART_InitializeModeGeneral
9D00ACE0  00000000   NOP
402:                             false,  /*Auto baud*/
403:                             false,  /*LoopBack mode*/
404:                             false,  /*Auto wakeup on start*/
405:                             false,  /*IRDA mode*/
406:                             false);  /*Stop In Idle mode*/
407:                 
408:                     /* Set the line control mode */
409:                     PLIB_USART_LineControlModeSelect(USART_ID_1, DRV_USART_LINE_CONTROL_8NONE1);
9D00ACE4  3C02BF80   LUI V0, -16512
9D00ACE8  34446000   ORI A0, V0, 24576
9D00ACEC  00002821   ADDU A1, ZERO, ZERO
9D00ACF0  0F4036C0   JAL PLIB_USART_LineControlModeSelect
9D00ACF4  00000000   NOP
410:                 
411:                     /* We set the receive interrupt mode to receive an interrupt whenever FIFO
412:                        is not empty */
413:                     PLIB_USART_InitializeOperation(USART_ID_1,
9D00ACF8  3C02BF80   LUI V0, -16512
9D00ACFC  34446000   ORI A0, V0, 24576
9D00AD00  00002821   ADDU A1, ZERO, ZERO
9D00AD04  24060001   ADDIU A2, ZERO, 1
9D00AD08  00003821   ADDU A3, ZERO, ZERO
9D00AD0C  0F4036EE   JAL .LFE507, PLIB_USART_InitializeOperation
9D00AD10  00000000   NOP
414:                             USART_RECEIVE_FIFO_ONE_CHAR,
415:                             USART_TRANSMIT_FIFO_IDLE,
416:                             USART_ENABLE_TX_RX_USED);
417:                 
418:                     /* Get the USART clock source value*/
419:                     clockSource = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_1 );
9D00AD14  00002021   ADDU A0, ZERO, ZERO
9D00AD18  0F403745   JAL SYS_CLK_PeripheralFrequencyGet
9D00AD1C  00000000   NOP
9D00AD20  AFC20018   SW V0, 24(FP)
420:                 
421:                     /* Set the baud rate and enable the USART */
422:                     PLIB_USART_BaudSetAndEnable(USART_ID_1,
9D00AD24  3C02BF80   LUI V0, -16512
9D00AD28  34446000   ORI A0, V0, 24576
9D00AD2C  8FC50018   LW A1, 24(FP)
9D00AD30  3C020001   LUI V0, 1
9D00AD34  3446C200   ORI A2, V0, -15872
9D00AD38  0F4033EA   JAL .LFE1152, PLIB_USART_BaudSetAndEnable
9D00AD3C  00000000   NOP
423:                             clockSource,
424:                             115200);  /*Desired Baud rate value*/
425:                 
426:                     /* Clear the interrupts to be on the safer side*/
427:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_1_TRANSMIT);
9D00AD40  00002021   ADDU A0, ZERO, ZERO
9D00AD44  24050029   ADDIU A1, ZERO, 41
9D00AD48  0F403790   JAL PLIB_INT_SourceFlagClear
9D00AD4C  00000000   NOP
428:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_1_RECEIVE);
9D00AD50  00002021   ADDU A0, ZERO, ZERO
9D00AD54  24050028   ADDIU A1, ZERO, 40
9D00AD58  0F403790   JAL PLIB_INT_SourceFlagClear
9D00AD5C  00000000   NOP
429:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_1_ERROR);
9D00AD60  00002021   ADDU A0, ZERO, ZERO
9D00AD64  24050027   ADDIU A1, ZERO, 39
9D00AD68  0F403790   JAL PLIB_INT_SourceFlagClear
9D00AD6C  00000000   NOP
430:                 
431:                     /* Enable the error interrupt source */
432:                     SYS_INT_SourceEnable(INT_SOURCE_USART_1_ERROR);
9D00AD70  00002021   ADDU A0, ZERO, ZERO
9D00AD74  24050027   ADDIU A1, ZERO, 39
9D00AD78  0F40379A   JAL PLIB_INT_SourceEnable
9D00AD7C  00000000   NOP
433:                 
434:                     /* Enable the Receive interrupt source */
435:                     SYS_INT_SourceEnable(INT_SOURCE_USART_1_RECEIVE);
9D00AD80  00002021   ADDU A0, ZERO, ZERO
9D00AD84  24050028   ADDIU A1, ZERO, 40
9D00AD88  0F40379A   JAL PLIB_INT_SourceEnable
9D00AD8C  00000000   NOP
436:                 
437:                     /* Return the driver instance value*/
438:                     return (SYS_MODULE_OBJ)DRV_USART_INDEX_1;
9D00AD90  24020001   ADDIU V0, ZERO, 1
439:                 }
9D00AD94  03C0E821   ADDU SP, FP, ZERO
9D00AD98  8FBF0024   LW RA, 36(SP)
9D00AD9C  8FBE0020   LW FP, 32(SP)
9D00ADA0  27BD0028   ADDIU SP, SP, 40
9D00ADA4  03E00008   JR RA
9D00ADA8  00000000   NOP
440:                 
441:                 void  DRV_USART1_Deinitialize(void)
442:                 {
00000000  00000000   NOP
443:                     bool status;
444:                 
445:                     /* Disable the interrupts */
446:                     status = SYS_INT_SourceDisable(INT_SOURCE_USART_1_TRANSMIT) ;
00000010  00000000   NOP
447:                     status = SYS_INT_SourceDisable(INT_SOURCE_USART_1_RECEIVE) ;
00000020  00000000   NOP
448:                     status = SYS_INT_SourceDisable(INT_SOURCE_USART_1_ERROR);
00000030  00000000   NOP
449:                     /* Ignore the warning */
450:                     (void)status;
451:                 
452:                     /* Disable USART module */
453:                     PLIB_USART_Disable (USART_ID_1);
00000040  00000000   NOP
454:                 
455:                 }
00000050  00000000   NOP
456:                 
457:                 
458:                 SYS_STATUS DRV_USART1_Status(void)
459:                 {
00000000  00000000   NOP
460:                     /* Return the status as ready always */
461:                     return SYS_STATUS_READY;
0000000C  00000000   NOP
462:                 }
00000010  00000000   NOP
463:                 
464:                 
465:                 void DRV_USART1_TasksTransmit(void)
466:                 {
00000000  00000000   NOP
467:                     /* This is the USART Driver Transmit tasks routine.
468:                        In this function, the driver checks if a transmit
469:                        interrupt is active and performs respective action*/
470:                 
471:                     /* Reading the transmit interrupt flag */
472:                     if(SYS_INT_SourceStatusGet(INT_SOURCE_USART_1_TRANSMIT))
00000010  00000000   NOP
473:                     {
474:                         /* Disable the interrupt, to avoid calling ISR continuously*/
475:                         SYS_INT_SourceDisable(INT_SOURCE_USART_1_TRANSMIT);
00000028  00000000   NOP
476:                 
477:                         /* Clear up the interrupt flag */
478:                         SYS_INT_SourceStatusClear(INT_SOURCE_USART_1_TRANSMIT);
00000034  00000000   NOP
479:                     }
480:                 }
00000044  00000000   NOP
481:                 
482:                 void DRV_USART1_TasksReceive(void)
483:                 {
00000000  00000000   NOP
484:                     /* This is the USART Driver Receive tasks routine. If the receive
485:                        interrupt flag is set, the tasks routines are executed.
486:                      */
487:                 
488:                     /* Reading the receive interrupt flag */
489:                     if(SYS_INT_SourceStatusGet(INT_SOURCE_USART_1_RECEIVE))
00000010  00000000   NOP
490:                     {
491:                 
492:                         /* Clear up the interrupt flag */
493:                         SYS_INT_SourceStatusClear(INT_SOURCE_USART_1_RECEIVE);
00000028  00000000   NOP
494:                     }
495:                 }
00000038  00000000   NOP
496:                 
497:                 
498:                 void DRV_USART1_TasksError(void)
499:                 {
00000000  00000000   NOP
500:                     /* This is the USART Driver Error tasks routine. In this function, the
501:                      * driver checks if an error interrupt has occurred. If so the error
502:                      * condition is cleared.  */
503:                 
504:                     /* Reading the error interrupt flag */
505:                     if(SYS_INT_SourceStatusGet(INT_SOURCE_USART_1_ERROR))
00000010  00000000   NOP
506:                     {
507:                         /* This means an error has occurred */
508:                         /* Clear up the error interrupt flag */
509:                         SYS_INT_SourceStatusClear(INT_SOURCE_USART_1_ERROR);
00000028  00000000   NOP
510:                     }
511:                 }
00000038  00000000   NOP
512:                 
513:                 DRV_HANDLE DRV_USART1_Open(const SYS_MODULE_INDEX index, const DRV_IO_INTENT ioIntent)
514:                 {
00000000  00000000   NOP
515:                 
516:                     /* Return the driver instance value*/
517:                     return ((DRV_HANDLE)DRV_USART_INDEX_1 );
00000018  00000000   NOP
518:                 }
0000001C  00000000   NOP
519:                 
520:                 void DRV_USART1_Close(void)
521:                 {
00000000  00000000   NOP
522:                     return;
0000000C  00000000   NOP
523:                 }
00000010  00000000   NOP
524:                 
525:                 DRV_USART_CLIENT_STATUS DRV_USART1_ClientStatus(void)
526:                 {
00000000  00000000   NOP
527:                     /* Return the status as ready always*/
528:                     return DRV_USART_CLIENT_STATUS_READY;
0000000C  00000000   NOP
529:                 }
00000010  00000000   NOP
530:                 
531:                 DRV_USART_TRANSFER_STATUS DRV_USART1_TransferStatus( void )
532:                 {
00000000  00000000   NOP
533:                     DRV_USART_TRANSFER_STATUS result = 0;
00000010  00000000   NOP
534:                 
535:                     /* Check if RX data available */
536:                     if(PLIB_USART_ReceiverDataIsAvailable(USART_ID_1))
00000014  00000000   NOP
537:                     {
538:                         result|= DRV_USART_TRANSFER_STATUS_RECEIVER_DATA_PRESENT;
0000002C  00000000   NOP
539:                     }
540:                     else
541:                     {
542:                         result|= DRV_USART_TRANSFER_STATUS_RECEIVER_EMPTY;
00000040  00000000   NOP
543:                     }
544:                 
545:                     /* Check if TX Buffer is empty */
546:                     if(PLIB_USART_TransmitterIsEmpty(USART_ID_1))
0000004C  00000000   NOP
547:                     {
548:                         result|= DRV_USART_TRANSFER_STATUS_TRANSMIT_EMPTY;
00000064  00000000   NOP
549:                     }
550:                 
551:                     /* Check if the TX buffer is full */
552:                     if(PLIB_USART_TransmitterBufferIsFull(USART_ID_1))
00000070  00000000   NOP
553:                     {
554:                         result|= DRV_USART_TRANSFER_STATUS_TRANSMIT_FULL;
00000088  00000000   NOP
555:                     }
556:                 
557:                     return(result);
00000094  00000000   NOP
558:                 }
00000098  00000000   NOP
559:                 
560:                 DRV_USART_ERROR DRV_USART1_ErrorGet(void)
561:                 {
00000000  00000000   NOP
562:                     DRV_USART_ERROR error;
563:                     error = gDrvUSART1Obj.error;
0000000C  00000000   NOP
564:                 
565:                     /* Clear the error before returning */
566:                     gDrvUSART1Obj.error = DRV_USART_ERROR_NONE;
00000014  00000000   NOP
567:                 
568:                     /* Return the error*/
569:                     return(error);
00000018  00000000   NOP
570:                 }
0000001C  00000000   NOP
571:                 
572:                 
573:                 void _DRV_USART1_ErrorConditionClear()
574:                 {
00000000  00000000   NOP
575:                     uint8_t dummyData = 0u;
00000010  00000000   NOP
576:                     /* RX length = (FIFO level + RX register) */
577:                     uint8_t RXlength = _DRV_USART_RX_DEPTH;
00000014  00000000   NOP
578:                 
579:                     /* If it's a overrun error then clear it to flush FIFO */
580:                     if(USART_ERROR_RECEIVER_OVERRUN & PLIB_USART_ErrorsGet(USART_ID_1))
0000001C  00000000   NOP
581:                     {
582:                         PLIB_USART_ReceiverOverrunErrorClear(USART_ID_1);
00000038  00000000   NOP
583:                     }
584:                 
585:                     /* Read existing error bytes from FIFO to clear parity and framing error flags*/
586:                     while( (USART_ERROR_PARITY | USART_ERROR_FRAMING) & PLIB_USART_ErrorsGet(USART_ID_1) )
00000048  00000000   NOP
0000008C  00000000   NOP
587:                     {
588:                         dummyData = PLIB_USART_ReceiverByteReceive(USART_ID_1);
00000058  00000000   NOP
589:                         RXlength--;
0000006C  00000000   NOP
590:                 
591:                         /* Try to flush error bytes for one full FIFO and exit instead of
592:                          * blocking here if more error bytes are received*/
593:                         if(0u == RXlength)
00000078  00000000   NOP
594:                         {
595:                             break;
00000084  00000000   NOP
596:                         }
597:                     }
598:                 
599:                     /* Ignore the warning */
600:                     (void)dummyData;
601:                 
602:                     /* Clear error interrupt flag */
603:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_1_ERROR);
000000A8  00000000   NOP
604:                 
605:                     /* Clear up the receive interrupt flag so that RX interrupt is not
606:                      * triggered for error bytes*/
607:                     SYS_INT_SourceStatusClear(INT_SOURCE_USART_1_RECEIVE);
000000B8  00000000   NOP
608:                 }
000000C8  00000000   NOP
609:                 
610:                 
611:                 
612:                 DRV_USART_BAUD_SET_RESULT DRV_USART1_BaudSet(uint32_t baud)
613:                 {
00000000  00000000   NOP
614:                     uint32_t clockSource;
615:                     int32_t brgValueLow=0;
00000014  00000000   NOP
616:                     int32_t brgValueHigh=0;
00000018  00000000   NOP
617:                     DRV_USART_BAUD_SET_RESULT retVal = DRV_USART_BAUD_SET_SUCCESS;
0000001C  00000000   NOP
618:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
619:                     bool isEnabled = false;
620:                 #endif
621:                 
622:                     /* Get the USART clock source value*/
623:                     clockSource = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_1 );
00000020  00000000   NOP
624:                 
625:                     /* Calculate low and high baud values */
626:                     brgValueLow  = ( (clockSource/baud) >> 4 ) - 1;
00000030  00000000   NOP
627:                     brgValueHigh = ( (clockSource/baud) >> 2 ) - 1;
00000054  00000000   NOP
628:                 
629:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
630:                         isEnabled = PLIB_USART_ModuleIsBusy (USART_ID_1);
631:                         if (isEnabled)
632:                         {
633:                             PLIB_USART_Disable (USART_ID_1);
634:                             while (PLIB_USART_ModuleIsBusy (USART_ID_1));
635:                         }
636:                 #endif
637:                 
638:                     /* Check if the baud value can be set with high baud settings */
639:                     if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX))
00000078  00000000   NOP
640:                     {
641:                         PLIB_USART_BaudRateHighEnable(USART_ID_1);
00000098  00000000   NOP
642:                         PLIB_USART_BaudRateHighSet(USART_ID_1,clockSource,baud);
000000A8  00000000   NOP
643:                     }
644:                 
645:                     /* Check if the baud value can be set with low baud settings */
646:                     else if ((brgValueLow >= 0) && (brgValueLow <= UINT16_MAX))
000000C8  00000000   NOP
647:                     {
648:                         PLIB_USART_BaudRateHighDisable(USART_ID_1);
000000E8  00000000   NOP
649:                         PLIB_USART_BaudRateSet(USART_ID_1, clockSource, baud);
000000F8  00000000   NOP
650:                     }
651:                     else
652:                     {
653:                             retVal = DRV_USART_BAUD_SET_ERROR;
00000118  00000000   NOP
654:                     }
655:                 
656:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
657:                     if (isEnabled)
658:                     {
659:                         PLIB_USART_Enable (USART_ID_1);
660:                     }
661:                 #endif
662:                 
663:                     return retVal;
00000120  00000000   NOP
664:                 }
00000124  00000000   NOP
665:                 
666:                 
667:                 DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART1_LineControlSet(DRV_USART_LINE_CONTROL lineControlMode)
668:                 {
00000000  00000000   NOP
669:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
670:                     bool isEnabled = false;
671:                 #endif
672:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
673:                         isEnabled = PLIB_USART_ModuleIsBusy (USART_ID_1);
674:                         if (isEnabled)
675:                         {
676:                             PLIB_USART_Disable (USART_ID_1);
677:                             while (PLIB_USART_ModuleIsBusy (USART_ID_1));
678:                         }
679:                 #endif
680:                 
681:                     /* Set the Line Control Mode */
682:                     PLIB_USART_LineControlModeSelect(USART_ID_1, lineControlMode);
00000014  00000000   NOP
683:                 
684:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
685:                         if (isEnabled)
686:                         {
687:                             PLIB_USART_Enable (USART_ID_1);
688:                         }
689:                 #endif
690:                 
691:                     /* Return success */
692:                     return(DRV_USART_LINE_CONTROL_SET_SUCCESS);
00000028  00000000   NOP
693:                 }
0000002C  00000000   NOP
694:                 
695:                 /*******************************************************************************
696:                  End of File
697:                 */
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/driver/usart/src/drv_usart_mapping.c
1:                   /*******************************************************************************
2:                     USART Driver Dynamic to Static mapping
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart_mapping.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver dynamic APIs to static API mapping.
12:                  
13:                    Description:
14:                      This file contains code that maps dynamic APIs to static whenever
15:                      the static mode of the driver is selected..
16:                  
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                  
21:                      Static single-open interfaces also eliminate the need for the open handle.
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  //DOM-IGNORE-END
48:                  
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  // Section: Included Files
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  SYS_MODULE_OBJ DRV_USART_Initialize(const SYS_MODULE_INDEX index,const SYS_MODULE_INIT * const init)
59:                  {
9D00CC84  27BDFFE0   ADDIU SP, SP, -32
9D00CC88  AFBF001C   SW RA, 28(SP)
9D00CC8C  AFBE0018   SW FP, 24(SP)
9D00CC90  03A0F021   ADDU FP, SP, ZERO
9D00CC94  00801021   ADDU V0, A0, ZERO
9D00CC98  AFC50024   SW A1, 36(FP)
9D00CC9C  A7C20020   SH V0, 32(FP)
60:                      SYS_MODULE_OBJ returnValue;
61:                  
62:                      switch(index)
9D00CCA0  97C20020   LHU V0, 32(FP)
9D00CCA4  10400006   BEQ V0, ZERO, 0x9D00CCC0
9D00CCA8  00000000   NOP
9D00CCAC  24030001   ADDIU V1, ZERO, 1
9D00CCB0  10430008   BEQ V0, V1, .LVL3
9D00CCB4  00000000   NOP
9D00CCB8  0B40333A   J .LVL6
9D00CCBC  00000000   NOP
63:                      {
64:                          case DRV_USART_INDEX_0:
65:                          {
66:                              returnValue = DRV_USART0_Initialize();
9D00CCC0  0F402AE5   JAL DRV_USART0_Initialize
9D00CCC4  00000000   NOP
9D00CCC8  AFC20010   SW V0, 16(FP)
67:                              break;
9D00CCCC  0B40333D   J .LVL8
9D00CCD0  00000000   NOP
68:                          }
69:                          case DRV_USART_INDEX_1:
70:                          {
71:                              returnValue = DRV_USART1_Initialize();
9D00CCD4  0F402B28   JAL DRV_USART1_Initialize
9D00CCD8  00000000   NOP
9D00CCDC  AFC20010   SW V0, 16(FP)
72:                              break;
9D00CCE0  0B40333D   J .LVL8
9D00CCE4  00000000   NOP
73:                          }
74:                          default:
75:                          {
76:                              returnValue = SYS_MODULE_OBJ_INVALID;
9D00CCE8  2402FFFF   ADDIU V0, ZERO, -1
9D00CCEC  AFC20010   SW V0, 16(FP)
77:                              break;
9D00CCF0  00000000   NOP
78:                          }
79:                      }
80:                      return returnValue;
9D00CCF4  8FC20010   LW V0, 16(FP)
81:                  }
9D00CCF8  03C0E821   ADDU SP, FP, ZERO
9D00CCFC  8FBF001C   LW RA, 28(SP)
9D00CD00  8FBE0018   LW FP, 24(SP)
9D00CD04  27BD0020   ADDIU SP, SP, 32
9D00CD08  03E00008   JR RA
9D00CD0C  00000000   NOP
82:                  
83:                  void DRV_USART_Deinitialize( SYS_MODULE_OBJ object)
84:                  {
00000000  00000000   NOP
85:                      switch(object)
00000014  00000000   NOP
86:                      {
87:                          case DRV_USART_INDEX_0:
88:                          {
89:                              DRV_USART0_Deinitialize();
00000034  00000000   NOP
90:                              break;
0000003C  00000000   NOP
91:                          }
92:                          case DRV_USART_INDEX_1:
93:                          {
94:                              DRV_USART1_Deinitialize();
00000044  00000000   NOP
95:                              break;
0000004C  00000000   NOP
96:                          }
97:                          default:
98:                          {
99:                              break;
0000002C  00000000   NOP
100:                         }
101:                     }
102:                 }
00000050  00000000   NOP
103:                 
104:                 SYS_STATUS DRV_USART_Status( SYS_MODULE_OBJ object)
105:                 {
00000000  00000000   NOP
106:                     SYS_STATUS returnValue;
107:                 
108:                     switch(object)
00000014  00000000   NOP
109:                     {
110:                         case DRV_USART_INDEX_0:
111:                         {
112:                             returnValue = DRV_USART0_Status();
00000034  00000000   NOP
113:                             break;
00000040  00000000   NOP
114:                         }
115:                         case DRV_USART_INDEX_1:
116:                         {
117:                             returnValue = DRV_USART1_Status();
00000048  00000000   NOP
118:                             break;
00000054  00000000   NOP
119:                         }
120:                         default:
121:                         {
122:                             returnValue = SYS_STATUS_ERROR;
0000005C  00000000   NOP
123:                             break;
00000064  00000000   NOP
124:                         }
125:                     }
126:                     return returnValue;
00000068  00000000   NOP
127:                 }
0000006C  00000000   NOP
128:                 
129:                 void DRV_USART_TasksTransmit ( SYS_MODULE_OBJ object )
130:                 {
00000000  00000000   NOP
131:                     switch(object)
00000014  00000000   NOP
132:                     {
133:                         case DRV_USART_INDEX_0:
134:                         {
135:                             DRV_USART0_TasksTransmit();
00000034  00000000   NOP
136:                             break;
0000003C  00000000   NOP
137:                         }
138:                         case DRV_USART_INDEX_1:
139:                         {
140:                             DRV_USART1_TasksTransmit();
00000044  00000000   NOP
141:                             break;
0000004C  00000000   NOP
142:                         }
143:                         default:
144:                         {
145:                             break;
0000002C  00000000   NOP
146:                         }
147:                     }
148:                 }
00000050  00000000   NOP
149:                 
150:                 void DRV_USART_TasksReceive ( SYS_MODULE_OBJ object )
151:                 {
00000000  00000000   NOP
152:                     switch(object)
00000014  00000000   NOP
153:                     {
154:                         case DRV_USART_INDEX_0:
155:                         {
156:                             DRV_USART0_TasksReceive();
00000034  00000000   NOP
157:                             break;
0000003C  00000000   NOP
158:                         }
159:                         case DRV_USART_INDEX_1:
160:                         {
161:                             DRV_USART1_TasksReceive();
00000044  00000000   NOP
162:                             break;
0000004C  00000000   NOP
163:                         }
164:                         default:
165:                         {
166:                             break;
0000002C  00000000   NOP
167:                         }
168:                     }
169:                 }
00000050  00000000   NOP
170:                 
171:                 void DRV_USART_TasksError ( SYS_MODULE_OBJ object )
172:                 {
00000000  00000000   NOP
173:                     switch(object)
00000014  00000000   NOP
174:                     {
175:                         case DRV_USART_INDEX_0:
176:                         {
177:                             DRV_USART0_TasksError();
00000034  00000000   NOP
178:                             break;
0000003C  00000000   NOP
179:                         }
180:                         case DRV_USART_INDEX_1:
181:                         {
182:                             DRV_USART1_TasksError();
00000044  00000000   NOP
183:                             break;
0000004C  00000000   NOP
184:                         }
185:                         default:
186:                         {
187:                             break;
0000002C  00000000   NOP
188:                         }
189:                     }
190:                 }
00000050  00000000   NOP
191:                 
192:                 
193:                 //client interface
194:                 DRV_HANDLE DRV_USART_Open( const SYS_MODULE_INDEX index, const DRV_IO_INTENT ioIntent)
195:                 {
00000000  00000000   NOP
196:                     DRV_HANDLE returnValue;
197:                 
198:                     switch(index)
0000001C  00000000   NOP
199:                     {
200:                         case DRV_USART_INDEX_0:
201:                         {
202:                             returnValue = DRV_USART0_Open(index,ioIntent);
0000003C  00000000   NOP
203:                             break;
00000054  00000000   NOP
204:                         }
205:                         case DRV_USART_INDEX_1:
206:                         {
207:                             returnValue = DRV_USART1_Open(index,ioIntent);
0000005C  00000000   NOP
208:                             break;
00000074  00000000   NOP
209:                         }
210:                         default:
211:                         {
212:                             returnValue = DRV_HANDLE_INVALID;
0000007C  00000000   NOP
213:                             break;
00000084  00000000   NOP
214:                         }
215:                     }
216:                     return returnValue;
00000088  00000000   NOP
217:                 }
0000008C  00000000   NOP
218:                 
219:                 void DRV_USART_Close( const DRV_HANDLE handle)
220:                 {
00000000  00000000   NOP
221:                     uintptr_t instance;
222:                 
223:                     instance = handle & 0x00FF;
00000014  00000000   NOP
224:                     //As we are handling single client, only multiple instance is taken care.
225:                     switch(instance)
00000020  00000000   NOP
226:                     {
227:                         case DRV_USART_INDEX_0:
228:                         {
229:                             DRV_USART0_Close();
00000040  00000000   NOP
230:                             break;
00000048  00000000   NOP
231:                         }
232:                         case DRV_USART_INDEX_1:
233:                         {
234:                             DRV_USART1_Close();
00000050  00000000   NOP
235:                             break;
00000058  00000000   NOP
236:                         }
237:                         default:
238:                         {
239:                             break;
00000038  00000000   NOP
240:                         }
241:                     }
242:                 }
0000005C  00000000   NOP
243:                 
244:                 DRV_USART_CLIENT_STATUS DRV_USART_ClientStatus ( DRV_HANDLE handle )
245:                 {
00000000  00000000   NOP
246:                     uintptr_t instance;
247:                     DRV_USART_CLIENT_STATUS returnValue;
248:                 
249:                     instance = handle & 0x00FF;
00000014  00000000   NOP
250:                     //As we are handling single client, only multiple instance is taken care.
251:                     switch(instance)
00000020  00000000   NOP
252:                     {
253:                         case DRV_USART_INDEX_0:
254:                         {
255:                             returnValue = DRV_USART0_ClientStatus();
00000040  00000000   NOP
256:                             break;
0000004C  00000000   NOP
257:                         }
258:                         case DRV_USART_INDEX_1:
259:                         {
260:                             returnValue = DRV_USART1_ClientStatus();
00000054  00000000   NOP
261:                             break;
00000060  00000000   NOP
262:                         }
263:                         default:
264:                         {
265:                             returnValue = DRV_CLIENT_STATUS_ERROR;
00000068  00000000   NOP
266:                             break;
00000070  00000000   NOP
267:                         }
268:                     }
269:                     return returnValue;
00000074  00000000   NOP
270:                 }
00000078  00000000   NOP
271:                 
272:                 DRV_USART_TRANSFER_STATUS DRV_USART_TransferStatus( const DRV_HANDLE handle )
273:                 {
00000000  00000000   NOP
274:                     uintptr_t instance;
275:                     DRV_USART_TRANSFER_STATUS returnValue;
276:                 
277:                     instance = handle & 0x00FF;
00000014  00000000   NOP
278:                     //As we are handling single client, only multiple instance is taken care.
279:                     switch(instance)
00000020  00000000   NOP
280:                     {
281:                         case DRV_USART_INDEX_0:
282:                         {
283:                             returnValue = DRV_USART0_TransferStatus();
00000040  00000000   NOP
284:                             break;
0000004C  00000000   NOP
285:                         }
286:                         case DRV_USART_INDEX_1:
287:                         {
288:                             returnValue = DRV_USART1_TransferStatus();
00000054  00000000   NOP
289:                             break;
00000060  00000000   NOP
290:                         }
291:                         default:
292:                         {
293:                             returnValue = (DRV_USART_TRANSFER_STATUS)NULL;
00000068  00000000   NOP
294:                             break;
0000006C  00000000   NOP
295:                         }
296:                     }
297:                     return returnValue;
00000070  00000000   NOP
298:                 }
00000074  00000000   NOP
299:                 
300:                 DRV_USART_ERROR DRV_USART_ErrorGet(const DRV_HANDLE handle)
301:                 {
00000000  00000000   NOP
302:                     uintptr_t instance;
303:                     DRV_USART_ERROR returnValue;
304:                 
305:                     instance = handle & 0x00FF;
00000014  00000000   NOP
306:                     //As we are handling single client, only multiple instance is taken care.
307:                     switch(instance)
00000020  00000000   NOP
308:                     {
309:                         case DRV_USART_INDEX_0:
310:                         {
311:                             returnValue = DRV_USART0_ErrorGet();
00000040  00000000   NOP
312:                             break;
0000004C  00000000   NOP
313:                         }
314:                         case DRV_USART_INDEX_1:
315:                         {
316:                             returnValue = DRV_USART1_ErrorGet();
00000054  00000000   NOP
317:                             break;
00000060  00000000   NOP
318:                         }
319:                         default:
320:                         {
321:                             returnValue = (DRV_USART_ERROR)NULL;
00000068  00000000   NOP
322:                             break;
0000006C  00000000   NOP
323:                         }
324:                     }
325:                     return returnValue;
00000070  00000000   NOP
326:                 }
00000074  00000000   NOP
327:                 
328:                 
329:                 
330:                 //Byte Model
331:                 uint8_t DRV_USART_ReadByte( const DRV_HANDLE handle )
332:                 {
00000000  00000000   NOP
333:                     uintptr_t instance;
334:                     uint8_t returnValue;
335:                 
336:                     instance = handle & 0x00FF;
00000014  00000000   NOP
337:                     //As we are handling single client, only multiple instance is taken care.
338:                     switch(instance)
00000020  00000000   NOP
339:                     {
340:                         case DRV_USART_INDEX_0:
341:                         {
342:                             returnValue = DRV_USART0_ReadByte();
00000040  00000000   NOP
343:                             break;
0000004C  00000000   NOP
344:                         }
345:                         case DRV_USART_INDEX_1:
346:                         {
347:                             returnValue = DRV_USART1_ReadByte();
00000054  00000000   NOP
348:                             break;
00000060  00000000   NOP
349:                         }
350:                         default:
351:                         {
352:                             SYS_ASSERT(false, "Incorrect Driver Handle");
353:                             returnValue = 0;
00000068  00000000   NOP
354:                             break;
0000006C  00000000   NOP
355:                         }
356:                     }
357:                     return returnValue;
00000070  00000000   NOP
358:                 }
00000074  00000000   NOP
359:                 
360:                 void DRV_USART_WriteByte( const DRV_HANDLE handle, const uint8_t byte)
361:                 {
00000000  00000000   NOP
362:                     uintptr_t instance;
363:                 
364:                     instance = handle & 0x00FF;
0000001C  00000000   NOP
365:                     //As we are handling single client, only multiple instance is taken care.
366:                     switch(instance)
00000028  00000000   NOP
367:                     {
368:                         case DRV_USART_INDEX_0:
369:                         {
370:                             DRV_USART0_WriteByte(byte);
00000048  00000000   NOP
371:                             break;
00000058  00000000   NOP
372:                         }
373:                         case DRV_USART_INDEX_1:
374:                         {
375:                             DRV_USART1_WriteByte(byte);
00000060  00000000   NOP
376:                             break;
00000070  00000000   NOP
377:                         }
378:                         default:
379:                         {
380:                             break;
00000040  00000000   NOP
381:                         }
382:                     }
383:                 }
00000074  00000000   NOP
384:                 
385:                 unsigned int DRV_USART_ReceiverBufferSizeGet( const DRV_HANDLE handle )
386:                 {
00000000  00000000   NOP
387:                     uintptr_t instance;
388:                     unsigned int returnValue;
389:                 
390:                     instance = handle & 0x00FF;
00000014  00000000   NOP
391:                     //As we are handling single client, only multiple instance is taken care.
392:                     switch(instance)
00000020  00000000   NOP
393:                     {
394:                         case DRV_USART_INDEX_0:
395:                         {
396:                             returnValue = DRV_USART0_ReceiverBufferSizeGet();
00000040  00000000   NOP
397:                             break;
0000004C  00000000   NOP
398:                         }
399:                         case DRV_USART_INDEX_1:
400:                         {
401:                             returnValue = DRV_USART1_ReceiverBufferSizeGet();
00000054  00000000   NOP
402:                             break;
00000060  00000000   NOP
403:                         }
404:                         default:
405:                         {
406:                             returnValue = (unsigned int)NULL;
00000068  00000000   NOP
407:                             break;
0000006C  00000000   NOP
408:                         }
409:                     }
410:                     return returnValue;
00000070  00000000   NOP
411:                 }
00000074  00000000   NOP
412:                 
413:                 unsigned int DRV_USART_TransmitBufferSizeGet( const DRV_HANDLE handle )
414:                 {
00000000  00000000   NOP
415:                     uintptr_t instance;
416:                     unsigned int returnValue;
417:                 
418:                     instance = handle & 0x00FF;
00000014  00000000   NOP
419:                     //As we are handling single client, only multiple instance is taken care.
420:                     switch(instance)
00000020  00000000   NOP
421:                     {
422:                         case DRV_USART_INDEX_0:
423:                         {
424:                             returnValue = DRV_USART0_TransmitBufferSizeGet();
00000040  00000000   NOP
425:                             break;
0000004C  00000000   NOP
426:                         }
427:                         case DRV_USART_INDEX_1:
428:                         {
429:                             returnValue = DRV_USART1_TransmitBufferSizeGet();
00000054  00000000   NOP
430:                             break;
00000060  00000000   NOP
431:                         }
432:                         default:
433:                         {
434:                             returnValue = (unsigned int)NULL;
00000068  00000000   NOP
435:                             break;
0000006C  00000000   NOP
436:                         }
437:                     }
438:                     return returnValue;
00000070  00000000   NOP
439:                 }
00000074  00000000   NOP
440:                 
441:                 bool DRV_USART_ReceiverBufferIsEmpty( const DRV_HANDLE handle )
442:                 {
00000000  00000000   NOP
443:                     uintptr_t instance;
444:                     bool returnValue;
445:                 
446:                     instance = handle & 0x00FF;
00000014  00000000   NOP
447:                     //As we are handling single client, only multiple instance is taken care.
448:                     switch(instance)
00000020  00000000   NOP
449:                     {
450:                         case DRV_USART_INDEX_0:
451:                         {
452:                             returnValue = DRV_USART0_ReceiverBufferIsEmpty();
00000040  00000000   NOP
453:                             break;
0000004C  00000000   NOP
454:                         }
455:                         case DRV_USART_INDEX_1:
456:                         {
457:                             returnValue = DRV_USART1_ReceiverBufferIsEmpty();
00000054  00000000   NOP
458:                             break;
00000060  00000000   NOP
459:                         }
460:                         default:
461:                         {
462:                             returnValue = false;
00000068  00000000   NOP
463:                             break;
0000006C  00000000   NOP
464:                         }
465:                     }
466:                     return returnValue;
00000070  00000000   NOP
467:                 }
00000074  00000000   NOP
468:                 
469:                 bool DRV_USART_TransmitBufferIsFull( const DRV_HANDLE handle )
470:                 {
00000000  00000000   NOP
471:                     uintptr_t instance;
472:                     bool returnValue;
473:                 
474:                     instance = handle & 0x00FF;
00000014  00000000   NOP
475:                     //As we are handling single client, only multiple instance is taken care.
476:                     switch(instance)
00000020  00000000   NOP
477:                     {
478:                         case DRV_USART_INDEX_0:
479:                         {
480:                             returnValue = DRV_USART0_TransmitBufferIsFull();
00000040  00000000   NOP
481:                             break;
0000004C  00000000   NOP
482:                         }
483:                         case DRV_USART_INDEX_1:
484:                         {
485:                             returnValue = DRV_USART1_TransmitBufferIsFull();
00000054  00000000   NOP
486:                             break;
00000060  00000000   NOP
487:                         }
488:                         default:
489:                         {
490:                             returnValue = false;
00000068  00000000   NOP
491:                             break;
0000006C  00000000   NOP
492:                         }
493:                     }
494:                     return returnValue;
00000070  00000000   NOP
495:                 }
00000074  00000000   NOP
496:                 
497:                 DRV_USART_BAUD_SET_RESULT DRV_USART_BaudSet(const DRV_HANDLE handle, uint32_t baud)
498:                 {
00000000  00000000   NOP
499:                     uintptr_t instance;
500:                     DRV_USART_BAUD_SET_RESULT returnValue;
501:                 
502:                     instance = handle & 0x00FF;
00000018  00000000   NOP
503:                     //As we are handling single client, only multiple instance is taken care.
504:                     switch(instance)
00000024  00000000   NOP
505:                     {
506:                         case DRV_USART_INDEX_0:
507:                         {
508:                             returnValue = DRV_USART0_BaudSet(baud);
00000044  00000000   NOP
509:                             break;
00000054  00000000   NOP
510:                         }
511:                         case DRV_USART_INDEX_1:
512:                         {
513:                             returnValue = DRV_USART1_BaudSet(baud);
0000005C  00000000   NOP
514:                             break;
0000006C  00000000   NOP
515:                         }
516:                         default:
517:                         {
518:                             returnValue = DRV_USART_BAUD_SET_ERROR;
00000074  00000000   NOP
519:                             break;
0000007C  00000000   NOP
520:                         }
521:                     }
522:                     return returnValue;
00000080  00000000   NOP
523:                 }
00000084  00000000   NOP
524:                 
525:                 DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART_LineControlSet(const DRV_HANDLE handle,const DRV_USART_LINE_CONTROL lineControl)
526:                 {
00000000  00000000   NOP
527:                     uintptr_t instance;
528:                     DRV_USART_LINE_CONTROL_SET_RESULT returnValue;
529:                 
530:                     instance = handle & 0x00FF;
00000018  00000000   NOP
531:                     //As we are handling single client, only multiple instance is taken care.
532:                     switch(instance)
00000024  00000000   NOP
533:                     {
534:                         case DRV_USART_INDEX_0:
535:                         {
536:                             returnValue = DRV_USART0_LineControlSet(lineControl);
00000044  00000000   NOP
537:                             break;
00000054  00000000   NOP
538:                         }
539:                         case DRV_USART_INDEX_1:
540:                         {
541:                             returnValue = DRV_USART1_LineControlSet(lineControl);
0000005C  00000000   NOP
542:                             break;
0000006C  00000000   NOP
543:                         }
544:                         default:
545:                         {
546:                             returnValue = DRV_USART_LINE_CONTROL_SET_ERROR;
00000074  00000000   NOP
547:                             break;
0000007C  00000000   NOP
548:                         }
549:                     }
550:                     return returnValue;
00000080  00000000   NOP
551:                 }
00000084  00000000   NOP
552:                 
553:                 
554:                 /*******************************************************************************
555:                  End of File
556:                 */
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_static.c
1:                   /*******************************************************************************
2:                     Timer Static Driver File
3:                   
4:                     File Name:
5:                       drv_tmr_static.c
6:                   
7:                     Company:
8:                       Microchip Technology Inc.   
9:                   
10:                    Summary:
11:                      Timer driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      None
19:                   *******************************************************************************/
20:                  
21:                  /*******************************************************************************
22:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublTMRense terms in the accompanying lTMRense agreement).
28:                  
29:                  You should refer to the lTMRense agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTTMRULAR PURPOSE.
35:                  IN NO EVENT SHALL MTMRROCHIP OR ITS LTMRENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRTMRT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVTMRES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                   *******************************************************************************/
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Header Includes
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include "driver/tmr/drv_tmr_static.h"
50:                  #include "driver/tmr/src/drv_tmr_variant_mapping.h"
51:                  
52:                  typedef struct
53:                  {
54:                      DRV_TMR_CALLBACK alarmFunc;  // For alarm registering
55:                      uint32_t alarmCount;    // For AlarmHasElapsed function
56:                      bool    alarmEnabled;   // For Enable/Disable function
57:                      bool    alarmPeriodic;      // Keep Alarm enabled or disable it
58:                      uintptr_t   alarmContext;   // For Alarm Callback
59:                      uint32_t    alarmPeriod;    // For Period Set/Get
60:                  } DRV_TMR_ALARM_OBJ;
61:                  
62:                  static bool _DRV_TMR_ClockSourceSet(TMR_MODULE_ID timerId, DRV_TMR_CLK_SOURCES clockSource)
63:                  {
00000000  00000000   NOP
64:                      bool clockSet = true;
00000018  00000000   NOP
65:                      /* Clock Source Selection */
66:                      if(clockSource == DRV_TMR_CLKSOURCE_INTERNAL)
00000020  00000000   NOP
67:                      {
68:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
0000002C  00000000   NOP
69:                          {               
70:                              PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );           
00000040  00000000   NOP
71:                          }
72:                          else
73:                          {
74:                              /* If clock source feature doesn't exist for any specific timer module instance,
75:                              then by default internal peripheral clock is considered as timer source, so do nothing */ 
76:                          }
77:                      }
78:                      /* External Synchronous Clock Source Selection */
79:                      else if(!(clockSource & 0x10))
00000058  00000000   NOP
80:                      {
81:                          if ( PLIB_TMR_ExistsClockSource ( timerId ) )
00000068  00000000   NOP
82:                          {               
83:                              if ( PLIB_TMR_ExistsClockSourceSync ( timerId )  )
0000007C  00000000   NOP
84:                              {
85:                                  PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );                
00000090  00000000   NOP
86:                                  PLIB_TMR_ClockSourceExternalSyncEnable ( timerId );                    
000000A8  00000000   NOP
87:                              }
88:                              /* If Synchronization feature doesn't exist for any specific timer module 
89:                              instance with external clock source then it is synchronous by default */
90:                              else if (clockSource == DRV_TMR_CLKSOURCE_EXTERNAL_SYNCHRONOUS)
000000BC  00000000   NOP
91:                              {
92:                                  PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_EXTERNAL_INPUT_PIN );
000000CC  00000000   NOP
93:                              }
94:                              else
95:                              {
96:                                  clockSet = false;
000000E4  00000000   NOP
97:                              }  
98:                          }
99:                          else
100:                         {
101:                             clockSet = false;
000000F0  00000000   NOP
102:                         }        
103:                     }
104:                     /* External Asynchronous Clock Source Selection */
105:                     else if(clockSource & 0x10)
000000FC  00000000   NOP
106:                     {
107:                         if ( PLIB_TMR_ExistsClockSourceSync ( timerId ) )
0000010C  00000000   NOP
108:                         {
109:                             PLIB_TMR_ClockSourceSelect ( timerId, (TMR_CLOCK_SOURCE)(clockSource & 0x0F) );
00000120  00000000   NOP
110:                             PLIB_TMR_ClockSourceExternalSyncDisable ( timerId );
00000138  00000000   NOP
111:                         }
112:                         else
113:                         {
114:                             clockSet = false;
0000014C  00000000   NOP
115:                         }        
116:                     }
117:                     
118:                     return clockSet;
00000150  00000000   NOP
119:                 }
00000154  00000000   NOP
120:                 
121:                 // Prescaler selection
122:                 static bool _DRV_TMR_ClockPrescaleSet(TMR_MODULE_ID timerId, TMR_PRESCALE  prescale)
123:                 {
00000000  00000000   NOP
124:                     if( PLIB_TMR_ExistsPrescale( timerId ) )
00000018  00000000   NOP
125:                     {
126:                         PLIB_TMR_PrescaleSelect( timerId , prescale );
0000002C  00000000   NOP
127:                         return true;
0000003C  00000000   NOP
128:                     }
129:                     return false;
00000048  00000000   NOP
130:                 }
0000004C  00000000   NOP
131:                 
132:                 
133:                 // *****************************************************************************
134:                 // *****************************************************************************
135:                 // Section: Instance 1 static driver data
136:                 // *****************************************************************************
137:                 // *****************************************************************************
138:                 
139:                 static bool                   DRV_TMR1_Running;
140:                 
141:                 // *****************************************************************************
142:                 // *****************************************************************************
143:                 // Section: Instance 1 static driver functions
144:                 // *****************************************************************************
145:                 // *****************************************************************************
146:                 void DRV_TMR1_Initialize(void)
147:                 {   
9D00C2CC  27BDFFE8   ADDIU SP, SP, -24
9D00C2D0  AFBF0014   SW RA, 20(SP)
9D00C2D4  AFBE0010   SW FP, 16(SP)
9D00C2D8  03A0F021   ADDU FP, SP, ZERO
148:                     /* Initialize Timer Instance1 */
149:                     /* Disable Timer */
150:                     PLIB_TMR_Stop(TMR_ID_2);
9D00C2DC  3C02BF80   LUI V0, -16512
9D00C2E0  34440800   ORI A0, V0, 2048
9D00C2E4  0F4038E8   JAL PLIB_TMR_Stop
9D00C2E8  00000000   NOP
151:                     /* Select clock source */
152:                     PLIB_TMR_ClockSourceSelect ( TMR_ID_2, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );
9D00C2EC  3C02BF80   LUI V0, -16512
9D00C2F0  34440800   ORI A0, V0, 2048
9D00C2F4  00002821   ADDU A1, ZERO, ZERO
9D00C2F8  0F40388F   JAL PLIB_TMR_ClockSourceSelect
9D00C2FC  00000000   NOP
153:                     /* Select prescalar value */
154:                     PLIB_TMR_PrescaleSelect(TMR_ID_2, TMR_PRESCALE_VALUE_16);
9D00C300  3C02BF80   LUI V0, -16512
9D00C304  34440800   ORI A0, V0, 2048
9D00C308  24050004   ADDIU A1, ZERO, 4
9D00C30C  0F40313B   JAL .LFE3, PLIB_TMR_PrescaleSelect
9D00C310  00000000   NOP
155:                     /* Enable 16 bit mode */
156:                     PLIB_TMR_Mode16BitEnable(TMR_ID_2);
9D00C314  3C02BF80   LUI V0, -16512
9D00C318  34440800   ORI A0, V0, 2048
9D00C31C  0F403856   JAL PLIB_TMR_Mode16BitEnable
9D00C320  00000000   NOP
157:                     /* Clear counter */ 
158:                     PLIB_TMR_Counter16BitClear(TMR_ID_2);
9D00C324  3C02BF80   LUI V0, -16512
9D00C328  34440800   ORI A0, V0, 2048
9D00C32C  0F403915   JAL PLIB_TMR_Counter16BitClear
9D00C330  00000000   NOP
159:                     /*Set period */ 
160:                     PLIB_TMR_Period16BitSet(TMR_ID_2, 62499);
9D00C334  3C02BF80   LUI V0, -16512
9D00C338  34440800   ORI A0, V0, 2048
9D00C33C  3405F423   ORI A1, ZERO, -3037
9D00C340  0F403918   JAL PLIB_TMR_Period16BitSet
9D00C344  00000000   NOP
161:                     /* Setup Interrupt */   
162:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_T2, INT_PRIORITY_LEVEL1);
9D00C348  00002021   ADDU A0, ZERO, ZERO
9D00C34C  24050008   ADDIU A1, ZERO, 8
9D00C350  24060001   ADDIU A2, ZERO, 1
9D00C354  0F4035E5   JAL .LFE8, PLIB_INT_VectorPrioritySet
9D00C358  00000000   NOP
163:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_T2, INT_SUBPRIORITY_LEVEL0);          
9D00C35C  00002021   ADDU A0, ZERO, ZERO
9D00C360  24050008   ADDIU A1, ZERO, 8
9D00C364  00003021   ADDU A2, ZERO, ZERO
9D00C368  0F403623   JAL .LFE1152, PLIB_INT_VectorSubPrioritySet
9D00C36C  00000000   NOP
164:                 }
9D00C370  03C0E821   ADDU SP, FP, ZERO
9D00C374  8FBF0014   LW RA, 20(SP)
9D00C378  8FBE0010   LW FP, 16(SP)
9D00C37C  27BD0018   ADDIU SP, SP, 24
9D00C380  03E00008   JR RA
9D00C384  00000000   NOP
165:                 
166:                 static void _DRV_TMR1_Resume(bool resume)
167:                 {
9D00D288  27BDFFE8   ADDIU SP, SP, -24
9D00D28C  AFBF0014   SW RA, 20(SP)
9D00D290  AFBE0010   SW FP, 16(SP)
9D00D294  03A0F021   ADDU FP, SP, ZERO
9D00D298  00801021   ADDU V0, A0, ZERO
9D00D29C  A3C20018   SB V0, 24(FP)
168:                     if (resume)
9D00D2A0  93C20018   LBU V0, 24(FP)
9D00D2A4  1040000D   BEQ V0, ZERO, .LVL37
9D00D2A8  00000000   NOP
169:                     {
170:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_2);
9D00D2AC  00002021   ADDU A0, ZERO, ZERO
9D00D2B0  24050009   ADDIU A1, ZERO, 9
9D00D2B4  0F403790   JAL PLIB_INT_SourceFlagClear
9D00D2B8  00000000   NOP
171:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_2);
9D00D2BC  00002021   ADDU A0, ZERO, ZERO
9D00D2C0  24050009   ADDIU A1, ZERO, 9
9D00D2C4  0F40379A   JAL PLIB_INT_SourceEnable
9D00D2C8  00000000   NOP
172:                         PLIB_TMR_Start(TMR_ID_2);
9D00D2CC  3C02BF80   LUI V0, -16512
9D00D2D0  34440800   ORI A0, V0, 2048
9D00D2D4  0F4038E4   JAL PLIB_TMR_Start
9D00D2D8  00000000   NOP
173:                     }
174:                 }
9D00D2DC  03C0E821   ADDU SP, FP, ZERO
9D00D2E0  8FBF0014   LW RA, 20(SP)
9D00D2E4  8FBE0010   LW FP, 16(SP)
9D00D2E8  27BD0018   ADDIU SP, SP, 24
9D00D2EC  03E00008   JR RA
9D00D2F0  00000000   NOP
175:                 
176:                 bool DRV_TMR1_Start(void)
177:                 {
9D00DA80  27BDFFE8   ADDIU SP, SP, -24
9D00DA84  AFBF0014   SW RA, 20(SP)
9D00DA88  AFBE0010   SW FP, 16(SP)
9D00DA8C  03A0F021   ADDU FP, SP, ZERO
178:                     /* Start Timer*/
179:                     _DRV_TMR1_Resume(true);
9D00DA90  24040001   ADDIU A0, ZERO, 1
9D00DA94  0F4034A2   JAL .LFB496, _DRV_TMR1_Resume, .LVL33, .LFE0
9D00DA98  00000000   NOP
180:                     DRV_TMR1_Running = true;
9D00DA9C  24020001   ADDIU V0, ZERO, 1
9D00DAA0  A382801A   SB V0, -32742(GP)
181:                     
182:                     return true;
9D00DAA4  24020001   ADDIU V0, ZERO, 1
183:                 }
9D00DAA8  03C0E821   ADDU SP, FP, ZERO
9D00DAAC  8FBF0014   LW RA, 20(SP)
9D00DAB0  8FBE0010   LW FP, 16(SP)
9D00DAB4  27BD0018   ADDIU SP, SP, 24
9D00DAB8  03E00008   JR RA
9D00DABC  00000000   NOP
184:                 
185:                 static bool _DRV_TMR1_Suspend(void)
186:                 {
00000000  00000000   NOP
187:                     if (DRV_TMR1_Running)
00000010  00000000   NOP
188:                     {
189:                         PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_TIMER_2);
0000001C  00000000   NOP
190:                         PLIB_TMR_Stop(TMR_ID_2);
0000002C  00000000   NOP
191:                         return (true);
0000003C  00000000   NOP
192:                     }
193:                     
194:                     return (false);
00000048  00000000   NOP
195:                 }
0000004C  00000000   NOP
196:                 
197:                 void DRV_TMR1_Stop(void)
198:                 {
00000000  00000000   NOP
199:                     _DRV_TMR1_Suspend();
00000010  00000000   NOP
200:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_2);
00000018  00000000   NOP
201:                     DRV_TMR1_Running = false;
00000028  00000000   NOP
202:                 }
0000002C  00000000   NOP
203:                 
204:                 DRV_TMR_CLIENT_STATUS DRV_TMR1_ClientStatus ( void )
205:                 {
00000000  00000000   NOP
206:                     if (DRV_TMR1_Running)
0000000C  00000000   NOP
207:                         return DRV_TMR_CLIENT_STATUS_RUNNING;
00000018  00000000   NOP
208:                     else
209:                         return DRV_TMR_CLIENT_STATUS_READY;
00000024  00000000   NOP
210:                 }
00000028  00000000   NOP
211:                 
212:                 void DRV_TMR1_CounterValueSet(uint32_t value)
213:                 {
00000000  00000000   NOP
214:                     /* Set 16-bit counter value*/
215:                     PLIB_TMR_Counter16BitSet(TMR_ID_2, (uint16_t)value);
00000014  00000000   NOP
216:                 }
00000030  00000000   NOP
217:                 
218:                 uint32_t DRV_TMR1_CounterValueGet(void)
219:                 {
00000000  00000000   NOP
220:                     /* Get 16-bit counter value*/
221:                     return (uint32_t) PLIB_TMR_Counter16BitGet(TMR_ID_2);
00000010  00000000   NOP
222:                 }
00000020  00000000   NOP
223:                 
224:                 void DRV_TMR1_CounterClear(void)
225:                 {
00000000  00000000   NOP
226:                     /* Clear 16-bit counter value*/
227:                     PLIB_TMR_Counter16BitClear(TMR_ID_2);
00000010  00000000   NOP
228:                 }
00000020  00000000   NOP
229:                 
230:                 DRV_TMR_OPERATION_MODE DRV_TMR1_DividerRangeGet
231:                 (
232:                 	DRV_TMR_DIVIDER_RANGE * pDivRange
233:                 )
234:                 {
00000000  00000000   NOP
235:                 	if(pDivRange)
00000010  00000000   NOP
236:                 	{
237:                         pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_16BIT;
0000001C  00000000   NOP
238:                         pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_16BIT;
00000028  00000000   NOP
239:                 		pDivRange->dividerStep = 1;
00000034  00000000   NOP
240:                 		return DRV_TMR_OPERATION_MODE_16_BIT;
00000040  00000000   NOP
241:                 	}
242:                 	return DRV_TMR_OPERATION_MODE_NONE;
0000004C  00000000   NOP
243:                 }
00000050  00000000   NOP
244:                 
245:                 uint32_t DRV_TMR1_CounterFrequencyGet(void)
246:                 {
00000000  00000000   NOP
247:                     uint32_t prescale, tmrBaseFreq;
248:                     
249:                     tmrBaseFreq = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_FOR_TIMER_PERIPHERAL );
00000010  00000000   NOP
250:                     prescale = PLIB_TMR_PrescaleGet(TMR_ID_2);
00000020  00000000   NOP
251:                     return ( tmrBaseFreq / prescale );
00000034  00000000   NOP
252:                 }
0000004C  00000000   NOP
253:                 
254:                 TMR_PRESCALE DRV_TMR1_PrescalerGet(void)
255:                 {
00000000  00000000   NOP
256:                     uint16_t prescale_value;
257:                     /* Call the PLIB directly */
258:                     prescale_value = PLIB_TMR_PrescaleGet(TMR_ID_2);
00000010  00000000   NOP
259:                     
260:                     switch(prescale_value)
00000024  00000000   NOP
261:                     {
262:                         case 1: return TMR_PRESCALE_VALUE_1;
000000B8  00000000   NOP
263:                         case 2: return TMR_PRESCALE_VALUE_2;
000000C4  00000000   NOP
264:                         case 4: return TMR_PRESCALE_VALUE_4;
000000D0  00000000   NOP
265:                         case 8: return TMR_PRESCALE_VALUE_8;
000000DC  00000000   NOP
266:                         case 16: return TMR_PRESCALE_VALUE_16;
000000E8  00000000   NOP
267:                         case 32: return TMR_PRESCALE_VALUE_32;
000000F4  00000000   NOP
268:                         case 64: return TMR_PRESCALE_VALUE_64;
00000100  00000000   NOP
269:                         case 256: return TMR_PRESCALE_VALUE_256;
0000010C  00000000   NOP
270:                         default: return TMR_PRESCALE_VALUE_1;
00000118  00000000   NOP
271:                     }
272:                 }
0000011C  00000000   NOP
273:                 
274:                 void DRV_TMR1_PeriodValueSet(uint32_t value)
275:                 {
00000000  00000000   NOP
276:                     /* Set 16-bit counter value*/
277:                     PLIB_TMR_Period16BitSet(TMR_ID_2, (uint16_t)value);
00000014  00000000   NOP
278:                 }
00000030  00000000   NOP
279:                 
280:                 uint32_t DRV_TMR1_PeriodValueGet(void)
281:                 {
00000000  00000000   NOP
282:                     /* Get 16-bit counter value*/
283:                     return (uint32_t) PLIB_TMR_Period16BitGet(TMR_ID_2);
00000010  00000000   NOP
284:                 }
00000020  00000000   NOP
285:                 
286:                 void DRV_TMR1_StopInIdleDisable(void)
287:                 {
00000000  00000000   NOP
288:                     PLIB_TMR_StopInIdleDisable(TMR_ID_2);
00000010  00000000   NOP
289:                 }
00000020  00000000   NOP
290:                 
291:                 void DRV_TMR1_StopInIdleEnable(void)
292:                 {
00000000  00000000   NOP
293:                     PLIB_TMR_StopInIdleDisable(TMR_ID_2);
00000010  00000000   NOP
294:                 }
00000020  00000000   NOP
295:                 
296:                 bool DRV_TMR1_ClockSet
297:                 (
298:                     DRV_TMR_CLK_SOURCES clockSource,
299:                     TMR_PRESCALE        preScale
300:                 )
301:                 {
00000000  00000000   NOP
302:                     bool success = false;
00000018  00000000   NOP
303:                     bool resume = _DRV_TMR1_Suspend();
0000001C  00000000   NOP
304:                     
305:                     if (_DRV_TMR_ClockSourceSet(TMR_ID_2, clockSource) &&
00000028  00000000   NOP
00000058  00000000   NOP
306:                         _DRV_TMR_ClockPrescaleSet(TMR_ID_2, preScale))
00000044  00000000   NOP
307:                     {
308:                         success = true;
00000060  00000000   NOP
309:                     }
310:                     
311:                     _DRV_TMR1_Resume(resume);
00000068  00000000   NOP
312:                     return success;
00000078  00000000   NOP
313:                 }
0000007C  00000000   NOP
314:                 
315:                  
316:                  
317:                 /*******************************************************************************
318:                  End of File
319:                 */
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/driver/tmr/src/drv_tmr_mapping.c
1:                   /*******************************************************************************
2:                     Timer Driver Interface Mapping Dynamic APIs to Static APIs           
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr_mapping.h
9:                   
10:                    Summary:
11:                      This file allows maintaining a single set of APIs for all Timer transactions  
12:                      by making the type of implementation transparent to the application. In case
13:                      where static implementation of Timer driver is selected, this file maps the 
14:                      API functions to a particular driver instance-specific static implementation
15:                      function, eliminating unnecessary dynamic parameters. 
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #include "driver/tmr/drv_tmr.h"
44:                  #include "driver/tmr/drv_tmr_static.h"
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Driver System Interface Function Definitions
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  // *****************************************************************************
53:                  /* Function:
54:                      SYS_MODULE_OBJ DRV_TMR_Initialize 
55:                      ( 
56:                          const SYS_MODULE_INDEX drvIndex,
57:                          const SYS_MODULE_INIT * const init 
58:                      )
59:                  
60:                    Summary:
61:                      Initializes the Timer driver.
62:                  
63:                    Description:
64:                      This function initializes the Timer driver, making it ready for clients to
65:                      open and use it.
66:                  
67:                    Remarks:
68:                      Refer to drv_tmr.h for usage information.
69:                  */
70:                  
71:                  SYS_MODULE_OBJ DRV_TMR_Initialize 
72:                  ( 
73:                      const SYS_MODULE_INDEX drvIndex,
74:                      const SYS_MODULE_INIT  * const init 
75:                  )
76:                  {
00000000  00000000   NOP
77:                  	SYS_MODULE_OBJ sysObj;
78:                  	
79:                  	switch (drvIndex)
0000001C  00000000   NOP
80:                      {
81:                                  case DRV_TMR_INDEX_1:
82:                          {
83:                              DRV_TMR1_Initialize();
0000002C  00000000   NOP
84:                  			sysObj = (SYS_MODULE_OBJ)DRV_TMR_INDEX_1;
00000034  00000000   NOP
85:                              break;
0000003C  00000000   NOP
86:                          }
87:                          default:
88:                          {
89:                  			sysObj = SYS_MODULE_OBJ_INVALID;
00000044  00000000   NOP
90:                              break;
0000004C  00000000   NOP
91:                          }
92:                      }
93:                  	return sysObj;
00000050  00000000   NOP
94:                  }
00000054  00000000   NOP
95:                  
96:                  // *****************************************************************************
97:                  /* Function:
98:                      void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
99:                  
100:                   Summary:
101:                     Deinitializes the specified instance of the Timer driver.
102:                 
103:                   Description:
104:                     Deinitializes the specified instance of the Timer driver, disabling
105:                     its operation (and any hardware). All internal data is invalidated.
106:                 
107:                   Remarks:
108:                     Refer to drv_tmr.h for usage information.
109:                 */
110:                 
111:                 void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
112:                 {
00000000  00000000   NOP
113:                 	switch (object)
00000014  00000000   NOP
114:                     {
115:                         case DRV_TMR_INDEX_1:
116:                         {
117:                             DRV_TMR1_DeInitialize();
0000002C  00000000   NOP
118:                             break;
00000034  00000000   NOP
119:                         }
120:                         default:
121:                         {
122:                             break;
00000024  00000000   NOP
123:                         }
124:                     }
125:                 }
00000038  00000000   NOP
126:                 
127:                 // *****************************************************************************
128:                 /* Function:
129:                     SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
130:                 
131:                   Summary:
132:                     Provides the current status of the Timer driver.
133:                 
134:                   Description:
135:                     This function provides the current status of the Timer driver.
136:                 
137:                   Remarks:
138:                     Refer to drv_tmr.h for usage information.
139:                 */
140:                 
141:                 SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
142:                 {
00000000  00000000   NOP
143:                 	SYS_STATUS returnValue;
144:                 	
145:                 	switch (object)
00000014  00000000   NOP
146:                     {
147:                         case DRV_TMR_INDEX_1:
148:                         {
149:                             returnValue = DRV_TMR1_Status();
0000002C  00000000   NOP
150:                             break;
00000038  00000000   NOP
151:                         }
152:                         default:
153:                         {
154:                             break;
00000024  00000000   NOP
155:                         }
156:                     }
157:                 	return returnValue;
0000003C  00000000   NOP
158:                 }
00000040  00000000   NOP
159:                 
160:                 // *****************************************************************************
161:                 /* Function:
162:                     void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
163:                 
164:                   Summary:
165:                     Maintains the driver's state machine.
166:                 
167:                   Description:
168:                     This function is used to maintain the driver's internal state machine and
169:                     processes the timer events.
170:                 
171:                   Remarks:
172:                     Refer to drv_tmr.h for usage information.
173:                 */
174:                 
175:                 void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
176:                 {
00000000  00000000   NOP
177:                 	switch (object)
00000014  00000000   NOP
178:                     {
179:                         case DRV_TMR_INDEX_1:
180:                         {
181:                             DRV_TMR1_Tasks();
0000002C  00000000   NOP
182:                             break;
00000034  00000000   NOP
183:                         }
184:                         default:
185:                         {
186:                             break;
00000024  00000000   NOP
187:                         }
188:                     }
189:                 }
00000038  00000000   NOP
190:                 
191:                 // *****************************************************************************
192:                 // *****************************************************************************
193:                 // Section: TMR Driver Client Functions
194:                 // *****************************************************************************
195:                 // *****************************************************************************
196:                 
197:                 // *****************************************************************************
198:                 /* Function:
199:                     DRV_HANDLE DRV_TMR_Open 
200:                     ( 
201:                         const SYS_MODULE_INDEX index,
202:                         const DRV_IO_INTENT    intent
203:                     )
204:                 
205:                   Summary:
206:                     Opens the specified Timer driver instance and returns a handle to it.
207:                   
208:                   Description:
209:                     This function opens the specified Timer driver instance and provides a
210:                     handle that must be provided to all other client-level operations to
211:                     identify the caller and the instance of the driver.  Timer driver does not
212:                     support multiple clients. If two tasks want to use the timer, one should
213:                     wait until the other one gets closed. 
214:                 
215:                   Remarks:
216:                     Refer to drv_tmr.h for usage information.
217:                 */
218:                 
219:                 DRV_HANDLE DRV_TMR_Open 
220:                 ( 
221:                     const SYS_MODULE_INDEX index, 
222:                     const DRV_IO_INTENT intent 
223:                 )
224:                 {
00000000  00000000   NOP
225:                     switch (index)
00000018  00000000   NOP
226:                     {
227:                         case DRV_TMR_INDEX_1:
228:                         {
229:                             return (DRV_HANDLE)DRV_TMR_INDEX_1;
00000038  00000000   NOP
230:                             break;
231:                         }
232:                         default:
233:                         {
234:                             break;
00000028  00000000   NOP
235:                         }
236:                     }
237:                     
238:                     return (DRV_HANDLE)NULL;
0000002C  00000000   NOP
239:                 }
0000003C  00000000   NOP
240:                 
241:                 // *****************************************************************************
242:                 /* Function:
243:                     void DRV_TMR_Close ( DRV_HANDLE handle )
244:                 
245:                   Summary:
246:                     Closes an opened instance of the Timer driver.
247:                 
248:                   Description:
249:                     This function closes an opened instance of the Timer driver, invalidating
250:                     the handle.
251:                   
252:                   Remarks:
253:                     Refer to drv_tmr.h for usage information.
254:                 */
255:                 
256:                 void DRV_TMR_Close ( DRV_HANDLE handle )
257:                 {
00000000  00000000   NOP
258:                     switch (handle)
00000014  00000000   NOP
259:                     {
260:                         case DRV_TMR_INDEX_1:
261:                         {
262:                             DRV_TMR1_Close();
0000002C  00000000   NOP
263:                             break;
00000034  00000000   NOP
264:                         }
265:                         default:
266:                         {
267:                             break;
00000024  00000000   NOP
268:                         }
269:                     }
270:                 }
00000038  00000000   NOP
271:                 
272:                 // *****************************************************************************
273:                 /* Function:
274:                     DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus ( DRV_HANDLE handle )
275:                 
276:                   Summary:
277:                     Gets the status of the client operation.
278:                 
279:                   Description:
280:                     This function gets the status of the recently completed client level
281:                     operation.
282:                 
283:                   Remarks:
284:                     Refer to drv_tmr.h for usage information.
285:                 */
286:                 
287:                 DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus 
288:                 ( DRV_HANDLE handle )
289:                 {
00000000  00000000   NOP
290:                     switch (handle)
00000014  00000000   NOP
291:                     {
292:                         case DRV_TMR_INDEX_1:
293:                         {
294:                             return DRV_TMR1_ClientStatus();
00000034  00000000   NOP
295:                             break;
296:                         }
297:                         default:
298:                         {
299:                             break;
00000024  00000000   NOP
300:                         }
301:                     }
302:                 
303:                     return DRV_TMR_CLIENT_STATUS_INVALID;
00000028  00000000   NOP
304:                 }
0000003C  00000000   NOP
305:                 
306:                 // *****************************************************************************
307:                 // *****************************************************************************
308:                 // Section: TMR Driver Counter functions
309:                 // *****************************************************************************
310:                 // *****************************************************************************
311:                 
312:                 // *****************************************************************************
313:                 /* Function:
314:                     void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
315:                 
316:                   Summary:
317:                     Updates the Timer's counter register.
318:                 
319:                   Description:
320:                     This function updates the Timer's value in the counter register.
321:                 
322:                   Remarks:
323:                     Refer to drv_tmr.h for usage information.
324:                 */
325:                 
326:                 void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
327:                 {
00000000  00000000   NOP
328:                     switch (handle)
00000018  00000000   NOP
329:                     {
330:                         case DRV_TMR_INDEX_1:
331:                         {
332:                             DRV_TMR1_CounterValueSet(counterPeriod);
00000030  00000000   NOP
333:                             break;
0000003C  00000000   NOP
334:                         }
335:                         default:
336:                         {
337:                             break;
00000028  00000000   NOP
338:                         }
339:                     }
340:                 }
00000040  00000000   NOP
341:                 
342:                 // *****************************************************************************
343:                 /* Function:
344:                     uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
345:                 
346:                   Summary:
347:                     Reads the Timer's counter register.
348:                 
349:                   Description:
350:                     This function returns the Timer's value in the counter register.
351:                 
352:                   Remarks:
353:                     Refer to drv_tmr.h for usage information.
354:                 */
355:                 
356:                 uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
357:                 {
00000000  00000000   NOP
358:                     switch (handle)
00000014  00000000   NOP
359:                     {
360:                         case DRV_TMR_INDEX_1:
361:                         {
362:                             return DRV_TMR1_CounterValueGet();
00000034  00000000   NOP
363:                             break;
364:                         }
365:                         default:
366:                         {
367:                             break;
00000024  00000000   NOP
368:                         }
369:                     }
370:                 
371:                     return 0;
00000028  00000000   NOP
372:                 }
0000003C  00000000   NOP
373:                 
374:                 // *****************************************************************************
375:                 /* Function:
376:                     void DRV_TMR_CounterClear ( DRV_HANDLE handle )
377:                 
378:                   Summary:
379:                     Clears the Timer's counter register.
380:                 
381:                   Description:
382:                     This function clears the Timer's value in the counter register.
383:                 
384:                   Remarks:
385:                     Refer to drv_tmr.h for usage information.
386:                 */
387:                 
388:                 void DRV_TMR_CounterClear ( DRV_HANDLE handle )
389:                 {
00000000  00000000   NOP
390:                     switch (handle)
00000014  00000000   NOP
391:                     {
392:                         case DRV_TMR_INDEX_1:
393:                         {
394:                             DRV_TMR1_CounterClear();
0000002C  00000000   NOP
395:                             break;
00000034  00000000   NOP
396:                         }
397:                         default:
398:                         {
399:                             break;
00000024  00000000   NOP
400:                         }
401:                     }
402:                 }
00000038  00000000   NOP
403:                 
404:                 // *****************************************************************************
405:                 // *****************************************************************************
406:                 // Section: TMR Driver Alarm functions
407:                 // *****************************************************************************
408:                 // *****************************************************************************
409:                 
410:                 // *****************************************************************************
411:                 /* Function:
412:                     bool DRV_TMR_AlarmRegister 
413:                     ( 
414:                         DRV_HANDLE handle, 
415:                         uint32_t divider, 
416:                         bool isPeriodic, 
417:                         uintptr_t context, 
418:                         DRV_TMR_CALLBACK callBack 
419:                     )
420:                 
421:                   Summary:
422:                     Sets up an alarm.
423:                 
424:                   Description:
425:                     This function sets up an alarm, allowing the client to receive a callback
426:                     from the driver when the timer counter reaches zero.  Alarms can be one-shot
427:                     or periodic.  A periodic alarm will reload the timer and generate alarm
428:                     until stopped.  The alarm frequency is: DRV_TMR_CounterFrequencyGet() /
429:                     divider;
430:                 
431:                   Remarks:
432:                     Refer to drv_tmr.h for usage information.
433:                 */
434:                 
435:                 bool DRV_TMR_AlarmRegister 
436:                 (
437:                     DRV_HANDLE handle, 
438:                     uint32_t divider, 
439:                     bool isPeriodic, 
440:                     uintptr_t context, 
441:                     DRV_TMR_CALLBACK callBack 
442:                 )
443:                 {
00000000  00000000   NOP
444:                     switch (handle)
445:                     {
446:                         default:
447:                         {
448:                             break;
00000020  00000000   NOP
449:                         }
450:                     }
451:                 
452:                     return false;
00000024  00000000   NOP
453:                 }
00000028  00000000   NOP
454:                 
455:                 // *****************************************************************************
456:                 /* Function:
457:                     bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle);
458:                 
459:                   Summary:
460:                     Disables an alarm signal.
461:                 
462:                   Description:
463:                     This function allows the client to disable an alarm generation.
464:                     Use DRV_TMR_AlarmEnable to re-enable.
465:                 
466:                   Remarks:
467:                     Refer to drv_tmr.h for usage information.
468:                 */
469:                 
470:                 bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle)
471:                 {
00000000  00000000   NOP
472:                     switch (handle)
473:                     {
474:                         default:
475:                         {
476:                             break;
00000010  00000000   NOP
477:                         }
478:                     }
479:                 
480:                     return false;
00000014  00000000   NOP
481:                 }
00000018  00000000   NOP
482:                 
483:                 // *****************************************************************************
484:                 /* Function:
485:                     void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable );
486:                 
487:                   Summary:
488:                     Re-enables an alarm signal.
489:                 
490:                   Description:
491:                     This function allows the client to re-enable an alarm after it has been
492:                     disabled by a DRV_TMR_AlarmDisable call.
493:                 
494:                   Remarks:
495:                     Refer to drv_tmr.h for usage information.
496:                 */
497:                 
498:                 void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable )
499:                 {
00000000  00000000   NOP
500:                     switch (handle)
501:                     {
502:                         default:
503:                         {
504:                             break;
00000018  00000000   NOP
505:                         }
506:                     }
507:                 }
0000001C  00000000   NOP
508:                 
509:                 // *****************************************************************************
510:                 /* Function:
511:                     void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
512:                 
513:                   Summary:
514:                     Updates the Timer's period.
515:                 
516:                   Description:
517:                     This function updates the Timer's period.
518:                 
519:                   Remarks:
520:                     Refer to drv_tmr.h for usage information.
521:                 */
522:                 
523:                 void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
524:                 {
00000000  00000000   NOP
525:                     switch (handle)
526:                     {
527:                         default:
528:                         {
529:                             break;
00000014  00000000   NOP
530:                         }
531:                     }
532:                 }
00000018  00000000   NOP
533:                 
534:                 // *****************************************************************************
535:                 /* Function:
536:                     uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
537:                 
538:                   Summary:
539:                     Provides the Timer's period.
540:                 
541:                   Description:
542:                     This function gets the Timer's period.
543:                 
544:                   Remarks:
545:                     Refer to drv_tmr.h for usage information.
546:                 */
547:                 
548:                 uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
549:                 {
00000000  00000000   NOP
550:                     switch (handle)
551:                     {
552:                         default:
553:                         {
554:                             break;
00000010  00000000   NOP
555:                         }
556:                     }
557:                 
558:                     return 0;
00000014  00000000   NOP
559:                 }
00000018  00000000   NOP
560:                 
561:                 // *****************************************************************************
562:                 /* Function:
563:                     void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
564:                 
565:                   Summary:
566:                     Removes a previously set alarm.
567:                 
568:                   Description:
569:                     This function removes a previously set alarm.
570:                 
571:                   Remarks:
572:                     Refer to drv_tmr.h for usage information.
573:                 */
574:                 
575:                 void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
576:                 {
00000000  00000000   NOP
577:                     switch (handle)
578:                     {
579:                         default:
580:                         {
581:                             break;
00000010  00000000   NOP
582:                         }
583:                     }
584:                 }
00000014  00000000   NOP
585:                 
586:                 // *****************************************************************************
587:                 // *****************************************************************************
588:                 // Section: TMR Driver Operation Control functions
589:                 // *****************************************************************************
590:                 // *****************************************************************************
591:                 
592:                 // *****************************************************************************
593:                 /* Function:
594:                     bool DRV_TMR_Start ( DRV_HANDLE handle )
595:                 
596:                   Summary:
597:                     Starts the Timer counting.
598:                 
599:                   Description:
600:                     This function starts the Timer counting.
601:                 
602:                   Remarks:
603:                     Refer to drv_tmr.h for usage information.
604:                 */
605:                 
606:                 bool DRV_TMR_Start ( DRV_HANDLE handle )
607:                 {
00000000  00000000   NOP
608:                     switch (handle)
00000014  00000000   NOP
609:                     {
610:                         case DRV_TMR_INDEX_1:
611:                         {
612:                             return DRV_TMR1_Start();
00000034  00000000   NOP
613:                             break;
614:                         }
615:                         default:
616:                         {
617:                             break;
00000024  00000000   NOP
618:                         }
619:                     }
620:                 
621:                     return false;
00000028  00000000   NOP
622:                 }
0000003C  00000000   NOP
623:                 
624:                 // *****************************************************************************
625:                 /* Function:
626:                     void DRV_TMR_Stop ( DRV_HANDLE handle )
627:                 
628:                   Summary:
629:                     Stops the Timer from counting.
630:                 
631:                   Description:
632:                     This function stops the running Timer from counting.
633:                 
634:                   Remarks:
635:                     Refer to drv_tmr.h for usage information.
636:                 */
637:                 
638:                 void DRV_TMR_Stop ( DRV_HANDLE handle )
639:                 {
00000000  00000000   NOP
640:                     switch (handle)
00000014  00000000   NOP
641:                     {
642:                         case DRV_TMR_INDEX_1:
643:                         {
644:                             DRV_TMR1_Stop();
0000002C  00000000   NOP
645:                             break;
00000034  00000000   NOP
646:                         }
647:                         default:
648:                         {
649:                             break;
00000024  00000000   NOP
650:                         }
651:                     }
652:                 }
00000038  00000000   NOP
653:                 
654:                 // *****************************************************************************
655:                 /* Function:
656:                     uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
657:                 
658:                   Summary:
659:                     Provides the status of Timer's period elapse.
660:                 
661:                   Description:
662:                     This function returns the number of times Timer's period has elapsed since
663:                     last call to this API has made. On calling this API, the internally
664:                     maintained counter will be cleared and count will be started again from next
665:                     elapse.
666:                 
667:                   Remarks:
668:                     Refer to drv_tmr.h for usage information.
669:                 */
670:                 
671:                 uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
672:                 {
00000000  00000000   NOP
673:                     switch (handle)
674:                     {
675:                         default:
676:                         {
677:                             break;
00000010  00000000   NOP
678:                         }
679:                     }
680:                 
681:                     return 0;
00000014  00000000   NOP
682:                 }
00000018  00000000   NOP
683:                 
684:                 // *****************************************************************************
685:                 /* Function:
686:                     DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
687:                 
688:                   Summary:
689:                     This function gets the currently selected operation mode.
690:                 
691:                   Description:
692:                     This function gets the currently selected 16/32 bit operation mode.
693:                 
694:                   Remarks:
695:                     Refer to drv_tmr.h for usage information.
696:                 */
697:                 
698:                 DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
699:                 {
00000000  00000000   NOP
700:                     switch (handle)
00000014  00000000   NOP
701:                     {
702:                         case DRV_TMR_INDEX_1:
703:                         {
704:                             return DRV_TMR1_OperationModeGet();
00000034  00000000   NOP
705:                             break;
706:                         }
707:                         default:
708:                         {
709:                             break;
00000024  00000000   NOP
710:                         }
711:                     }
712:                 
713:                     return DRV_TMR_OPERATION_MODE_NONE;
00000028  00000000   NOP
714:                 }
0000003C  00000000   NOP
715:                 
716:                 // *****************************************************************************
717:                 // *****************************************************************************
718:                 // Section: TMR Driver Miscellaneous information functions
719:                 // *****************************************************************************
720:                 // *****************************************************************************
721:                 
722:                 // *****************************************************************************
723:                 /* Function:
724:                     bool DRV_TMR_ClockSet 
725:                     ( 
726:                         DRV_HANDLE handle, 
727:                         DRV_TMR_CLK_SOURCES clockSource, 
728:                         TMR_PRESCALE  preScale 
729:                     )
730:                 
731:                   Summary:
732:                     Sets the timers clock by selecting the source and prescaler.
733:                 
734:                   Description:
735:                     This function sets the timers clock by selecting the source and prescaler.
736:                 
737:                   Remarks:
738:                     Refer to drv_tmr.h for usage information.
739:                 */
740:                 
741:                 bool DRV_TMR_ClockSet 
742:                 ( 
743:                     DRV_HANDLE handle, 
744:                     DRV_TMR_CLK_SOURCES clockSource, 
745:                     TMR_PRESCALE  preScale 
746:                 )
747:                 {
00000000  00000000   NOP
748:                     switch (handle)
0000001C  00000000   NOP
749:                     {
750:                         case DRV_TMR_INDEX_1:
751:                         {
752:                             return DRV_TMR1_ClockSet(clockSource, preScale);
0000003C  00000000   NOP
753:                             break;
754:                         }
755:                         default:
756:                         {
757:                             break;
0000002C  00000000   NOP
758:                         }
759:                     }
760:                 
761:                     return false;
00000030  00000000   NOP
762:                 }
0000004C  00000000   NOP
763:                 
764:                 // *****************************************************************************
765:                 /* Function:
766:                     TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
767:                 
768:                   Summary:
769:                     This function gets the currently selected prescaler.
770:                 
771:                   Description:
772:                     This function gets the currently selected prescaler.
773:                 
774:                   Remarks:
775:                     Refer to drv_tmr.h for usage information.
776:                 */
777:                 
778:                 TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
779:                 {
00000000  00000000   NOP
780:                     switch (handle)
00000014  00000000   NOP
781:                     {
782:                         case DRV_TMR_INDEX_1:
783:                         {
784:                             return DRV_TMR1_PrescalerGet();
00000034  00000000   NOP
785:                             break;
786:                         }
787:                         default:
788:                         {
789:                             break;
00000024  00000000   NOP
790:                         }
791:                     }
792:                 
793:                     return -1;
00000028  00000000   NOP
794:                 }
0000003C  00000000   NOP
795:                 
796:                 // *****************************************************************************
797:                 /* Function:
798:                     bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
799:                 
800:                   Summary:
801:                     Enables the Gate mode.
802:                 
803:                   Description:
804:                     This function enables the Gated mode of Timer. User can measure the duration
805:                     of an external signal in this mode. Once the Gate mode is enabled, Timer
806:                     will start on the raising edge of the external signal. It will keep counting
807:                     until the next falling edge. 
808:                 
809:                   Remarks:
810:                     Refer to drv_tmr.h for usage information.
811:                 */
812:                 
813:                 bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
814:                 {
00000000  00000000   NOP
815:                     switch (handle)
816:                     {
817:                         default:
818:                         {
819:                             break;
00000010  00000000   NOP
820:                         }
821:                     }
822:                 
823:                     return false;
00000014  00000000   NOP
824:                 }
00000018  00000000   NOP
825:                 
826:                 // *****************************************************************************
827:                 /* Function:
828:                     bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
829:                 
830:                   Summary:
831:                     Enables the Gate mode.
832:                 
833:                   Description:
834:                     This function enables the Gated mode of Timer. User can measure the duration
835:                     of an external signal in this mode. Once the Gate mode is enabled, Timer
836:                     will start on the raising edge of the external signal. It will keep counting
837:                     until the next falling edge. 
838:                 
839:                   Remarks:
840:                     Refer to drv_tmr.h for usage information.
841:                 */
842:                 
843:                 bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
844:                 {
00000000  00000000   NOP
845:                     switch (handle)
846:                     {
847:                         default:
848:                         {
849:                             break;
00000010  00000000   NOP
850:                         }
851:                     }
852:                 
853:                     return false;
00000014  00000000   NOP
854:                 }
00000018  00000000   NOP
855:                 
856:                 // *****************************************************************************
857:                 /* Function:
858:                     uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
859:                 
860:                   Summary:
861:                     Provides the Timer input frequency.
862:                 
863:                   Description:
864:                     This function provides the Timer input frequency. Input frequency is the
865:                     clock to the Timer register and it is considering the prescaler divisor. 
866:                 
867:                   Remarks:
868:                     Refer to drv_tmr.h for usage information.
869:                 */
870:                 
871:                 uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
872:                 {
00000000  00000000   NOP
873:                     switch (handle)
00000014  00000000   NOP
874:                     {
875:                         case DRV_TMR_INDEX_1:
876:                         {
877:                             return DRV_TMR1_CounterFrequencyGet();
00000034  00000000   NOP
878:                             break;
879:                         }
880:                         default:
881:                         {
882:                             break;
00000024  00000000   NOP
883:                         }
884:                     }
885:                 
886:                     return 0;
00000028  00000000   NOP
887:                 }
0000003C  00000000   NOP
888:                 
889:                 // *****************************************************************************
890:                 /* Function:
891:                     DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
892:                     ( 
893:                         DRV_HANDLE handle, 
894:                         DRV_TMR_DIVIDER_RANGE* pDivRange
895:                     )
896:                 
897:                   Summary:
898:                     Returns the Timer divider values.
899:                 
900:                   Description:
901:                     This function provides the Timer operating mode and divider range.
902:                 
903:                   Remarks:
904:                     Refer to drv_tmr.h for usage information.
905:                 */
906:                 
907:                 DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
908:                 ( 
909:                     DRV_HANDLE handle,
910:                     DRV_TMR_DIVIDER_RANGE* pDivRange
911:                 )
912:                 {
00000000  00000000   NOP
913:                     switch (handle)
00000018  00000000   NOP
914:                     {
915:                         case DRV_TMR_INDEX_1:
916:                         {
917:                             return DRV_TMR1_DividerRangeGet(pDivRange);
00000038  00000000   NOP
918:                             break;
919:                         }
920:                         default:
921:                         {
922:                             break;
00000028  00000000   NOP
923:                         }
924:                     }
925:                 
926:                     return DRV_TMR_OPERATION_MODE_NONE;
0000002C  00000000   NOP
927:                 }
00000044  00000000   NOP
928:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/system_config/default/framework/driver/tmr/drv_tmr_static.h
1:                   /*******************************************************************************
2:                     Timer Driver Interface Declarations for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr_static.h
9:                   
10:                    Summary:
11:                      Timer driver interface declarations for the static single instance driver.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer
15:                      modules on Microchip microcontrollers. This file defines the interface
16:                      Declarations for the TMR driver.
17:                      
18:                    Remarks:
19:                      Static interfaces incorporate the driver instance number within the names
20:                      of the routines, eliminating the need for an object ID or object handle.
21:                      
22:                      Static single-open interfaces also eliminate the need for the open handle.
23:                  *******************************************************************************/
24:                  
25:                  //DOM-IGNORE-BEGIN
26:                  /*******************************************************************************
27:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
28:                  
29:                  Microchip licenses to you the right to use, modify, copy and distribute
30:                  Software only when embedded on a Microchip microcontroller or digital signal
31:                  controller that is integrated into your product or third party product
32:                  (pursuant to the sublicense terms in the accompanying license agreement).
33:                  
34:                  You should refer to the license agreement accompanying this Software for
35:                  additional information regarding your rights and obligations.
36:                  
37:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
38:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
39:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTOCULAR PURPOSE.
40:                  IN NO EVENT SHALL MOCROCHIP OR ITS LOCENSORS BE LIABLE OR OBLIGATED UNDER
41:                  CONTRACT, NEGLIGENCE, STROCT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
42:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
43:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
44:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVOCES, OR ANY CLAIMS BY THIRD PARTIES
46:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                  *******************************************************************************/
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _DRV_TMR_STATIC_H
51:                  #define _DRV_TMR_STATIC_H
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Headers
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  #include <stdint.h>
58:                  #include "driver/tmr/drv_tmr.h"
59:                  #include "peripheral/tmr/plib_tmr.h"
60:                  #include "peripheral/int/plib_int.h"
61:                  
62:                  // maximum divider value for 32 bit operation mode
63:                  #define     DRV_TIMER_DIVIDER_MAX_32BIT     0xffffffff
64:                  
65:                  // minimum divider value for 32 bit operation mode
66:                  #define     DRV_TIMER_DIVIDER_MIN_32BIT     0x2
67:                  
68:                  // maximum divider value for 16 bit operation mode
69:                  #define     DRV_TIMER_DIVIDER_MAX_16BIT     0x10000
70:                  
71:                  // minimum divider value for 16 bit operation mode
72:                  #define     DRV_TIMER_DIVIDER_MIN_16BIT     0x2
73:                  
74:                  
75:                  // *****************************************************************************
76:                  // *****************************************************************************
77:                  // Section: Interface Headers for Instance 1 for the static driver
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  
81:                  void DRV_TMR1_Initialize(void);
82:                  bool DRV_TMR1_Start(void);
83:                  void DRV_TMR1_Stop(void);
84:                  static inline void DRV_TMR1_DeInitialize(void)
85:                  {
00000000  00000000   NOP
86:                  	DRV_TMR1_Stop();
00000010  00000000   NOP
87:                  }
00000018  00000000   NOP
88:                  static inline SYS_STATUS DRV_TMR1_Status(void)
89:                  {
00000000  00000000   NOP
90:                  	/* Return the status as ready always */
91:                      return SYS_STATUS_READY; 
0000000C  00000000   NOP
92:                  }
00000010  00000000   NOP
93:                  static inline void DRV_TMR1_Open(void) {}
94:                  DRV_TMR_CLIENT_STATUS DRV_TMR1_ClientStatus ( void );
95:                  static inline DRV_TMR_OPERATION_MODE DRV_TMR1_OperationModeGet(void)
96:                  {
00000000  00000000   NOP
97:                      return DRV_TMR_OPERATION_MODE_16_BIT;
0000000C  00000000   NOP
98:                  }
00000010  00000000   NOP
99:                  static inline void DRV_TMR1_Close(void) 
100:                 {
00000000  00000000   NOP
101:                     DRV_TMR1_Stop();
00000010  00000000   NOP
102:                 }
00000018  00000000   NOP
103:                 bool DRV_TMR1_ClockSet
104:                 (
105:                     DRV_TMR_CLK_SOURCES clockSource, 
106:                     TMR_PRESCALE  prescale 
107:                 );
108:                 void DRV_TMR1_CounterValueSet(uint32_t value);
109:                 uint32_t DRV_TMR1_CounterValueGet(void);
110:                 void DRV_TMR1_CounterClear(void);
111:                 TMR_PRESCALE DRV_TMR1_PrescalerGet(void);
112:                 void DRV_TMR1_PeriodValueSet(uint32_t value);
113:                 uint32_t DRV_TMR1_PeriodValueGet(void);
114:                 void DRV_TMR1_StopInIdleDisable(void);
115:                 void DRV_TMR1_StopInIdleEnable(void);
116:                 static inline void DRV_TMR1_Tasks(void) {}
00000000  00000000   NOP
0000000C  00000000   NOP
117:                 uint32_t DRV_TMR1_CounterFrequencyGet(void);
118:                 DRV_TMR_OPERATION_MODE DRV_TMR1_DividerRangeGet
119:                 (
120:                     DRV_TMR_DIVIDER_RANGE * pDivRange
121:                 );
122:                 #endif // #ifndef _DRV_TMR_STATIC_H
123:                 
124:                 /*******************************************************************************
125:                  End of File
126:                 */
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/menugen.c  -----------------
1:                   /* 
2:                    * File:   MenuGen.c
3:                    * Author: dierickenbach
4:                    *
5:                    * Created on 4. septembre 2020, 13:24
6:                    */
7:                   
8:                   //inlcudes
9:                   #include "MenuGen.h"
10:                  #include "Mc32gest_RS232.h"
11:                  #include "BME280.h"
12:                  #include "ESP8266.h"
13:                  #include "system/common/sys_common.h"
14:                  #include "app.h"
15:                  #include "system_definitions.h"
16:                  #include "Mc32Delays.h"
17:                  #include <stdio.h>
18:                  #include <stdlib.h>
19:                  #include <string.h>
20:                  #include "Mc32NVMUtil.h"
21:                  
22:                  /*******************************************************************************
23:                  * Auteur : Diego Rickenbach                                                    *                     
24:                  * Nom de la fonction :     GestMenu                                            *                                    
25:                  * Entre :      rien                                                           *                                                                      
26:                  * Sortie :      rien                                                           *
27:                  * Desription :  Cette fonction permet de grer les tats du menu               *                                                    
28:                  * Remarques:    Voir le prototype dans MenuGen.h.                              *
29:                  *******************************************************************************/
30:                  void GestMenu (void)
31:                  {
9D000000  27BDFB50   ADDIU SP, SP, -1200
9D000004  AFBF04AC   SW RA, 1196(SP)
9D000008  AFBE04A8   SW FP, 1192(SP)
9D00000C  03A0F021   ADDU FP, SP, ZERO
32:                      switch (MenuStatus)
9D000010  8F828034   LW V0, -32716(GP)
9D000014  2C43001A   SLTIU V1, V0, 26
9D000018  10600707   BEQ V1, ZERO, .LBE34
9D00001C  00000000   NOP
9D000020  00021880   SLL V1, V0, 2
9D000024  3C029D00   LUI V0, -25344
9D000028  2442003C   ADDIU V0, V0, 60
9D00002C  00621021   ADDU V0, V1, V0
9D000030  8C420000   LW V0, 0(V0)
9D000034  00400008   JR V0
9D000038  00000000   NOP
33:                      {
34:                          case Enter_Menu_Set:
35:                          {
36:                              int8_t sendMess[] = "\r\nVeuillez appuyer sur la touche \"q\" pour acceder au menu\r\n\r\n";
9D0000A4  3C029D00   LUI V0, -25344
9D0000A8  27C403A0   ADDIU A0, FP, 928
9D0000AC  24433A20   ADDIU V1, V0, 14880
9D0000B0  2402003E   ADDIU V0, ZERO, 62
9D0000B4  00602821   ADDU A1, V1, ZERO
9D0000B8  00403021   ADDU A2, V0, ZERO
9D0000BC  0F40272F   JAL .LFE1156, memcpy
9D0000C0  00000000   NOP
37:                              SendUSBMessage(sendMess, strlen((char*)sendMess));
9D0000C4  27C203A0   ADDIU V0, FP, 928
9D0000C8  00402021   ADDU A0, V0, ZERO
9D0000CC  0F402789   JAL strlen
9D0000D0  00000000   NOP
9D0000D4  304200FF   ANDI V0, V0, 255
9D0000D8  27C303A0   ADDIU V1, FP, 928
9D0000DC  00602021   ADDU A0, V1, ZERO
9D0000E0  00402821   ADDU A1, V0, ZERO
9D0000E4  0F403051   JAL SendUSBMessage
9D0000E8  00000000   NOP
38:                              MenuStatus = Enter_Menu_Get;
9D0000EC  24020001   ADDIU V0, ZERO, 1
9D0000F0  AF828034   SW V0, -32716(GP)
39:                              break;
9D0000F4  00000000   NOP
9D0000F8  0B40070F   J 0x9D001C3C
9D0000FC  00000000   NOP
40:                          }
41:                          case Enter_Menu_Get:
42:                          {
43:                              static uint16_t count5s = 0;
44:                              int8_t getMess[5] = {0};
9D000100  AFC00014   SW ZERO, 20(FP)
9D000104  A3C00018   SB ZERO, 24(FP)
45:                              
46:                              if(count5s >= 50)
9D000108  97828018   LHU V0, -32744(GP)
9D00010C  2C420032   SLTIU V0, V0, 50
9D000110  14400005   BNE V0, ZERO, 0x9D000128
9D000114  00000000   NOP
47:                              {
48:                                  count5s = 0;
9D000118  A7808018   SH ZERO, -32744(GP)
49:                                  MenuStatus = Enter_Menu_Set;
9D00011C  AF808034   SW ZERO, -32716(GP)
9D000120  0B400062   J 0x9D000188
9D000124  00000000   NOP
50:                              }
51:                              else
52:                              {
53:                                  count5s++;
9D000128  97828018   LHU V0, -32744(GP)
9D00012C  24420001   ADDIU V0, V0, 1
9D000130  3042FFFF   ANDI V0, V0, -1
9D000134  A7828018   SH V0, -32744(GP)
54:                                  
55:                                  if(GetUSBMessage(getMess, "q") == OK)
9D000138  27C20014   ADDIU V0, FP, 20
9D00013C  00402021   ADDU A0, V0, ZERO
9D000140  3C029D00   LUI V0, -25344
9D000144  244538FC   ADDIU A1, V0, 14588
9D000148  0F402221   JAL GetUSBMessage
9D00014C  00000000   NOP
9D000150  1440000D   BNE V0, ZERO, 0x9D000188
9D000154  00000000   NOP
56:                                  {
57:                                      LED_G_Off();
9D000158  00002021   ADDU A0, ZERO, ZERO
9D00015C  24050001   ADDIU A1, ZERO, 1
9D000160  2406000D   ADDIU A2, ZERO, 13
9D000164  0F4037B8   JAL PLIB_PORTS_PinClear
9D000168  00000000   NOP
58:                                      LED_B_On();
9D00016C  00002021   ADDU A0, ZERO, ZERO
9D000170  24050001   ADDIU A1, ZERO, 1
9D000174  2406000E   ADDIU A2, ZERO, 14
9D000178  0F4037AE   JAL PLIB_PORTS_PinSet
9D00017C  00000000   NOP
59:                              
60:                                      MenuStatus = Menu_Set;
9D000180  24020003   ADDIU V0, ZERO, 3
9D000184  AF828034   SW V0, -32716(GP)
61:                                  }
62:                              } 
63:                              break;
9D000188  00000000   NOP
9D00018C  0B40070F   J 0x9D001C3C
9D000190  00000000   NOP
64:                          }
65:                          case QuitSave_Menu:
66:                          {
67:                              int8_t sendBye[] = "Merci et a bientot!\r\n";
9D000194  3C029D00   LUI V0, -25344
9D000198  8C473A60   LW A3, 14944(V0)
9D00019C  24433A60   ADDIU V1, V0, 14944
9D0001A0  8C660004   LW A2, 4(V1)
9D0001A4  24433A60   ADDIU V1, V0, 14944
9D0001A8  8C650008   LW A1, 8(V1)
9D0001AC  24433A60   ADDIU V1, V0, 14944
9D0001B0  8C64000C   LW A0, 12(V1)
9D0001B4  24433A60   ADDIU V1, V0, 14944
9D0001B8  8C630010   LW V1, 16(V1)
9D0001BC  AFC7001C   SW A3, 28(FP)
9D0001C0  AFC60020   SW A2, 32(FP)
9D0001C4  AFC50024   SW A1, 36(FP)
9D0001C8  AFC40028   SW A0, 40(FP)
9D0001CC  AFC3002C   SW V1, 44(FP)
9D0001D0  24423A60   ADDIU V0, V0, 14944
9D0001D4  94420014   LHU V0, 20(V0)
9D0001D8  A7C20030   SH V0, 48(FP)
68:                              SendUSBMessage(sendBye, strlen((char*)sendBye));
9D0001DC  27C2001C   ADDIU V0, FP, 28
9D0001E0  00402021   ADDU A0, V0, ZERO
9D0001E4  0F402789   JAL strlen
9D0001E8  00000000   NOP
9D0001EC  304200FF   ANDI V0, V0, 255
9D0001F0  27C3001C   ADDIU V1, FP, 28
9D0001F4  00602021   ADDU A0, V1, ZERO
9D0001F8  00402821   ADDU A1, V0, ZERO
9D0001FC  0F403051   JAL SendUSBMessage
9D000200  00000000   NOP
69:                              
70:                              BME280.Magic = 0x1234;
9D000204  3C02A000   LUI V0, -24576
9D000208  24420270   ADDIU V0, V0, 624
9D00020C  24031234   ADDIU V1, ZERO, 4660
9D000210  AC430018   SW V1, 24(V0)
71:                              Wifi.Magic = 0x1234;
9D000214  3C02A000   LUI V0, -24576
9D000218  244203BC   ADDIU V0, V0, 956
9D00021C  24031234   ADDIU V1, ZERO, 4660
9D000220  AC4300DC   SW V1, 220(V0)
72:                              ESP8266.Magic = 0x1234;     
9D000224  3C02A000   LUI V0, -24576
9D000228  24420244   ADDIU V0, V0, 580
9D00022C  24031234   ADDIU V1, ZERO, 4660
9D000230  AC430028   SW V1, 40(V0)
73:                                      
74:                              memcpy(&Struct_save.BME280_save, &BME280, sizeof(S_BME280));
9D000234  3C02A000   LUI V0, -24576
9D000238  3C03A000   LUI V1, -24576
9D00023C  8C640270   LW A0, 624(V1)
9D000240  24650270   ADDIU A1, V1, 624
9D000244  8CAA0004   LW T2, 4(A1)
9D000248  24650270   ADDIU A1, V1, 624
9D00024C  8CA90008   LW T1, 8(A1)
9D000250  24650270   ADDIU A1, V1, 624
9D000254  8CA8000C   LW T0, 12(A1)
9D000258  24650270   ADDIU A1, V1, 624
9D00025C  8CA70010   LW A3, 16(A1)
9D000260  24650270   ADDIU A1, V1, 624
9D000264  8CA60014   LW A2, 20(A1)
9D000268  24650270   ADDIU A1, V1, 624
9D00026C  8CA50018   LW A1, 24(A1)
9D000270  24630270   ADDIU V1, V1, 624
9D000274  8C63001C   LW V1, 28(V1)
9D000278  AC440290   SW A0, 656(V0)
9D00027C  24440290   ADDIU A0, V0, 656
9D000280  AC8A0004   SW T2, 4(A0)
9D000284  24440290   ADDIU A0, V0, 656
9D000288  AC890008   SW T1, 8(A0)
9D00028C  24440290   ADDIU A0, V0, 656
9D000290  AC88000C   SW T0, 12(A0)
9D000294  24440290   ADDIU A0, V0, 656
9D000298  AC870010   SW A3, 16(A0)
9D00029C  24440290   ADDIU A0, V0, 656
9D0002A0  AC860014   SW A2, 20(A0)
9D0002A4  24440290   ADDIU A0, V0, 656
9D0002A8  AC850018   SW A1, 24(A0)
9D0002AC  24420290   ADDIU V0, V0, 656
9D0002B0  AC43001C   SW V1, 28(V0)
75:                              memcpy(&Struct_save.ESP8266_save, &ESP8266, sizeof(S_ESP8266));
9D0002B4  3C02A000   LUI V0, -24576
9D0002B8  24430290   ADDIU V1, V0, 656
9D0002BC  3C02A000   LUI V0, -24576
9D0002C0  24640020   ADDIU A0, V1, 32
9D0002C4  24430244   ADDIU V1, V0, 580
9D0002C8  2402002C   ADDIU V0, ZERO, 44
9D0002CC  00602821   ADDU A1, V1, ZERO
9D0002D0  00403021   ADDU A2, V0, ZERO
9D0002D4  0F40272F   JAL .LFE1156, memcpy
9D0002D8  00000000   NOP
76:                              memcpy(&Struct_save.Wifi_save, &Wifi, sizeof(S_WIFI));
9D0002DC  3C02A000   LUI V0, -24576
9D0002E0  24430290   ADDIU V1, V0, 656
9D0002E4  3C02A000   LUI V0, -24576
9D0002E8  2464004C   ADDIU A0, V1, 76
9D0002EC  244303BC   ADDIU V1, V0, 956
9D0002F0  240200E0   ADDIU V0, ZERO, 224
9D0002F4  00602821   ADDU A1, V1, ZERO
9D0002F8  00403021   ADDU A2, V0, ZERO
9D0002FC  0F40272F   JAL .LFE1156, memcpy
9D000300  00000000   NOP
77:                      
78:                              NVM_WriteBlock((uint32_t *)(&Struct_save),sizeof(S_SAVE));
9D000304  3C02A000   LUI V0, -24576
9D000308  24440290   ADDIU A0, V0, 656
9D00030C  2405012C   ADDIU A1, ZERO, 300
9D000310  0F402CAB   JAL NVM_WriteBlock
9D000314  00000000   NOP
79:                              
80:                              LED_G_On();
9D000318  00002021   ADDU A0, ZERO, ZERO
9D00031C  24050001   ADDIU A1, ZERO, 1
9D000320  2406000D   ADDIU A2, ZERO, 13
9D000324  0F4037AE   JAL PLIB_PORTS_PinSet
9D000328  00000000   NOP
81:                              BME280_Init();
9D00032C  0F402675   JAL BME280_Init
9D000330  00000000   NOP
82:                              ESP8266_Init();
9D000334  0F401A89   JAL ESP8266_Init
9D000338  00000000   NOP
83:                              LED_G_Off();
9D00033C  00002021   ADDU A0, ZERO, ZERO
9D000340  24050001   ADDIU A1, ZERO, 1
9D000344  2406000D   ADDIU A2, ZERO, 13
9D000348  0F4037B8   JAL PLIB_PORTS_PinClear
9D00034C  00000000   NOP
84:                              
85:                              LED_B_Off();
9D000350  00002021   ADDU A0, ZERO, ZERO
9D000354  24050001   ADDIU A1, ZERO, 1
9D000358  2406000E   ADDIU A2, ZERO, 14
9D00035C  0F4037B8   JAL PLIB_PORTS_PinClear
9D000360  00000000   NOP
86:                              
87:                              MenuStatus = Enter_Menu_Set;
9D000364  AF808034   SW ZERO, -32716(GP)
88:                              
89:                              APP_UpdateState(APP_STATE_WAIT);
9D000368  24040001   ADDIU A0, ZERO, 1
9D00036C  0F403724   JAL APP_UpdateState
9D000370  00000000   NOP
90:                              break;
9D000374  00000000   NOP
9D000378  0B40070F   J 0x9D001C3C
9D00037C  00000000   NOP
91:                          }
92:                          case Menu_Set: 
93:                          {
94:                              int8_t Line1[] = "\r\n\r\nQue voulez-vous faire?\r\n\r\n";
9D000380  3C029D00   LUI V0, -25344
9D000384  8C493A78   LW T1, 14968(V0)
9D000388  24433A78   ADDIU V1, V0, 14968
9D00038C  8C680004   LW T0, 4(V1)
9D000390  24433A78   ADDIU V1, V0, 14968
9D000394  8C670008   LW A3, 8(V1)
9D000398  24433A78   ADDIU V1, V0, 14968
9D00039C  8C66000C   LW A2, 12(V1)
9D0003A0  24433A78   ADDIU V1, V0, 14968
9D0003A4  8C650010   LW A1, 16(V1)
9D0003A8  24433A78   ADDIU V1, V0, 14968
9D0003AC  8C640014   LW A0, 20(V1)
9D0003B0  24433A78   ADDIU V1, V0, 14968
9D0003B4  8C630018   LW V1, 24(V1)
9D0003B8  AFC90034   SW T1, 52(FP)
9D0003BC  AFC80038   SW T0, 56(FP)
9D0003C0  AFC7003C   SW A3, 60(FP)
9D0003C4  AFC60040   SW A2, 64(FP)
9D0003C8  AFC50044   SW A1, 68(FP)
9D0003CC  AFC40048   SW A0, 72(FP)
9D0003D0  AFC3004C   SW V1, 76(FP)
9D0003D4  24423A78   ADDIU V0, V0, 14968
9D0003D8  9443001C   LHU V1, 28(V0)
9D0003DC  A7C30050   SH V1, 80(FP)
9D0003E0  9042001E   LBU V0, 30(V0)
9D0003E4  A3C20052   SB V0, 82(FP)
95:                              int8_t Line2[] = "1: Modifier les regalges Wifi (SSID ou PWD)\r\n";
9D0003E8  3C029D00   LUI V0, -25344
9D0003EC  27C40404   ADDIU A0, FP, 1028
9D0003F0  24433A98   ADDIU V1, V0, 15000
9D0003F4  2402002E   ADDIU V0, ZERO, 46
9D0003F8  00602821   ADDU A1, V1, ZERO
9D0003FC  00403021   ADDU A2, V0, ZERO
9D000400  0F40272F   JAL .LFE1156, memcpy
9D000404  00000000   NOP
96:                              int8_t Line3[] = "2: Mofifier les reglages Domoticz(IP, Port, Index)\r\n";
9D000408  3C029D00   LUI V0, -25344
9D00040C  27C403A0   ADDIU A0, FP, 928
9D000410  24433AC8   ADDIU V1, V0, 15048
9D000414  24020035   ADDIU V0, ZERO, 53
9D000418  00602821   ADDU A1, V1, ZERO
9D00041C  00403021   ADDU A2, V0, ZERO
9D000420  0F40272F   JAL .LFE1156, memcpy
9D000424  00000000   NOP
97:                              int8_t Line4[] = "3: Modifier le temps entre chaques mesures\r\n";
9D000428  3C029D00   LUI V0, -25344
9D00042C  27C40434   ADDIU A0, FP, 1076
9D000430  24433B00   ADDIU V1, V0, 15104
9D000434  2402002D   ADDIU V0, ZERO, 45
9D000438  00602821   ADDU A1, V1, ZERO
9D00043C  00403021   ADDU A2, V0, ZERO
9D000440  0F40272F   JAL .LFE1156, memcpy
9D000444  00000000   NOP
98:                              int8_t Line5[] = "4: Afficher les mesures du BME280\r\n";
9D000448  3C029D00   LUI V0, -25344
9D00044C  27C40464   ADDIU A0, FP, 1124
9D000450  24433B30   ADDIU V1, V0, 15152
9D000454  24020024   ADDIU V0, ZERO, 36
9D000458  00602821   ADDU A1, V1, ZERO
9D00045C  00403021   ADDU A2, V0, ZERO
9D000460  0F40272F   JAL .LFE1156, memcpy
9D000464  00000000   NOP
99:                              int8_t Line6[] = "5: Modifier l'altitude\r\n";
9D000468  3C029D00   LUI V0, -25344
9D00046C  8C483B54   LW T0, 15188(V0)
9D000470  24433B54   ADDIU V1, V0, 15188
9D000474  8C670004   LW A3, 4(V1)
9D000478  24433B54   ADDIU V1, V0, 15188
9D00047C  8C660008   LW A2, 8(V1)
9D000480  24433B54   ADDIU V1, V0, 15188
9D000484  8C65000C   LW A1, 12(V1)
9D000488  24433B54   ADDIU V1, V0, 15188
9D00048C  8C640010   LW A0, 16(V1)
9D000490  24433B54   ADDIU V1, V0, 15188
9D000494  8C630014   LW V1, 20(V1)
9D000498  AFC80054   SW T0, 84(FP)
9D00049C  AFC70058   SW A3, 88(FP)
9D0004A0  AFC6005C   SW A2, 92(FP)
9D0004A4  AFC50060   SW A1, 96(FP)
9D0004A8  AFC40064   SW A0, 100(FP)
9D0004AC  AFC30068   SW V1, 104(FP)
9D0004B0  24423B54   ADDIU V0, V0, 15188
9D0004B4  90420018   LBU V0, 24(V0)
9D0004B8  A3C2006C   SB V0, 108(FP)
100:                             int8_t Line7[] = "\"q\": Quitter et sauvegarder\r\n\r\n";
9D0004BC  3C029D00   LUI V0, -25344
9D0004C0  8C493B70   LW T1, 15216(V0)
9D0004C4  24433B70   ADDIU V1, V0, 15216
9D0004C8  8C680004   LW T0, 4(V1)
9D0004CC  24433B70   ADDIU V1, V0, 15216
9D0004D0  8C670008   LW A3, 8(V1)
9D0004D4  24433B70   ADDIU V1, V0, 15216
9D0004D8  8C66000C   LW A2, 12(V1)
9D0004DC  24433B70   ADDIU V1, V0, 15216
9D0004E0  8C650010   LW A1, 16(V1)
9D0004E4  24433B70   ADDIU V1, V0, 15216
9D0004E8  8C640014   LW A0, 20(V1)
9D0004EC  24433B70   ADDIU V1, V0, 15216
9D0004F0  8C630018   LW V1, 24(V1)
9D0004F4  24423B70   ADDIU V0, V0, 15216
9D0004F8  8C42001C   LW V0, 28(V0)
9D0004FC  AFC90488   SW T1, 1160(FP)
9D000500  AFC8048C   SW T0, 1164(FP)
9D000504  AFC70490   SW A3, 1168(FP)
9D000508  AFC60494   SW A2, 1172(FP)
9D00050C  AFC50498   SW A1, 1176(FP)
9D000510  AFC4049C   SW A0, 1180(FP)
9D000514  AFC304A0   SW V1, 1184(FP)
9D000518  AFC204A4   SW V0, 1188(FP)
101:                 
102:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D00051C  27C20034   ADDIU V0, FP, 52
9D000520  00402021   ADDU A0, V0, ZERO
9D000524  0F402789   JAL strlen
9D000528  00000000   NOP
9D00052C  304200FF   ANDI V0, V0, 255
9D000530  27C30034   ADDIU V1, FP, 52
9D000534  00602021   ADDU A0, V1, ZERO
9D000538  00402821   ADDU A1, V0, ZERO
9D00053C  0F403051   JAL SendUSBMessage
9D000540  00000000   NOP
103:                             SendUSBMessage(Line2, strlen((char*)Line2));
9D000544  27C20404   ADDIU V0, FP, 1028
9D000548  00402021   ADDU A0, V0, ZERO
9D00054C  0F402789   JAL strlen
9D000550  00000000   NOP
9D000554  304200FF   ANDI V0, V0, 255
9D000558  27C30404   ADDIU V1, FP, 1028
9D00055C  00602021   ADDU A0, V1, ZERO
9D000560  00402821   ADDU A1, V0, ZERO
9D000564  0F403051   JAL SendUSBMessage
9D000568  00000000   NOP
104:                             SendUSBMessage(Line3, strlen((char*)Line3));
9D00056C  27C203A0   ADDIU V0, FP, 928
9D000570  00402021   ADDU A0, V0, ZERO
9D000574  0F402789   JAL strlen
9D000578  00000000   NOP
9D00057C  304200FF   ANDI V0, V0, 255
9D000580  27C303A0   ADDIU V1, FP, 928
9D000584  00602021   ADDU A0, V1, ZERO
9D000588  00402821   ADDU A1, V0, ZERO
9D00058C  0F403051   JAL SendUSBMessage
9D000590  00000000   NOP
105:                             SendUSBMessage(Line4, strlen((char*)Line4));
9D000594  27C20434   ADDIU V0, FP, 1076
9D000598  00402021   ADDU A0, V0, ZERO
9D00059C  0F402789   JAL strlen
9D0005A0  00000000   NOP
9D0005A4  304200FF   ANDI V0, V0, 255
9D0005A8  27C30434   ADDIU V1, FP, 1076
9D0005AC  00602021   ADDU A0, V1, ZERO
9D0005B0  00402821   ADDU A1, V0, ZERO
9D0005B4  0F403051   JAL SendUSBMessage
9D0005B8  00000000   NOP
106:                             SendUSBMessage(Line5, strlen((char*)Line5));
9D0005BC  27C20464   ADDIU V0, FP, 1124
9D0005C0  00402021   ADDU A0, V0, ZERO
9D0005C4  0F402789   JAL strlen
9D0005C8  00000000   NOP
9D0005CC  304200FF   ANDI V0, V0, 255
9D0005D0  27C30464   ADDIU V1, FP, 1124
9D0005D4  00602021   ADDU A0, V1, ZERO
9D0005D8  00402821   ADDU A1, V0, ZERO
9D0005DC  0F403051   JAL SendUSBMessage
9D0005E0  00000000   NOP
107:                             SendUSBMessage(Line6, strlen((char*)Line6));
9D0005E4  27C20054   ADDIU V0, FP, 84
9D0005E8  00402021   ADDU A0, V0, ZERO
9D0005EC  0F402789   JAL strlen
9D0005F0  00000000   NOP
9D0005F4  304200FF   ANDI V0, V0, 255
9D0005F8  27C30054   ADDIU V1, FP, 84
9D0005FC  00602021   ADDU A0, V1, ZERO
9D000600  00402821   ADDU A1, V0, ZERO
9D000604  0F403051   JAL SendUSBMessage
9D000608  00000000   NOP
108:                             SendUSBMessage(Line7, strlen((char*)Line7));
9D00060C  27C20488   ADDIU V0, FP, 1160
9D000610  00402021   ADDU A0, V0, ZERO
9D000614  0F402789   JAL strlen
9D000618  00000000   NOP
9D00061C  304200FF   ANDI V0, V0, 255
9D000620  27C30488   ADDIU V1, FP, 1160
9D000624  00602021   ADDU A0, V1, ZERO
9D000628  00402821   ADDU A1, V0, ZERO
9D00062C  0F403051   JAL SendUSBMessage
9D000630  00000000   NOP
109:                             
110:                             MenuStatus = Menu_Get;
9D000634  24020004   ADDIU V0, ZERO, 4
9D000638  AF828034   SW V0, -32716(GP)
111:                             break;
9D00063C  00000000   NOP
9D000640  0B40070F   J 0x9D001C3C
9D000644  00000000   NOP
112:                         }
113:                         case Menu_Get: 
114:                         {
115:                             int8_t menuResponse[5];
116:                             uint8_t status = GetUSBMessage(menuResponse,"1");
9D000648  27C20070   ADDIU V0, FP, 112
9D00064C  00402021   ADDU A0, V0, ZERO
9D000650  3C029D00   LUI V0, -25344
9D000654  24453900   ADDIU A1, V0, 14592
9D000658  0F402221   JAL GetUSBMessage
9D00065C  00000000   NOP
9D000660  A3C20010   SB V0, 16(FP)
117:                             if(status == OK){
9D000664  93C20010   LBU V0, 16(FP)
9D000668  14400005   BNE V0, ZERO, 0x9D000680
9D00066C  00000000   NOP
118:                                 MenuStatus = Wifi_Set;
9D000670  24020005   ADDIU V0, ZERO, 5
9D000674  AF828034   SW V0, -32716(GP)
119:                                 break;
9D000678  0B40070F   J 0x9D001C3C
9D00067C  00000000   NOP
120:                             }
121:                             status = GetUSBMessage(menuResponse,"2");
9D000680  27C20070   ADDIU V0, FP, 112
9D000684  00402021   ADDU A0, V0, ZERO
9D000688  3C029D00   LUI V0, -25344
9D00068C  24453904   ADDIU A1, V0, 14596
9D000690  0F402221   JAL GetUSBMessage
9D000694  00000000   NOP
9D000698  A3C20010   SB V0, 16(FP)
122:                             if(status == OK){
9D00069C  93C20010   LBU V0, 16(FP)
9D0006A0  14400005   BNE V0, ZERO, 0x9D0006B8
9D0006A4  00000000   NOP
123:                                 MenuStatus = Domoticz_Set;
9D0006A8  2402000C   ADDIU V0, ZERO, 12
9D0006AC  AF828034   SW V0, -32716(GP)
124:                                 break;
9D0006B0  0B40070F   J 0x9D001C3C
9D0006B4  00000000   NOP
125:                             }
126:                             status = GetUSBMessage(menuResponse,"3");
9D0006B8  27C20070   ADDIU V0, FP, 112
9D0006BC  00402021   ADDU A0, V0, ZERO
9D0006C0  3C029D00   LUI V0, -25344
9D0006C4  24453908   ADDIU A1, V0, 14600
9D0006C8  0F402221   JAL GetUSBMessage
9D0006CC  00000000   NOP
9D0006D0  A3C20010   SB V0, 16(FP)
127:                             if(status == OK){
9D0006D4  93C20010   LBU V0, 16(FP)
9D0006D8  14400005   BNE V0, ZERO, 0x9D0006F0
9D0006DC  00000000   NOP
128:                                 MenuStatus = Interval_Set;
9D0006E0  24020015   ADDIU V0, ZERO, 21
9D0006E4  AF828034   SW V0, -32716(GP)
129:                                 break;
9D0006E8  0B40070F   J 0x9D001C3C
9D0006EC  00000000   NOP
130:                             }
131:                             status = GetUSBMessage(menuResponse,"4");
9D0006F0  27C20070   ADDIU V0, FP, 112
9D0006F4  00402021   ADDU A0, V0, ZERO
9D0006F8  3C029D00   LUI V0, -25344
9D0006FC  2445390C   ADDIU A1, V0, 14604
9D000700  0F402221   JAL GetUSBMessage
9D000704  00000000   NOP
9D000708  A3C20010   SB V0, 16(FP)
132:                             if(status == OK){
9D00070C  93C20010   LBU V0, 16(FP)
9D000710  14400005   BNE V0, ZERO, 0x9D000728
9D000714  00000000   NOP
133:                                 MenuStatus = Measure;
9D000718  24020017   ADDIU V0, ZERO, 23
9D00071C  AF828034   SW V0, -32716(GP)
134:                                 break;
9D000720  0B40070F   J 0x9D001C3C
9D000724  00000000   NOP
135:                             }
136:                             status = GetUSBMessage(menuResponse,"5");
9D000728  27C20070   ADDIU V0, FP, 112
9D00072C  00402021   ADDU A0, V0, ZERO
9D000730  3C029D00   LUI V0, -25344
9D000734  24453910   ADDIU A1, V0, 14608
9D000738  0F402221   JAL GetUSBMessage
9D00073C  00000000   NOP
9D000740  A3C20010   SB V0, 16(FP)
137:                             if(status == OK){
9D000744  93C20010   LBU V0, 16(FP)
9D000748  14400005   BNE V0, ZERO, 0x9D000760
9D00074C  00000000   NOP
138:                                 MenuStatus = Altitude_Set;
9D000750  24020018   ADDIU V0, ZERO, 24
9D000754  AF828034   SW V0, -32716(GP)
139:                                 break;
9D000758  0B40070F   J 0x9D001C3C
9D00075C  00000000   NOP
140:                             }
141:                             status = GetUSBMessage(menuResponse,"q");
9D000760  27C20070   ADDIU V0, FP, 112
9D000764  00402021   ADDU A0, V0, ZERO
9D000768  3C029D00   LUI V0, -25344
9D00076C  244538FC   ADDIU A1, V0, 14588
9D000770  0F402221   JAL GetUSBMessage
9D000774  00000000   NOP
9D000778  A3C20010   SB V0, 16(FP)
142:                             if(status == OK){
9D00077C  93C20010   LBU V0, 16(FP)
9D000780  14400005   BNE V0, ZERO, 0x9D000798
9D000784  00000000   NOP
143:                                 MenuStatus = QuitSave_Menu;
9D000788  24020002   ADDIU V0, ZERO, 2
9D00078C  AF828034   SW V0, -32716(GP)
144:                                 break;
9D000790  0B40070F   J 0x9D001C3C
9D000794  00000000   NOP
145:                             }
146:                             break;
9D000798  00000000   NOP
9D00079C  0B40070F   J 0x9D001C3C
9D0007A0  00000000   NOP
147:                         }
148:                         case Wifi_Set: 
149:                         {
150:                             int8_t Line1[] = "\r\nQue voulez-vous faire?\r\n\r\n";
9D0007A4  3C029D00   LUI V0, -25344
9D0007A8  8C493B90   LW T1, 15248(V0)
9D0007AC  24433B90   ADDIU V1, V0, 15248
9D0007B0  8C680004   LW T0, 4(V1)
9D0007B4  24433B90   ADDIU V1, V0, 15248
9D0007B8  8C670008   LW A3, 8(V1)
9D0007BC  24433B90   ADDIU V1, V0, 15248
9D0007C0  8C66000C   LW A2, 12(V1)
9D0007C4  24433B90   ADDIU V1, V0, 15248
9D0007C8  8C650010   LW A1, 16(V1)
9D0007CC  24433B90   ADDIU V1, V0, 15248
9D0007D0  8C640014   LW A0, 20(V1)
9D0007D4  24433B90   ADDIU V1, V0, 15248
9D0007D8  8C630018   LW V1, 24(V1)
9D0007DC  AFC90078   SW T1, 120(FP)
9D0007E0  AFC8007C   SW T0, 124(FP)
9D0007E4  AFC70080   SW A3, 128(FP)
9D0007E8  AFC60084   SW A2, 132(FP)
9D0007EC  AFC50088   SW A1, 136(FP)
9D0007F0  AFC4008C   SW A0, 140(FP)
9D0007F4  AFC30090   SW V1, 144(FP)
9D0007F8  24423B90   ADDIU V0, V0, 15248
9D0007FC  9042001C   LBU V0, 28(V0)
9D000800  A3C20094   SB V0, 148(FP)
151:                             int8_t Line2[] = "1: Afficher les informations actuelles du Wifi\r\n";
9D000804  3C029D00   LUI V0, -25344
9D000808  27C403A0   ADDIU A0, FP, 928
9D00080C  24433BB0   ADDIU V1, V0, 15280
9D000810  24020031   ADDIU V0, ZERO, 49
9D000814  00602821   ADDU A1, V1, ZERO
9D000818  00403021   ADDU A2, V0, ZERO
9D00081C  0F40272F   JAL .LFE1156, memcpy
9D000820  00000000   NOP
152:                             int8_t Line3[] = "2: Modifier le nom du reseau\r\n";
9D000824  3C029D00   LUI V0, -25344
9D000828  8C493BE4   LW T1, 15332(V0)
9D00082C  24433BE4   ADDIU V1, V0, 15332
9D000830  8C680004   LW T0, 4(V1)
9D000834  24433BE4   ADDIU V1, V0, 15332
9D000838  8C670008   LW A3, 8(V1)
9D00083C  24433BE4   ADDIU V1, V0, 15332
9D000840  8C66000C   LW A2, 12(V1)
9D000844  24433BE4   ADDIU V1, V0, 15332
9D000848  8C650010   LW A1, 16(V1)
9D00084C  24433BE4   ADDIU V1, V0, 15332
9D000850  8C640014   LW A0, 20(V1)
9D000854  24433BE4   ADDIU V1, V0, 15332
9D000858  8C630018   LW V1, 24(V1)
9D00085C  AFC90098   SW T1, 152(FP)
9D000860  AFC8009C   SW T0, 156(FP)
9D000864  AFC700A0   SW A3, 160(FP)
9D000868  AFC600A4   SW A2, 164(FP)
9D00086C  AFC500A8   SW A1, 168(FP)
9D000870  AFC400AC   SW A0, 172(FP)
9D000874  AFC300B0   SW V1, 176(FP)
9D000878  24423BE4   ADDIU V0, V0, 15332
9D00087C  9443001C   LHU V1, 28(V0)
9D000880  A7C300B4   SH V1, 180(FP)
9D000884  9042001E   LBU V0, 30(V0)
9D000888  A3C200B6   SB V0, 182(FP)
153:                             int8_t Line4[] = "3: Modifier le mot de passe\r\n";
9D00088C  3C029D00   LUI V0, -25344
9D000890  8C493C04   LW T1, 15364(V0)
9D000894  24433C04   ADDIU V1, V0, 15364
9D000898  8C680004   LW T0, 4(V1)
9D00089C  24433C04   ADDIU V1, V0, 15364
9D0008A0  8C670008   LW A3, 8(V1)
9D0008A4  24433C04   ADDIU V1, V0, 15364
9D0008A8  8C66000C   LW A2, 12(V1)
9D0008AC  24433C04   ADDIU V1, V0, 15364
9D0008B0  8C650010   LW A1, 16(V1)
9D0008B4  24433C04   ADDIU V1, V0, 15364
9D0008B8  8C640014   LW A0, 20(V1)
9D0008BC  24433C04   ADDIU V1, V0, 15364
9D0008C0  8C630018   LW V1, 24(V1)
9D0008C4  AFC900B8   SW T1, 184(FP)
9D0008C8  AFC800BC   SW T0, 188(FP)
9D0008CC  AFC700C0   SW A3, 192(FP)
9D0008D0  AFC600C4   SW A2, 196(FP)
9D0008D4  AFC500C8   SW A1, 200(FP)
9D0008D8  AFC400CC   SW A0, 204(FP)
9D0008DC  AFC300D0   SW V1, 208(FP)
9D0008E0  24423C04   ADDIU V0, V0, 15364
9D0008E4  9442001C   LHU V0, 28(V0)
9D0008E8  A7C200D4   SH V0, 212(FP)
154:                             int8_t Line5[] = "\"r\": Revenir en arriere\r\n\r\n";
9D0008EC  3C029D00   LUI V0, -25344
9D0008F0  8C483C24   LW T0, 15396(V0)
9D0008F4  24433C24   ADDIU V1, V0, 15396
9D0008F8  8C670004   LW A3, 4(V1)
9D0008FC  24433C24   ADDIU V1, V0, 15396
9D000900  8C660008   LW A2, 8(V1)
9D000904  24433C24   ADDIU V1, V0, 15396
9D000908  8C65000C   LW A1, 12(V1)
9D00090C  24433C24   ADDIU V1, V0, 15396
9D000910  8C640010   LW A0, 16(V1)
9D000914  24433C24   ADDIU V1, V0, 15396
9D000918  8C630014   LW V1, 20(V1)
9D00091C  24423C24   ADDIU V0, V0, 15396
9D000920  8C420018   LW V0, 24(V0)
9D000924  AFC800D8   SW T0, 216(FP)
9D000928  AFC700DC   SW A3, 220(FP)
9D00092C  AFC600E0   SW A2, 224(FP)
9D000930  AFC500E4   SW A1, 228(FP)
9D000934  AFC400E8   SW A0, 232(FP)
9D000938  AFC300EC   SW V1, 236(FP)
9D00093C  AFC200F0   SW V0, 240(FP)
155:                             
156:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D000940  27C20078   ADDIU V0, FP, 120
9D000944  00402021   ADDU A0, V0, ZERO
9D000948  0F402789   JAL strlen
9D00094C  00000000   NOP
9D000950  304200FF   ANDI V0, V0, 255
9D000954  27C30078   ADDIU V1, FP, 120
9D000958  00602021   ADDU A0, V1, ZERO
9D00095C  00402821   ADDU A1, V0, ZERO
9D000960  0F403051   JAL SendUSBMessage
9D000964  00000000   NOP
157:                             SendUSBMessage(Line2, strlen((char*)Line2));
9D000968  27C203A0   ADDIU V0, FP, 928
9D00096C  00402021   ADDU A0, V0, ZERO
9D000970  0F402789   JAL strlen
9D000974  00000000   NOP
9D000978  304200FF   ANDI V0, V0, 255
9D00097C  27C303A0   ADDIU V1, FP, 928
9D000980  00602021   ADDU A0, V1, ZERO
9D000984  00402821   ADDU A1, V0, ZERO
9D000988  0F403051   JAL SendUSBMessage
9D00098C  00000000   NOP
158:                             SendUSBMessage(Line3, strlen((char*)Line3));
9D000990  27C20098   ADDIU V0, FP, 152
9D000994  00402021   ADDU A0, V0, ZERO
9D000998  0F402789   JAL strlen
9D00099C  00000000   NOP
9D0009A0  304200FF   ANDI V0, V0, 255
9D0009A4  27C30098   ADDIU V1, FP, 152
9D0009A8  00602021   ADDU A0, V1, ZERO
9D0009AC  00402821   ADDU A1, V0, ZERO
9D0009B0  0F403051   JAL SendUSBMessage
9D0009B4  00000000   NOP
159:                             SendUSBMessage(Line4, strlen((char*)Line4));
9D0009B8  27C200B8   ADDIU V0, FP, 184
9D0009BC  00402021   ADDU A0, V0, ZERO
9D0009C0  0F402789   JAL strlen
9D0009C4  00000000   NOP
9D0009C8  304200FF   ANDI V0, V0, 255
9D0009CC  27C300B8   ADDIU V1, FP, 184
9D0009D0  00602021   ADDU A0, V1, ZERO
9D0009D4  00402821   ADDU A1, V0, ZERO
9D0009D8  0F403051   JAL SendUSBMessage
9D0009DC  00000000   NOP
160:                             SendUSBMessage(Line5, strlen((char*)Line5));
9D0009E0  27C200D8   ADDIU V0, FP, 216
9D0009E4  00402021   ADDU A0, V0, ZERO
9D0009E8  0F402789   JAL strlen
9D0009EC  00000000   NOP
9D0009F0  304200FF   ANDI V0, V0, 255
9D0009F4  27C300D8   ADDIU V1, FP, 216
9D0009F8  00602021   ADDU A0, V1, ZERO
9D0009FC  00402821   ADDU A1, V0, ZERO
9D000A00  0F403051   JAL SendUSBMessage
9D000A04  00000000   NOP
161:                             
162:                             MenuStatus = Wifi_Get;
9D000A08  24020006   ADDIU V0, ZERO, 6
9D000A0C  AF828034   SW V0, -32716(GP)
163:                             break;
9D000A10  00000000   NOP
9D000A14  0B40070F   J 0x9D001C3C
9D000A18  00000000   NOP
164:                         }
165:                         case Wifi_Get: 
166:                         {
167:                             int8_t menuResponse[10];
168:                             
169:                             if(GetUSBMessage(menuResponse,"1") == OK){
9D000A1C  27C200F4   ADDIU V0, FP, 244
9D000A20  00402021   ADDU A0, V0, ZERO
9D000A24  3C029D00   LUI V0, -25344
9D000A28  24453900   ADDIU A1, V0, 14592
9D000A2C  0F402221   JAL GetUSBMessage
9D000A30  00000000   NOP
9D000A34  14400005   BNE V0, ZERO, 0x9D000A4C
9D000A38  00000000   NOP
170:                                 MenuStatus = Wifi_Info;
9D000A3C  24020007   ADDIU V0, ZERO, 7
9D000A40  AF828034   SW V0, -32716(GP)
171:                                 break;
9D000A44  0B40070F   J 0x9D001C3C
9D000A48  00000000   NOP
172:                             }         
173:                 
174:                             if(GetUSBMessage(menuResponse,"2") == OK){
9D000A4C  27C200F4   ADDIU V0, FP, 244
9D000A50  00402021   ADDU A0, V0, ZERO
9D000A54  3C029D00   LUI V0, -25344
9D000A58  24453904   ADDIU A1, V0, 14596
9D000A5C  0F402221   JAL GetUSBMessage
9D000A60  00000000   NOP
9D000A64  14400005   BNE V0, ZERO, 0x9D000A7C
9D000A68  00000000   NOP
175:                                 MenuStatus = Wifi_SSID_Set;
9D000A6C  24020008   ADDIU V0, ZERO, 8
9D000A70  AF828034   SW V0, -32716(GP)
176:                                 break;
9D000A74  0B40070F   J 0x9D001C3C
9D000A78  00000000   NOP
177:                             }   
178:                             
179:                             if(GetUSBMessage(menuResponse,"3") == OK){
9D000A7C  27C200F4   ADDIU V0, FP, 244
9D000A80  00402021   ADDU A0, V0, ZERO
9D000A84  3C029D00   LUI V0, -25344
9D000A88  24453908   ADDIU A1, V0, 14600
9D000A8C  0F402221   JAL GetUSBMessage
9D000A90  00000000   NOP
9D000A94  14400005   BNE V0, ZERO, 0x9D000AAC
9D000A98  00000000   NOP
180:                                 MenuStatus = Wifi_PWD_Set;
9D000A9C  2402000A   ADDIU V0, ZERO, 10
9D000AA0  AF828034   SW V0, -32716(GP)
181:                                 break;
9D000AA4  0B40070F   J 0x9D001C3C
9D000AA8  00000000   NOP
182:                             }  
183:                             
184:                             if(GetUSBMessage(menuResponse,"r") == OK){
9D000AAC  27C200F4   ADDIU V0, FP, 244
9D000AB0  00402021   ADDU A0, V0, ZERO
9D000AB4  3C029D00   LUI V0, -25344
9D000AB8  24453914   ADDIU A1, V0, 14612
9D000ABC  0F402221   JAL GetUSBMessage
9D000AC0  00000000   NOP
9D000AC4  14400005   BNE V0, ZERO, 0x9D000ADC
9D000AC8  00000000   NOP
185:                                 MenuStatus = Menu_Set;
9D000ACC  24020003   ADDIU V0, ZERO, 3
9D000AD0  AF828034   SW V0, -32716(GP)
186:                                 break;
9D000AD4  0B40070F   J 0x9D001C3C
9D000AD8  00000000   NOP
187:                             }  
188:                             break;
9D000ADC  00000000   NOP
9D000AE0  0B40070F   J 0x9D001C3C
9D000AE4  00000000   NOP
189:                         }
190:                         case Wifi_Info:
191:                         {
192:                             int8_t Line1[30];
193:                             int8_t Line2[30];
194:                             int8_t Line3[30];
195:                             //int8_t Line4[30];
196:                             
197:                             sprintf((char*)Line1, "SSID : %s\r\n", Wifi.SSID);
9D000AE8  27C20100   ADDIU V0, FP, 256
9D000AEC  00402021   ADDU A0, V0, ZERO
9D000AF0  3C029D00   LUI V0, -25344
9D000AF4  24453918   ADDIU A1, V0, 14616
9D000AF8  3C02A000   LUI V0, -24576
9D000AFC  244603BC   ADDIU A2, V0, 956
9D000B00  0F40350B   JAL _sprintf_cdfFnopsuxX
9D000B04  00000000   NOP
198:                             sprintf((char*)Line2, "PWD  : %s\r\n", Wifi.PWD);
9D000B08  27C20120   ADDIU V0, FP, 288
9D000B0C  00402021   ADDU A0, V0, ZERO
9D000B10  3C029D00   LUI V0, -25344
9D000B14  24453924   ADDIU A1, V0, 14628
9D000B18  3C02A000   LUI V0, -24576
9D000B1C  24460420   ADDIU A2, V0, 1056
9D000B20  0F40350B   JAL _sprintf_cdfFnopsuxX
9D000B24  00000000   NOP
199:                             sprintf((char*)Line3, "IP   : %s\r\n", ESP8266.IP);
9D000B28  27C20140   ADDIU V0, FP, 320
9D000B2C  00402021   ADDU A0, V0, ZERO
9D000B30  3C029D00   LUI V0, -25344
9D000B34  24453930   ADDIU A1, V0, 14640
9D000B38  3C02A000   LUI V0, -24576
9D000B3C  24460244   ADDIU A2, V0, 580
9D000B40  0F40350B   JAL _sprintf_cdfFnopsuxX
9D000B44  00000000   NOP
200:                             
201:                 
202:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D000B48  27C20100   ADDIU V0, FP, 256
9D000B4C  00402021   ADDU A0, V0, ZERO
9D000B50  0F402789   JAL strlen
9D000B54  00000000   NOP
9D000B58  304200FF   ANDI V0, V0, 255
9D000B5C  27C30100   ADDIU V1, FP, 256
9D000B60  00602021   ADDU A0, V1, ZERO
9D000B64  00402821   ADDU A1, V0, ZERO
9D000B68  0F403051   JAL SendUSBMessage
9D000B6C  00000000   NOP
203:                             SendUSBMessage(Line2, strlen((char*)Line2));
9D000B70  27C20120   ADDIU V0, FP, 288
9D000B74  00402021   ADDU A0, V0, ZERO
9D000B78  0F402789   JAL strlen
9D000B7C  00000000   NOP
9D000B80  304200FF   ANDI V0, V0, 255
9D000B84  27C30120   ADDIU V1, FP, 288
9D000B88  00602021   ADDU A0, V1, ZERO
9D000B8C  00402821   ADDU A1, V0, ZERO
9D000B90  0F403051   JAL SendUSBMessage
9D000B94  00000000   NOP
204:                             SendUSBMessage(Line3, strlen((char*)Line3));
9D000B98  27C20140   ADDIU V0, FP, 320
9D000B9C  00402021   ADDU A0, V0, ZERO
9D000BA0  0F402789   JAL strlen
9D000BA4  00000000   NOP
9D000BA8  304200FF   ANDI V0, V0, 255
9D000BAC  27C30140   ADDIU V1, FP, 320
9D000BB0  00602021   ADDU A0, V1, ZERO
9D000BB4  00402821   ADDU A1, V0, ZERO
9D000BB8  0F403051   JAL SendUSBMessage
9D000BBC  00000000   NOP
205:                             //SendUSBMessage(Line4, strlen((char*)Line4));
206:                             
207:                             MenuStatus = Wifi_Set;
9D000BC0  24020005   ADDIU V0, ZERO, 5
9D000BC4  AF828034   SW V0, -32716(GP)
208:                             break;
9D000BC8  00000000   NOP
9D000BCC  0B40070F   J 0x9D001C3C
9D000BD0  00000000   NOP
209:                         }
210:                         case Wifi_SSID_Set: 
211:                         {
212:                             int8_t Line1[] = "Entrez le nouveau nom : ";
9D000BD4  3C029D00   LUI V0, -25344
9D000BD8  8C483C40   LW T0, 15424(V0)
9D000BDC  24433C40   ADDIU V1, V0, 15424
9D000BE0  8C670004   LW A3, 4(V1)
9D000BE4  24433C40   ADDIU V1, V0, 15424
9D000BE8  8C660008   LW A2, 8(V1)
9D000BEC  24433C40   ADDIU V1, V0, 15424
9D000BF0  8C65000C   LW A1, 12(V1)
9D000BF4  24433C40   ADDIU V1, V0, 15424
9D000BF8  8C640010   LW A0, 16(V1)
9D000BFC  24433C40   ADDIU V1, V0, 15424
9D000C00  8C630014   LW V1, 20(V1)
9D000C04  AFC80160   SW T0, 352(FP)
9D000C08  AFC70164   SW A3, 356(FP)
9D000C0C  AFC60168   SW A2, 360(FP)
9D000C10  AFC5016C   SW A1, 364(FP)
9D000C14  AFC40170   SW A0, 368(FP)
9D000C18  AFC30174   SW V1, 372(FP)
9D000C1C  24423C40   ADDIU V0, V0, 15424
9D000C20  90420018   LBU V0, 24(V0)
9D000C24  A3C20178   SB V0, 376(FP)
213:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D000C28  27C20160   ADDIU V0, FP, 352
9D000C2C  00402021   ADDU A0, V0, ZERO
9D000C30  0F402789   JAL strlen
9D000C34  00000000   NOP
9D000C38  304200FF   ANDI V0, V0, 255
9D000C3C  27C30160   ADDIU V1, FP, 352
9D000C40  00602021   ADDU A0, V1, ZERO
9D000C44  00402821   ADDU A1, V0, ZERO
9D000C48  0F403051   JAL SendUSBMessage
9D000C4C  00000000   NOP
214:                             
215:                             MenuStatus = Wifi_SSID_Get;
9D000C50  24020009   ADDIU V0, ZERO, 9
9D000C54  AF828034   SW V0, -32716(GP)
216:                             break;
9D000C58  00000000   NOP
9D000C5C  0B40070F   J 0x9D001C3C
9D000C60  00000000   NOP
217:                         }
218:                         case Wifi_SSID_Get: 
219:                         {
220:                             int8_t nSSID[100]={0};
9D000C64  27C303A0   ADDIU V1, FP, 928
9D000C68  24020064   ADDIU V0, ZERO, 100
9D000C6C  00602021   ADDU A0, V1, ZERO
9D000C70  00002821   ADDU A1, ZERO, ZERO
9D000C74  00403021   ADDU A2, V0, ZERO
9D000C78  0F4031E5   JAL .LFE4, memset
9D000C7C  00000000   NOP
221:                             
222:                             if(GetUSBMessage(nSSID, "\r") == OK)
9D000C80  27C203A0   ADDIU V0, FP, 928
9D000C84  00402021   ADDU A0, V0, ZERO
9D000C88  3C029D00   LUI V0, -25344
9D000C8C  2445393C   ADDIU A1, V0, 14652
9D000C90  0F402221   JAL GetUSBMessage
9D000C94  00000000   NOP
9D000C98  1440001D   BNE V0, ZERO, .LBE12
9D000C9C  00000000   NOP
223:                             {
224:                                 memcpy(Wifi.SSID, nSSID, sizeof(nSSID));
9D000CA0  3C02A000   LUI V0, -24576
9D000CA4  244403BC   ADDIU A0, V0, 956
9D000CA8  27C303A0   ADDIU V1, FP, 928
9D000CAC  24020064   ADDIU V0, ZERO, 100
9D000CB0  00602821   ADDU A1, V1, ZERO
9D000CB4  00403021   ADDU A2, V0, ZERO
9D000CB8  0F40272F   JAL .LFE1156, memcpy
9D000CBC  00000000   NOP
225:                                 
226:                                 int8_t Line1[] = "Nouveau nom de reseau enregistre!\r\n";
9D000CC0  3C029D00   LUI V0, -25344
9D000CC4  27C40404   ADDIU A0, FP, 1028
9D000CC8  24433C5C   ADDIU V1, V0, 15452
9D000CCC  24020024   ADDIU V0, ZERO, 36
9D000CD0  00602821   ADDU A1, V1, ZERO
9D000CD4  00403021   ADDU A2, V0, ZERO
9D000CD8  0F40272F   JAL .LFE1156, memcpy
9D000CDC  00000000   NOP
227:                                 SendUSBMessage(Line1, strlen((char*)Line1));
9D000CE0  27C20404   ADDIU V0, FP, 1028
9D000CE4  00402021   ADDU A0, V0, ZERO
9D000CE8  0F402789   JAL strlen
9D000CEC  00000000   NOP
9D000CF0  304200FF   ANDI V0, V0, 255
9D000CF4  27C30404   ADDIU V1, FP, 1028
9D000CF8  00602021   ADDU A0, V1, ZERO
9D000CFC  00402821   ADDU A1, V0, ZERO
9D000D00  0F403051   JAL SendUSBMessage
9D000D04  00000000   NOP
228:                                 
229:                                 MenuStatus = Wifi_Set;
9D000D08  24020005   ADDIU V0, ZERO, 5
9D000D0C  AF828034   SW V0, -32716(GP)
230:                             }
231:                             break;
9D000D10  00000000   NOP
9D000D14  0B40070F   J 0x9D001C3C
9D000D18  00000000   NOP
232:                         }
233:                         case Wifi_PWD_Set: 
234:                         {
235:                             int8_t Line1[] = "Entrez le nouveau mot de passe : ";
9D000D1C  3C029D00   LUI V0, -25344
9D000D20  27C403A0   ADDIU A0, FP, 928
9D000D24  24433C80   ADDIU V1, V0, 15488
9D000D28  24020022   ADDIU V0, ZERO, 34
9D000D2C  00602821   ADDU A1, V1, ZERO
9D000D30  00403021   ADDU A2, V0, ZERO
9D000D34  0F40272F   JAL .LFE1156, memcpy
9D000D38  00000000   NOP
236:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D000D3C  27C203A0   ADDIU V0, FP, 928
9D000D40  00402021   ADDU A0, V0, ZERO
9D000D44  0F402789   JAL strlen
9D000D48  00000000   NOP
9D000D4C  304200FF   ANDI V0, V0, 255
9D000D50  27C303A0   ADDIU V1, FP, 928
9D000D54  00602021   ADDU A0, V1, ZERO
9D000D58  00402821   ADDU A1, V0, ZERO
9D000D5C  0F403051   JAL SendUSBMessage
9D000D60  00000000   NOP
237:                             
238:                             MenuStatus = Wifi_PWD_Get;
9D000D64  2402000B   ADDIU V0, ZERO, 11
9D000D68  AF828034   SW V0, -32716(GP)
239:                             break;
9D000D6C  00000000   NOP
9D000D70  0B40070F   J 0x9D001C3C
9D000D74  00000000   NOP
240:                         }
241:                         case Wifi_PWD_Get: 
242:                         {
243:                             int8_t nPWD[100]={0};
9D000D78  27C303A0   ADDIU V1, FP, 928
9D000D7C  24020064   ADDIU V0, ZERO, 100
9D000D80  00602021   ADDU A0, V1, ZERO
9D000D84  00002821   ADDU A1, ZERO, ZERO
9D000D88  00403021   ADDU A2, V0, ZERO
9D000D8C  0F4031E5   JAL .LFE4, memset
9D000D90  00000000   NOP
244:                             
245:                             if(GetUSBMessage(nPWD, "\r") == OK)
9D000D94  27C203A0   ADDIU V0, FP, 928
9D000D98  00402021   ADDU A0, V0, ZERO
9D000D9C  3C029D00   LUI V0, -25344
9D000DA0  2445393C   ADDIU A1, V0, 14652
9D000DA4  0F402221   JAL GetUSBMessage
9D000DA8  00000000   NOP
9D000DAC  1440001E   BNE V0, ZERO, .LBE15
9D000DB0  00000000   NOP
246:                             {
247:                                 memmove(Wifi.PWD, nPWD, sizeof(nPWD));
9D000DB4  3C02A000   LUI V0, -24576
9D000DB8  244203BC   ADDIU V0, V0, 956
9D000DBC  24440064   ADDIU A0, V0, 100
9D000DC0  27C303A0   ADDIU V1, FP, 928
9D000DC4  24020064   ADDIU V0, ZERO, 100
9D000DC8  00602821   ADDU A1, V1, ZERO
9D000DCC  00403021   ADDU A2, V0, ZERO
9D000DD0  0F40272F   JAL .LFE1156, memcpy
9D000DD4  00000000   NOP
248:                                 
249:                                 int8_t Line1[] = "Nouveau mot de passe enregistre!\r\n";
9D000DD8  3C029D00   LUI V0, -25344
9D000DDC  27C40404   ADDIU A0, FP, 1028
9D000DE0  24433CA4   ADDIU V1, V0, 15524
9D000DE4  24020023   ADDIU V0, ZERO, 35
9D000DE8  00602821   ADDU A1, V1, ZERO
9D000DEC  00403021   ADDU A2, V0, ZERO
9D000DF0  0F40272F   JAL .LFE1156, memcpy
9D000DF4  00000000   NOP
250:                                 SendUSBMessage(Line1, strlen((char*)Line1));
9D000DF8  27C20404   ADDIU V0, FP, 1028
9D000DFC  00402021   ADDU A0, V0, ZERO
9D000E00  0F402789   JAL strlen
9D000E04  00000000   NOP
9D000E08  304200FF   ANDI V0, V0, 255
9D000E0C  27C30404   ADDIU V1, FP, 1028
9D000E10  00602021   ADDU A0, V1, ZERO
9D000E14  00402821   ADDU A1, V0, ZERO
9D000E18  0F403051   JAL SendUSBMessage
9D000E1C  00000000   NOP
251:                                 MenuStatus = Wifi_Set;
9D000E20  24020005   ADDIU V0, ZERO, 5
9D000E24  AF828034   SW V0, -32716(GP)
252:                             }
253:                             break;
9D000E28  00000000   NOP
9D000E2C  0B40070F   J 0x9D001C3C
9D000E30  00000000   NOP
254:                         }
255:                         case Domoticz_Set: 
256:                         {
257:                             int8_t Line1[] = "\r\nQue voulez-vous faire ?\r\n\r\n";
9D000E34  3C029D00   LUI V0, -25344
9D000E38  8C493CC8   LW T1, 15560(V0)
9D000E3C  24433CC8   ADDIU V1, V0, 15560
9D000E40  8C680004   LW T0, 4(V1)
9D000E44  24433CC8   ADDIU V1, V0, 15560
9D000E48  8C670008   LW A3, 8(V1)
9D000E4C  24433CC8   ADDIU V1, V0, 15560
9D000E50  8C66000C   LW A2, 12(V1)
9D000E54  24433CC8   ADDIU V1, V0, 15560
9D000E58  8C650010   LW A1, 16(V1)
9D000E5C  24433CC8   ADDIU V1, V0, 15560
9D000E60  8C640014   LW A0, 20(V1)
9D000E64  24433CC8   ADDIU V1, V0, 15560
9D000E68  8C630018   LW V1, 24(V1)
9D000E6C  AFC9017C   SW T1, 380(FP)
9D000E70  AFC80180   SW T0, 384(FP)
9D000E74  AFC70184   SW A3, 388(FP)
9D000E78  AFC60188   SW A2, 392(FP)
9D000E7C  AFC5018C   SW A1, 396(FP)
9D000E80  AFC40190   SW A0, 400(FP)
9D000E84  AFC30194   SW V1, 404(FP)
9D000E88  24423CC8   ADDIU V0, V0, 15560
9D000E8C  9442001C   LHU V0, 28(V0)
9D000E90  A7C20198   SH V0, 408(FP)
258:                             int8_t Line2[] = "1: Afficher les informations actuelles du serveur\r\n";
9D000E94  3C029D00   LUI V0, -25344
9D000E98  27C403A0   ADDIU A0, FP, 928
9D000E9C  24433CE8   ADDIU V1, V0, 15592
9D000EA0  24020034   ADDIU V0, ZERO, 52
9D000EA4  00602821   ADDU A1, V1, ZERO
9D000EA8  00403021   ADDU A2, V0, ZERO
9D000EAC  0F40272F   JAL .LFE1156, memcpy
9D000EB0  00000000   NOP
259:                             int8_t Line3[] = "2: Modfier l'IP du serveur\r\n";
9D000EB4  3C029D00   LUI V0, -25344
9D000EB8  8C493D1C   LW T1, 15644(V0)
9D000EBC  24433D1C   ADDIU V1, V0, 15644
9D000EC0  8C680004   LW T0, 4(V1)
9D000EC4  24433D1C   ADDIU V1, V0, 15644
9D000EC8  8C670008   LW A3, 8(V1)
9D000ECC  24433D1C   ADDIU V1, V0, 15644
9D000ED0  8C66000C   LW A2, 12(V1)
9D000ED4  24433D1C   ADDIU V1, V0, 15644
9D000ED8  8C650010   LW A1, 16(V1)
9D000EDC  24433D1C   ADDIU V1, V0, 15644
9D000EE0  8C640014   LW A0, 20(V1)
9D000EE4  24433D1C   ADDIU V1, V0, 15644
9D000EE8  8C630018   LW V1, 24(V1)
9D000EEC  AFC9019C   SW T1, 412(FP)
9D000EF0  AFC801A0   SW T0, 416(FP)
9D000EF4  AFC701A4   SW A3, 420(FP)
9D000EF8  AFC601A8   SW A2, 424(FP)
9D000EFC  AFC501AC   SW A1, 428(FP)
9D000F00  AFC401B0   SW A0, 432(FP)
9D000F04  AFC301B4   SW V1, 436(FP)
9D000F08  24423D1C   ADDIU V0, V0, 15644
9D000F0C  9042001C   LBU V0, 28(V0)
9D000F10  A3C201B8   SB V0, 440(FP)
260:                             int8_t Line4[] = "3: Modifier le port du serveur\r\n";
9D000F14  3C029D00   LUI V0, -25344
9D000F18  27C40404   ADDIU A0, FP, 1028
9D000F1C  24433D3C   ADDIU V1, V0, 15676
9D000F20  24020021   ADDIU V0, ZERO, 33
9D000F24  00602821   ADDU A1, V1, ZERO
9D000F28  00403021   ADDU A2, V0, ZERO
9D000F2C  0F40272F   JAL .LFE1156, memcpy
9D000F30  00000000   NOP
261:                             int8_t Line5[] = "4: Modifier l'index du module\r\n";
9D000F34  3C029D00   LUI V0, -25344
9D000F38  8C493D60   LW T1, 15712(V0)
9D000F3C  24433D60   ADDIU V1, V0, 15712
9D000F40  8C680004   LW T0, 4(V1)
9D000F44  24433D60   ADDIU V1, V0, 15712
9D000F48  8C670008   LW A3, 8(V1)
9D000F4C  24433D60   ADDIU V1, V0, 15712
9D000F50  8C66000C   LW A2, 12(V1)
9D000F54  24433D60   ADDIU V1, V0, 15712
9D000F58  8C650010   LW A1, 16(V1)
9D000F5C  24433D60   ADDIU V1, V0, 15712
9D000F60  8C640014   LW A0, 20(V1)
9D000F64  24433D60   ADDIU V1, V0, 15712
9D000F68  8C630018   LW V1, 24(V1)
9D000F6C  24423D60   ADDIU V0, V0, 15712
9D000F70  8C42001C   LW V0, 28(V0)
9D000F74  AFC90434   SW T1, 1076(FP)
9D000F78  AFC80438   SW T0, 1080(FP)
9D000F7C  AFC7043C   SW A3, 1084(FP)
9D000F80  AFC60440   SW A2, 1088(FP)
9D000F84  AFC50444   SW A1, 1092(FP)
9D000F88  AFC40448   SW A0, 1096(FP)
9D000F8C  AFC3044C   SW V1, 1100(FP)
9D000F90  AFC20450   SW V0, 1104(FP)
262:                             int8_t Line6[] = "\"r\": Revenir en arriere\r\n\r\n";
9D000F94  3C029D00   LUI V0, -25344
9D000F98  8C483C24   LW T0, 15396(V0)
9D000F9C  24433C24   ADDIU V1, V0, 15396
9D000FA0  8C670004   LW A3, 4(V1)
9D000FA4  24433C24   ADDIU V1, V0, 15396
9D000FA8  8C660008   LW A2, 8(V1)
9D000FAC  24433C24   ADDIU V1, V0, 15396
9D000FB0  8C65000C   LW A1, 12(V1)
9D000FB4  24433C24   ADDIU V1, V0, 15396
9D000FB8  8C640010   LW A0, 16(V1)
9D000FBC  24433C24   ADDIU V1, V0, 15396
9D000FC0  8C630014   LW V1, 20(V1)
9D000FC4  24423C24   ADDIU V0, V0, 15396
9D000FC8  8C420018   LW V0, 24(V0)
9D000FCC  AFC801BC   SW T0, 444(FP)
9D000FD0  AFC701C0   SW A3, 448(FP)
9D000FD4  AFC601C4   SW A2, 452(FP)
9D000FD8  AFC501C8   SW A1, 456(FP)
9D000FDC  AFC401CC   SW A0, 460(FP)
9D000FE0  AFC301D0   SW V1, 464(FP)
9D000FE4  AFC201D4   SW V0, 468(FP)
263:                             
264:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D000FE8  27C2017C   ADDIU V0, FP, 380
9D000FEC  00402021   ADDU A0, V0, ZERO
9D000FF0  0F402789   JAL strlen
9D000FF4  00000000   NOP
9D000FF8  304200FF   ANDI V0, V0, 255
9D000FFC  27C3017C   ADDIU V1, FP, 380
9D001000  00602021   ADDU A0, V1, ZERO
9D001004  00402821   ADDU A1, V0, ZERO
9D001008  0F403051   JAL SendUSBMessage
9D00100C  00000000   NOP
265:                             SendUSBMessage(Line2, strlen((char*)Line2));
9D001010  27C203A0   ADDIU V0, FP, 928
9D001014  00402021   ADDU A0, V0, ZERO
9D001018  0F402789   JAL strlen
9D00101C  00000000   NOP
9D001020  304200FF   ANDI V0, V0, 255
9D001024  27C303A0   ADDIU V1, FP, 928
9D001028  00602021   ADDU A0, V1, ZERO
9D00102C  00402821   ADDU A1, V0, ZERO
9D001030  0F403051   JAL SendUSBMessage
9D001034  00000000   NOP
266:                             SendUSBMessage(Line3, strlen((char*)Line3));
9D001038  27C2019C   ADDIU V0, FP, 412
9D00103C  00402021   ADDU A0, V0, ZERO
9D001040  0F402789   JAL strlen
9D001044  00000000   NOP
9D001048  304200FF   ANDI V0, V0, 255
9D00104C  27C3019C   ADDIU V1, FP, 412
9D001050  00602021   ADDU A0, V1, ZERO
9D001054  00402821   ADDU A1, V0, ZERO
9D001058  0F403051   JAL SendUSBMessage
9D00105C  00000000   NOP
267:                             SendUSBMessage(Line4, strlen((char*)Line4));
9D001060  27C20404   ADDIU V0, FP, 1028
9D001064  00402021   ADDU A0, V0, ZERO
9D001068  0F402789   JAL strlen
9D00106C  00000000   NOP
9D001070  304200FF   ANDI V0, V0, 255
9D001074  27C30404   ADDIU V1, FP, 1028
9D001078  00602021   ADDU A0, V1, ZERO
9D00107C  00402821   ADDU A1, V0, ZERO
9D001080  0F403051   JAL SendUSBMessage
9D001084  00000000   NOP
268:                             SendUSBMessage(Line5, strlen((char*)Line5));
9D001088  27C20434   ADDIU V0, FP, 1076
9D00108C  00402021   ADDU A0, V0, ZERO
9D001090  0F402789   JAL strlen
9D001094  00000000   NOP
9D001098  304200FF   ANDI V0, V0, 255
9D00109C  27C30434   ADDIU V1, FP, 1076
9D0010A0  00602021   ADDU A0, V1, ZERO
9D0010A4  00402821   ADDU A1, V0, ZERO
9D0010A8  0F403051   JAL SendUSBMessage
9D0010AC  00000000   NOP
269:                             SendUSBMessage(Line6, strlen((char*)Line6));
9D0010B0  27C201BC   ADDIU V0, FP, 444
9D0010B4  00402021   ADDU A0, V0, ZERO
9D0010B8  0F402789   JAL strlen
9D0010BC  00000000   NOP
9D0010C0  304200FF   ANDI V0, V0, 255
9D0010C4  27C301BC   ADDIU V1, FP, 444
9D0010C8  00602021   ADDU A0, V1, ZERO
9D0010CC  00402821   ADDU A1, V0, ZERO
9D0010D0  0F403051   JAL SendUSBMessage
9D0010D4  00000000   NOP
270:                             
271:                             MenuStatus = Domoticz_Get;
9D0010D8  2402000D   ADDIU V0, ZERO, 13
9D0010DC  AF828034   SW V0, -32716(GP)
272:                             break;
9D0010E0  00000000   NOP
9D0010E4  0B40070F   J 0x9D001C3C
9D0010E8  00000000   NOP
273:                         }
274:                         case Domoticz_Get: 
275:                         {
276:                             int8_t menuResponse[10];
277:                             
278:                             if(GetUSBMessage(menuResponse,"1") == OK){
9D0010EC  27C201D8   ADDIU V0, FP, 472
9D0010F0  00402021   ADDU A0, V0, ZERO
9D0010F4  3C029D00   LUI V0, -25344
9D0010F8  24453900   ADDIU A1, V0, 14592
9D0010FC  0F402221   JAL GetUSBMessage
9D001100  00000000   NOP
9D001104  14400005   BNE V0, ZERO, 0x9D00111C
9D001108  00000000   NOP
279:                                 MenuStatus = Domo_Info;
9D00110C  2402000E   ADDIU V0, ZERO, 14
9D001110  AF828034   SW V0, -32716(GP)
280:                                 break;
9D001114  0B40070F   J 0x9D001C3C
9D001118  00000000   NOP
281:                             }    
282:                             
283:                             if(GetUSBMessage(menuResponse,"2") == OK){
9D00111C  27C201D8   ADDIU V0, FP, 472
9D001120  00402021   ADDU A0, V0, ZERO
9D001124  3C029D00   LUI V0, -25344
9D001128  24453904   ADDIU A1, V0, 14596
9D00112C  0F402221   JAL GetUSBMessage
9D001130  00000000   NOP
9D001134  14400005   BNE V0, ZERO, 0x9D00114C
9D001138  00000000   NOP
284:                                 MenuStatus = Domo_IP_Set;
9D00113C  2402000F   ADDIU V0, ZERO, 15
9D001140  AF828034   SW V0, -32716(GP)
285:                                 break;
9D001144  0B40070F   J 0x9D001C3C
9D001148  00000000   NOP
286:                             }         
287:                 
288:                             if(GetUSBMessage(menuResponse,"3") == OK){
9D00114C  27C201D8   ADDIU V0, FP, 472
9D001150  00402021   ADDU A0, V0, ZERO
9D001154  3C029D00   LUI V0, -25344
9D001158  24453908   ADDIU A1, V0, 14600
9D00115C  0F402221   JAL GetUSBMessage
9D001160  00000000   NOP
9D001164  14400005   BNE V0, ZERO, 0x9D00117C
9D001168  00000000   NOP
289:                                 MenuStatus = Domo_Port_Set;
9D00116C  24020011   ADDIU V0, ZERO, 17
9D001170  AF828034   SW V0, -32716(GP)
290:                                 break;
9D001174  0B40070F   J 0x9D001C3C
9D001178  00000000   NOP
291:                             }    
292:                 
293:                             if(GetUSBMessage(menuResponse,"4") == OK){
9D00117C  27C201D8   ADDIU V0, FP, 472
9D001180  00402021   ADDU A0, V0, ZERO
9D001184  3C029D00   LUI V0, -25344
9D001188  2445390C   ADDIU A1, V0, 14604
9D00118C  0F402221   JAL GetUSBMessage
9D001190  00000000   NOP
9D001194  14400005   BNE V0, ZERO, 0x9D0011AC
9D001198  00000000   NOP
294:                                 MenuStatus = Domo_Index_Set;
9D00119C  24020013   ADDIU V0, ZERO, 19
9D0011A0  AF828034   SW V0, -32716(GP)
295:                                 break;
9D0011A4  0B40070F   J 0x9D001C3C
9D0011A8  00000000   NOP
296:                             }
297:                             
298:                             if(GetUSBMessage(menuResponse,"r") == OK){
9D0011AC  27C201D8   ADDIU V0, FP, 472
9D0011B0  00402021   ADDU A0, V0, ZERO
9D0011B4  3C029D00   LUI V0, -25344
9D0011B8  24453914   ADDIU A1, V0, 14612
9D0011BC  0F402221   JAL GetUSBMessage
9D0011C0  00000000   NOP
9D0011C4  14400005   BNE V0, ZERO, 0x9D0011DC
9D0011C8  00000000   NOP
299:                                 MenuStatus = Menu_Set;
9D0011CC  24020003   ADDIU V0, ZERO, 3
9D0011D0  AF828034   SW V0, -32716(GP)
300:                                 break;
9D0011D4  0B40070F   J 0x9D001C3C
9D0011D8  00000000   NOP
301:                             }  
302:                             break;
9D0011DC  00000000   NOP
9D0011E0  0B40070F   J 0x9D001C3C
9D0011E4  00000000   NOP
303:                         }
304:                         case Domo_Info:
305:                         {        
306:                             int8_t Line1[30];
307:                             int8_t Line2[30];
308:                             int8_t Line3[30];
309:                             int8_t Line4[30];
310:                             int8_t Line5[30];
311:                             
312:                             sprintf((char*)Line1, "IP       : %s\r\n", Wifi.IPDom);
9D0011E8  27C201E4   ADDIU V0, FP, 484
9D0011EC  00402021   ADDU A0, V0, ZERO
9D0011F0  3C029D00   LUI V0, -25344
9D0011F4  24453940   ADDIU A1, V0, 14656
9D0011F8  3C02A000   LUI V0, -24576
9D0011FC  24460484   ADDIU A2, V0, 1156
9D001200  0F40350B   JAL _sprintf_cdfFnopsuxX
9D001204  00000000   NOP
313:                             sprintf((char*)Line2, "Port     : %s\r\n", Wifi.PortDom);
9D001208  27C20204   ADDIU V0, FP, 516
9D00120C  00402021   ADDU A0, V0, ZERO
9D001210  3C029D00   LUI V0, -25344
9D001214  24453950   ADDIU A1, V0, 14672
9D001218  3C02A000   LUI V0, -24576
9D00121C  24460493   ADDIU A2, V0, 1171
9D001220  0F40350B   JAL _sprintf_cdfFnopsuxX
9D001224  00000000   NOP
314:                             sprintf((char*)Line3, "MAC      : %s\r\n", ESP8266.MAC);
9D001228  27C20224   ADDIU V0, FP, 548
9D00122C  00402021   ADDU A0, V0, ZERO
9D001230  3C029D00   LUI V0, -25344
9D001234  24453960   ADDIU A1, V0, 14688
9D001238  3C02A000   LUI V0, -24576
9D00123C  24460253   ADDIU A2, V0, 595
9D001240  0F40350B   JAL _sprintf_cdfFnopsuxX
9D001244  00000000   NOP
315:                             sprintf((char*)Line4, "Interval : %dmin\r\n", (ESP8266.Interval/20/60));
9D001248  3C02A000   LUI V0, -24576
9D00124C  24420244   ADDIU V0, V0, 580
9D001250  8C430020   LW V1, 32(V0)
9D001254  3C021B4E   LUI V0, 6990
9D001258  344281B5   ORI V0, V0, -32331
9D00125C  00620019   MULTU 0, V1, V0
9D001260  00001010   MFHI V0
9D001264  000211C2   SRL V0, V0, 7
9D001268  27C30244   ADDIU V1, FP, 580
9D00126C  00602021   ADDU A0, V1, ZERO
9D001270  3C039D00   LUI V1, -25344
9D001274  24653970   ADDIU A1, V1, 14704
9D001278  00403021   ADDU A2, V0, ZERO
9D00127C  0F40350B   JAL _sprintf_cdfFnopsuxX
9D001280  00000000   NOP
316:                             sprintf((char*)Line5, "Index    : %d\r\n", BME280.Index);
9D001284  3C02A000   LUI V0, -24576
9D001288  90420270   LBU V0, 624(V0)
9D00128C  27C30264   ADDIU V1, FP, 612
9D001290  00602021   ADDU A0, V1, ZERO
9D001294  3C039D00   LUI V1, -25344
9D001298  24653984   ADDIU A1, V1, 14724
9D00129C  00403021   ADDU A2, V0, ZERO
9D0012A0  0F40350B   JAL _sprintf_cdfFnopsuxX
9D0012A4  00000000   NOP
317:                 
318:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D0012A8  27C201E4   ADDIU V0, FP, 484
9D0012AC  00402021   ADDU A0, V0, ZERO
9D0012B0  0F402789   JAL strlen
9D0012B4  00000000   NOP
9D0012B8  304200FF   ANDI V0, V0, 255
9D0012BC  27C301E4   ADDIU V1, FP, 484
9D0012C0  00602021   ADDU A0, V1, ZERO
9D0012C4  00402821   ADDU A1, V0, ZERO
9D0012C8  0F403051   JAL SendUSBMessage
9D0012CC  00000000   NOP
319:                             SendUSBMessage(Line2, strlen((char*)Line2));
9D0012D0  27C20204   ADDIU V0, FP, 516
9D0012D4  00402021   ADDU A0, V0, ZERO
9D0012D8  0F402789   JAL strlen
9D0012DC  00000000   NOP
9D0012E0  304200FF   ANDI V0, V0, 255
9D0012E4  27C30204   ADDIU V1, FP, 516
9D0012E8  00602021   ADDU A0, V1, ZERO
9D0012EC  00402821   ADDU A1, V0, ZERO
9D0012F0  0F403051   JAL SendUSBMessage
9D0012F4  00000000   NOP
320:                             SendUSBMessage(Line3, strlen((char*)Line3));
9D0012F8  27C20224   ADDIU V0, FP, 548
9D0012FC  00402021   ADDU A0, V0, ZERO
9D001300  0F402789   JAL strlen
9D001304  00000000   NOP
9D001308  304200FF   ANDI V0, V0, 255
9D00130C  27C30224   ADDIU V1, FP, 548
9D001310  00602021   ADDU A0, V1, ZERO
9D001314  00402821   ADDU A1, V0, ZERO
9D001318  0F403051   JAL SendUSBMessage
9D00131C  00000000   NOP
321:                             SendUSBMessage(Line4, strlen((char*)Line4));
9D001320  27C20244   ADDIU V0, FP, 580
9D001324  00402021   ADDU A0, V0, ZERO
9D001328  0F402789   JAL strlen
9D00132C  00000000   NOP
9D001330  304200FF   ANDI V0, V0, 255
9D001334  27C30244   ADDIU V1, FP, 580
9D001338  00602021   ADDU A0, V1, ZERO
9D00133C  00402821   ADDU A1, V0, ZERO
9D001340  0F403051   JAL SendUSBMessage
9D001344  00000000   NOP
322:                             SendUSBMessage(Line5, strlen((char*)Line5));
9D001348  27C20264   ADDIU V0, FP, 612
9D00134C  00402021   ADDU A0, V0, ZERO
9D001350  0F402789   JAL strlen
9D001354  00000000   NOP
9D001358  304200FF   ANDI V0, V0, 255
9D00135C  27C30264   ADDIU V1, FP, 612
9D001360  00602021   ADDU A0, V1, ZERO
9D001364  00402821   ADDU A1, V0, ZERO
9D001368  0F403051   JAL SendUSBMessage
9D00136C  00000000   NOP
323:                             
324:                             MenuStatus = Domoticz_Set;
9D001370  2402000C   ADDIU V0, ZERO, 12
9D001374  AF828034   SW V0, -32716(GP)
325:                 
326:                             break;
9D001378  00000000   NOP
9D00137C  0B40070F   J 0x9D001C3C
9D001380  00000000   NOP
327:                         }
328:                         case Domo_IP_Set: 
329:                         {
330:                             int8_t Line1[] = "Entrez la nouvelle IP : ";
9D001384  3C029D00   LUI V0, -25344
9D001388  8C483D80   LW T0, 15744(V0)
9D00138C  24433D80   ADDIU V1, V0, 15744
9D001390  8C670004   LW A3, 4(V1)
9D001394  24433D80   ADDIU V1, V0, 15744
9D001398  8C660008   LW A2, 8(V1)
9D00139C  24433D80   ADDIU V1, V0, 15744
9D0013A0  8C65000C   LW A1, 12(V1)
9D0013A4  24433D80   ADDIU V1, V0, 15744
9D0013A8  8C640010   LW A0, 16(V1)
9D0013AC  24433D80   ADDIU V1, V0, 15744
9D0013B0  8C630014   LW V1, 20(V1)
9D0013B4  AFC80284   SW T0, 644(FP)
9D0013B8  AFC70288   SW A3, 648(FP)
9D0013BC  AFC6028C   SW A2, 652(FP)
9D0013C0  AFC50290   SW A1, 656(FP)
9D0013C4  AFC40294   SW A0, 660(FP)
9D0013C8  AFC30298   SW V1, 664(FP)
9D0013CC  24423D80   ADDIU V0, V0, 15744
9D0013D0  90420018   LBU V0, 24(V0)
9D0013D4  A3C2029C   SB V0, 668(FP)
331:                             
332:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D0013D8  27C20284   ADDIU V0, FP, 644
9D0013DC  00402021   ADDU A0, V0, ZERO
9D0013E0  0F402789   JAL strlen
9D0013E4  00000000   NOP
9D0013E8  304200FF   ANDI V0, V0, 255
9D0013EC  27C30284   ADDIU V1, FP, 644
9D0013F0  00602021   ADDU A0, V1, ZERO
9D0013F4  00402821   ADDU A1, V0, ZERO
9D0013F8  0F403051   JAL SendUSBMessage
9D0013FC  00000000   NOP
333:                             MenuStatus = Domo_IP_Get;
9D001400  24020010   ADDIU V0, ZERO, 16
9D001404  AF828034   SW V0, -32716(GP)
334:                             break;
9D001408  00000000   NOP
9D00140C  0B40070F   J 0x9D001C3C
9D001410  00000000   NOP
335:                         }
336:                         case Domo_IP_Get: 
337:                         {
338:                             int8_t nIP[100]={0};
9D001414  27C303A0   ADDIU V1, FP, 928
9D001418  24020064   ADDIU V0, ZERO, 100
9D00141C  00602021   ADDU A0, V1, ZERO
9D001420  00002821   ADDU A1, ZERO, ZERO
9D001424  00403021   ADDU A2, V0, ZERO
9D001428  0F4031E5   JAL .LFE4, memset
9D00142C  00000000   NOP
339:                             
340:                             if(GetUSBMessage(nIP, "\r") == OK)
9D001430  27C203A0   ADDIU V0, FP, 928
9D001434  00402021   ADDU A0, V0, ZERO
9D001438  3C029D00   LUI V0, -25344
9D00143C  2445393C   ADDIU A1, V0, 14652
9D001440  0F402221   JAL GetUSBMessage
9D001444  00000000   NOP
9D001448  14400028   BNE V0, ZERO, .LBE21
9D00144C  00000000   NOP
341:                             {
342:                                 memmove(Wifi.IPDom, nIP, sizeof(nIP));
9D001450  3C02A000   LUI V0, -24576
9D001454  244203BC   ADDIU V0, V0, 956
9D001458  244400C8   ADDIU A0, V0, 200
9D00145C  27C303A0   ADDIU V1, FP, 928
9D001460  24020064   ADDIU V0, ZERO, 100
9D001464  00602821   ADDU A1, V1, ZERO
9D001468  00403021   ADDU A2, V0, ZERO
9D00146C  0F40272F   JAL .LFE1156, memcpy
9D001470  00000000   NOP
343:                                 
344:                                 int8_t Line1[] = "Nouvel IP enregistre!\r\n";
9D001474  3C029D00   LUI V0, -25344
9D001478  8C473D9C   LW A3, 15772(V0)
9D00147C  24433D9C   ADDIU V1, V0, 15772
9D001480  8C660004   LW A2, 4(V1)
9D001484  24433D9C   ADDIU V1, V0, 15772
9D001488  8C650008   LW A1, 8(V1)
9D00148C  24433D9C   ADDIU V1, V0, 15772
9D001490  8C64000C   LW A0, 12(V1)
9D001494  24433D9C   ADDIU V1, V0, 15772
9D001498  8C630010   LW V1, 16(V1)
9D00149C  24423D9C   ADDIU V0, V0, 15772
9D0014A0  8C420014   LW V0, 20(V0)
9D0014A4  AFC702A0   SW A3, 672(FP)
9D0014A8  AFC602A4   SW A2, 676(FP)
9D0014AC  AFC502A8   SW A1, 680(FP)
9D0014B0  AFC402AC   SW A0, 684(FP)
9D0014B4  AFC302B0   SW V1, 688(FP)
9D0014B8  AFC202B4   SW V0, 692(FP)
345:                                 SendUSBMessage(Line1, strlen((char*)Line1));
9D0014BC  27C202A0   ADDIU V0, FP, 672
9D0014C0  00402021   ADDU A0, V0, ZERO
9D0014C4  0F402789   JAL strlen
9D0014C8  00000000   NOP
9D0014CC  304200FF   ANDI V0, V0, 255
9D0014D0  27C302A0   ADDIU V1, FP, 672
9D0014D4  00602021   ADDU A0, V1, ZERO
9D0014D8  00402821   ADDU A1, V0, ZERO
9D0014DC  0F403051   JAL SendUSBMessage
9D0014E0  00000000   NOP
346:                                 MenuStatus = Domoticz_Set;
9D0014E4  2402000C   ADDIU V0, ZERO, 12
9D0014E8  AF828034   SW V0, -32716(GP)
347:                             }
348:                             break;
9D0014EC  00000000   NOP
9D0014F0  0B40070F   J 0x9D001C3C
9D0014F4  00000000   NOP
349:                         }
350:                         case Domo_Port_Set: 
351:                         {
352:                             int8_t Line1[] = "Entrez le nouveau port : ";
9D0014F8  3C029D00   LUI V0, -25344
9D0014FC  8C483DB4   LW T0, 15796(V0)
9D001500  24433DB4   ADDIU V1, V0, 15796
9D001504  8C670004   LW A3, 4(V1)
9D001508  24433DB4   ADDIU V1, V0, 15796
9D00150C  8C660008   LW A2, 8(V1)
9D001510  24433DB4   ADDIU V1, V0, 15796
9D001514  8C65000C   LW A1, 12(V1)
9D001518  24433DB4   ADDIU V1, V0, 15796
9D00151C  8C640010   LW A0, 16(V1)
9D001520  24433DB4   ADDIU V1, V0, 15796
9D001524  8C630014   LW V1, 20(V1)
9D001528  AFC802B8   SW T0, 696(FP)
9D00152C  AFC702BC   SW A3, 700(FP)
9D001530  AFC602C0   SW A2, 704(FP)
9D001534  AFC502C4   SW A1, 708(FP)
9D001538  AFC402C8   SW A0, 712(FP)
9D00153C  AFC302CC   SW V1, 716(FP)
9D001540  24423DB4   ADDIU V0, V0, 15796
9D001544  94420018   LHU V0, 24(V0)
9D001548  A7C202D0   SH V0, 720(FP)
353:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D00154C  27C202B8   ADDIU V0, FP, 696
9D001550  00402021   ADDU A0, V0, ZERO
9D001554  0F402789   JAL strlen
9D001558  00000000   NOP
9D00155C  304200FF   ANDI V0, V0, 255
9D001560  27C302B8   ADDIU V1, FP, 696
9D001564  00602021   ADDU A0, V1, ZERO
9D001568  00402821   ADDU A1, V0, ZERO
9D00156C  0F403051   JAL SendUSBMessage
9D001570  00000000   NOP
354:                             
355:                             MenuStatus = Domo_Port_Get;
9D001574  24020012   ADDIU V0, ZERO, 18
9D001578  AF828034   SW V0, -32716(GP)
356:                             break;
9D00157C  00000000   NOP
9D001580  0B40070F   J 0x9D001C3C
9D001584  00000000   NOP
357:                         }
358:                         case Domo_Port_Get: 
359:                         {
360:                             int8_t nPort[100]={0};
9D001588  27C303A0   ADDIU V1, FP, 928
9D00158C  24020064   ADDIU V0, ZERO, 100
9D001590  00602021   ADDU A0, V1, ZERO
9D001594  00002821   ADDU A1, ZERO, ZERO
9D001598  00403021   ADDU A2, V0, ZERO
9D00159C  0F4031E5   JAL .LFE4, memset
9D0015A0  00000000   NOP
361:                             
362:                             if(GetUSBMessage(nPort, "\r") == OK)
9D0015A4  27C203A0   ADDIU V0, FP, 928
9D0015A8  00402021   ADDU A0, V0, ZERO
9D0015AC  3C029D00   LUI V0, -25344
9D0015B0  2445393C   ADDIU A1, V0, 14652
9D0015B4  0F402221   JAL GetUSBMessage
9D0015B8  00000000   NOP
9D0015BC  1440002F   BNE V0, ZERO, .LBE24
9D0015C0  00000000   NOP
363:                             {
364:                                 memmove(Wifi.PortDom, nPort, strlen((char*)nPort));
9D0015C4  27C203A0   ADDIU V0, FP, 928
9D0015C8  00402021   ADDU A0, V0, ZERO
9D0015CC  0F402789   JAL strlen
9D0015D0  00000000   NOP
9D0015D4  3C04A000   LUI A0, -24576
9D0015D8  27C303A0   ADDIU V1, FP, 928
9D0015DC  24840493   ADDIU A0, A0, 1171
9D0015E0  00602821   ADDU A1, V1, ZERO
9D0015E4  00403021   ADDU A2, V0, ZERO
9D0015E8  0F40272F   JAL .LFE1156, memcpy
9D0015EC  00000000   NOP
365:                                 
366:                                 int8_t Line1[] = "Nouveau port enregistre!\r\n";
9D0015F0  3C029D00   LUI V0, -25344
9D0015F4  8C483DD0   LW T0, 15824(V0)
9D0015F8  24433DD0   ADDIU V1, V0, 15824
9D0015FC  8C670004   LW A3, 4(V1)
9D001600  24433DD0   ADDIU V1, V0, 15824
9D001604  8C660008   LW A2, 8(V1)
9D001608  24433DD0   ADDIU V1, V0, 15824
9D00160C  8C65000C   LW A1, 12(V1)
9D001610  24433DD0   ADDIU V1, V0, 15824
9D001614  8C640010   LW A0, 16(V1)
9D001618  24433DD0   ADDIU V1, V0, 15824
9D00161C  8C630014   LW V1, 20(V1)
9D001620  AFC802D4   SW T0, 724(FP)
9D001624  AFC702D8   SW A3, 728(FP)
9D001628  AFC602DC   SW A2, 732(FP)
9D00162C  AFC502E0   SW A1, 736(FP)
9D001630  AFC402E4   SW A0, 740(FP)
9D001634  AFC302E8   SW V1, 744(FP)
9D001638  24423DD0   ADDIU V0, V0, 15824
9D00163C  94430018   LHU V1, 24(V0)
9D001640  A7C302EC   SH V1, 748(FP)
9D001644  9042001A   LBU V0, 26(V0)
9D001648  A3C202EE   SB V0, 750(FP)
367:                                 SendUSBMessage(Line1, strlen((char*)Line1));
9D00164C  27C202D4   ADDIU V0, FP, 724
9D001650  00402021   ADDU A0, V0, ZERO
9D001654  0F402789   JAL strlen
9D001658  00000000   NOP
9D00165C  304200FF   ANDI V0, V0, 255
9D001660  27C302D4   ADDIU V1, FP, 724
9D001664  00602021   ADDU A0, V1, ZERO
9D001668  00402821   ADDU A1, V0, ZERO
9D00166C  0F403051   JAL SendUSBMessage
9D001670  00000000   NOP
368:                                 MenuStatus = Domoticz_Set;
9D001674  2402000C   ADDIU V0, ZERO, 12
9D001678  AF828034   SW V0, -32716(GP)
369:                             }
370:                             break;
9D00167C  00000000   NOP
9D001680  0B40070F   J 0x9D001C3C
9D001684  00000000   NOP
371:                         }
372:                         case Domo_Index_Set: 
373:                         {
374:                             int8_t Line1[] = "Entrez le nouvel index : ";
9D001688  3C029D00   LUI V0, -25344
9D00168C  8C483DEC   LW T0, 15852(V0)
9D001690  24433DEC   ADDIU V1, V0, 15852
9D001694  8C670004   LW A3, 4(V1)
9D001698  24433DEC   ADDIU V1, V0, 15852
9D00169C  8C660008   LW A2, 8(V1)
9D0016A0  24433DEC   ADDIU V1, V0, 15852
9D0016A4  8C65000C   LW A1, 12(V1)
9D0016A8  24433DEC   ADDIU V1, V0, 15852
9D0016AC  8C640010   LW A0, 16(V1)
9D0016B0  24433DEC   ADDIU V1, V0, 15852
9D0016B4  8C630014   LW V1, 20(V1)
9D0016B8  AFC802F0   SW T0, 752(FP)
9D0016BC  AFC702F4   SW A3, 756(FP)
9D0016C0  AFC602F8   SW A2, 760(FP)
9D0016C4  AFC502FC   SW A1, 764(FP)
9D0016C8  AFC40300   SW A0, 768(FP)
9D0016CC  AFC30304   SW V1, 772(FP)
9D0016D0  24423DEC   ADDIU V0, V0, 15852
9D0016D4  94420018   LHU V0, 24(V0)
9D0016D8  A7C20308   SH V0, 776(FP)
375:                             
376:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D0016DC  27C202F0   ADDIU V0, FP, 752
9D0016E0  00402021   ADDU A0, V0, ZERO
9D0016E4  0F402789   JAL strlen
9D0016E8  00000000   NOP
9D0016EC  304200FF   ANDI V0, V0, 255
9D0016F0  27C302F0   ADDIU V1, FP, 752
9D0016F4  00602021   ADDU A0, V1, ZERO
9D0016F8  00402821   ADDU A1, V0, ZERO
9D0016FC  0F403051   JAL SendUSBMessage
9D001700  00000000   NOP
377:                             MenuStatus = Domo_Index_Get;
9D001704  24020014   ADDIU V0, ZERO, 20
9D001708  AF828034   SW V0, -32716(GP)
378:                             break;
9D00170C  00000000   NOP
9D001710  0B40070F   J 0x9D001C3C
9D001714  00000000   NOP
379:                         }
380:                         case Domo_Index_Get: 
381:                         {
382:                             int8_t nIndex[5]={0};
9D001718  AFC0030C   SW ZERO, 780(FP)
9D00171C  A3C00310   SB ZERO, 784(FP)
383:                             
384:                             if(GetUSBMessage(nIndex, "\r") == OK)
9D001720  27C2030C   ADDIU V0, FP, 780
9D001724  00402021   ADDU A0, V0, ZERO
9D001728  3C029D00   LUI V0, -25344
9D00172C  2445393C   ADDIU A1, V0, 14652
9D001730  0F402221   JAL GetUSBMessage
9D001734  00000000   NOP
9D001738  1440002B   BNE V0, ZERO, .LBE27
9D00173C  00000000   NOP
385:                             {
386:                                 BME280.Index = atoi((char*)nIndex);
9D001740  27C2030C   ADDIU V0, FP, 780
9D001744  00402021   ADDU A0, V0, ZERO
9D001748  0F40320F   JAL atoi
9D00174C  00000000   NOP
9D001750  304300FF   ANDI V1, V0, 255
9D001754  3C02A000   LUI V0, -24576
9D001758  A0430270   SB V1, 624(V0)
387:                                 
388:                                 int8_t Line1[] = "Nouvel index enregistre!\r\n";
9D00175C  3C029D00   LUI V0, -25344
9D001760  8C483E08   LW T0, 15880(V0)
9D001764  24433E08   ADDIU V1, V0, 15880
9D001768  8C670004   LW A3, 4(V1)
9D00176C  24433E08   ADDIU V1, V0, 15880
9D001770  8C660008   LW A2, 8(V1)
9D001774  24433E08   ADDIU V1, V0, 15880
9D001778  8C65000C   LW A1, 12(V1)
9D00177C  24433E08   ADDIU V1, V0, 15880
9D001780  8C640010   LW A0, 16(V1)
9D001784  24433E08   ADDIU V1, V0, 15880
9D001788  8C630014   LW V1, 20(V1)
9D00178C  AFC80314   SW T0, 788(FP)
9D001790  AFC70318   SW A3, 792(FP)
9D001794  AFC6031C   SW A2, 796(FP)
9D001798  AFC50320   SW A1, 800(FP)
9D00179C  AFC40324   SW A0, 804(FP)
9D0017A0  AFC30328   SW V1, 808(FP)
9D0017A4  24423E08   ADDIU V0, V0, 15880
9D0017A8  94430018   LHU V1, 24(V0)
9D0017AC  A7C3032C   SH V1, 812(FP)
9D0017B0  9042001A   LBU V0, 26(V0)
9D0017B4  A3C2032E   SB V0, 814(FP)
389:                                 SendUSBMessage(Line1, strlen((char*)Line1));
9D0017B8  27C20314   ADDIU V0, FP, 788
9D0017BC  00402021   ADDU A0, V0, ZERO
9D0017C0  0F402789   JAL strlen
9D0017C4  00000000   NOP
9D0017C8  304200FF   ANDI V0, V0, 255
9D0017CC  27C30314   ADDIU V1, FP, 788
9D0017D0  00602021   ADDU A0, V1, ZERO
9D0017D4  00402821   ADDU A1, V0, ZERO
9D0017D8  0F403051   JAL SendUSBMessage
9D0017DC  00000000   NOP
390:                                 
391:                                 MenuStatus = Domoticz_Set;
9D0017E0  2402000C   ADDIU V0, ZERO, 12
9D0017E4  AF828034   SW V0, -32716(GP)
392:                             }
393:                             break;
9D0017E8  00000000   NOP
9D0017EC  0B40070F   J 0x9D001C3C
9D0017F0  00000000   NOP
394:                         }
395:                         case Interval_Set: 
396:                         {
397:                             int8_t Line1[] = "Combien de temps voulez-vous entre chaque mesure? [min] : ";
9D0017F4  3C029D00   LUI V0, -25344
9D0017F8  27C403A0   ADDIU A0, FP, 928
9D0017FC  24433E24   ADDIU V1, V0, 15908
9D001800  2402003B   ADDIU V0, ZERO, 59
9D001804  00602821   ADDU A1, V1, ZERO
9D001808  00403021   ADDU A2, V0, ZERO
9D00180C  0F40272F   JAL .LFE1156, memcpy
9D001810  00000000   NOP
398:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D001814  27C203A0   ADDIU V0, FP, 928
9D001818  00402021   ADDU A0, V0, ZERO
9D00181C  0F402789   JAL strlen
9D001820  00000000   NOP
9D001824  304200FF   ANDI V0, V0, 255
9D001828  27C303A0   ADDIU V1, FP, 928
9D00182C  00602021   ADDU A0, V1, ZERO
9D001830  00402821   ADDU A1, V0, ZERO
9D001834  0F403051   JAL SendUSBMessage
9D001838  00000000   NOP
399:                             
400:                             MenuStatus = Interval_Get;
9D00183C  24020016   ADDIU V0, ZERO, 22
9D001840  AF828034   SW V0, -32716(GP)
401:                             break;
9D001844  00000000   NOP
9D001848  0B40070F   J 0x9D001C3C
9D00184C  00000000   NOP
402:                         }
403:                         case Interval_Get: 
404:                         {
405:                             int8_t nInterval[5]={0};
9D001850  AFC00330   SW ZERO, 816(FP)
9D001854  A3C00334   SB ZERO, 820(FP)
406:                             uint8_t Intervalmin = 0;
9D001858  A3C00011   SB ZERO, 17(FP)
407:                             
408:                             if(GetUSBMessage(nInterval, "\r") == OK)
9D00185C  27C20330   ADDIU V0, FP, 816
9D001860  00402021   ADDU A0, V0, ZERO
9D001864  3C029D00   LUI V0, -25344
9D001868  2445393C   ADDIU A1, V0, 14652
9D00186C  0F402221   JAL GetUSBMessage
9D001870  00000000   NOP
9D001874  14400024   BNE V0, ZERO, .LBE30
9D001878  00000000   NOP
409:                             {
410:                                 Intervalmin = atoi((char*)nInterval);
9D00187C  27C20330   ADDIU V0, FP, 816
9D001880  00402021   ADDU A0, V0, ZERO
9D001884  0F40320F   JAL atoi
9D001888  00000000   NOP
9D00188C  A3C20011   SB V0, 17(FP)
411:                                 
412:                                 ESP8266.Interval = (20*60*Intervalmin); 
9D001890  93C20011   LBU V0, 17(FP)
9D001894  00021100   SLL V0, V0, 4
9D001898  00021880   SLL V1, V0, 2
9D00189C  00431021   ADDU V0, V0, V1
9D0018A0  00021900   SLL V1, V0, 4
9D0018A4  00621023   SUBU V0, V1, V0
9D0018A8  00401821   ADDU V1, V0, ZERO
9D0018AC  3C02A000   LUI V0, -24576
9D0018B0  24420244   ADDIU V0, V0, 580
9D0018B4  AC430020   SW V1, 32(V0)
413:                                 
414:                                 int8_t Line1[50];
415:                                 sprintf((char*)Line1, "Les mesures se feront toutes les %dmin\r\n", Intervalmin);
9D0018B8  93C20011   LBU V0, 17(FP)
9D0018BC  27C303A0   ADDIU V1, FP, 928
9D0018C0  00602021   ADDU A0, V1, ZERO
9D0018C4  3C039D00   LUI V1, -25344
9D0018C8  24653994   ADDIU A1, V1, 14740
9D0018CC  00403021   ADDU A2, V0, ZERO
9D0018D0  0F40350B   JAL _sprintf_cdfFnopsuxX
9D0018D4  00000000   NOP
416:                                 SendUSBMessage(Line1, strlen((char*)Line1));
9D0018D8  27C203A0   ADDIU V0, FP, 928
9D0018DC  00402021   ADDU A0, V0, ZERO
9D0018E0  0F402789   JAL strlen
9D0018E4  00000000   NOP
9D0018E8  304200FF   ANDI V0, V0, 255
9D0018EC  27C303A0   ADDIU V1, FP, 928
9D0018F0  00602021   ADDU A0, V1, ZERO
9D0018F4  00402821   ADDU A1, V0, ZERO
9D0018F8  0F403051   JAL SendUSBMessage
9D0018FC  00000000   NOP
417:                                 
418:                                 MenuStatus = Menu_Set;
9D001900  24020003   ADDIU V0, ZERO, 3
9D001904  AF828034   SW V0, -32716(GP)
419:                             }
420:                             break;
9D001908  00000000   NOP
9D00190C  0B40070F   J 0x9D001C3C
9D001910  00000000   NOP
421:                         }
422:                         case Measure: 
423:                         {
424:                             int8_t Line1[30];
425:                             int8_t Line2[30];
426:                             int8_t Line3[30];
427:                             
428:                             if(BME280.Temperature != 0 && BME280.Humidite != 0 && BME280.Pression != 0)
9D001914  3C02A000   LUI V0, -24576
9D001918  24420270   ADDIU V0, V0, 624
9D00191C  8C420004   LW V0, 4(V0)
9D001920  00402021   ADDU A0, V0, ZERO
9D001924  00002821   ADDU A1, ZERO, ZERO
9D001928  0F40328A   JAL __ltsf2
9D00192C  00000000   NOP
9D001930  1040005A   BEQ V0, ZERO, .LBB32
9D001934  00000000   NOP
9D001938  3C02A000   LUI V0, -24576
9D00193C  24420270   ADDIU V0, V0, 624
9D001940  8C420008   LW V0, 8(V0)
9D001944  00402021   ADDU A0, V0, ZERO
9D001948  00002821   ADDU A1, ZERO, ZERO
9D00194C  0F40328A   JAL __ltsf2
9D001950  00000000   NOP
9D001954  10400051   BEQ V0, ZERO, .LBB32
9D001958  00000000   NOP
9D00195C  3C02A000   LUI V0, -24576
9D001960  24420270   ADDIU V0, V0, 624
9D001964  8C420010   LW V0, 16(V0)
9D001968  00402021   ADDU A0, V0, ZERO
9D00196C  00002821   ADDU A1, ZERO, ZERO
9D001970  0F40328A   JAL __ltsf2
9D001974  00000000   NOP
9D001978  10400048   BEQ V0, ZERO, .LBB32
9D00197C  00000000   NOP
429:                             {
430:                                 sprintf((char*)Line1, "Il fait actuellement %.1f C\r\n", (double)BME280.Temperature);
9D001980  3C02A000   LUI V0, -24576
9D001984  24420270   ADDIU V0, V0, 624
9D001988  8C420004   LW V0, 4(V0)
9D00198C  00402021   ADDU A0, V0, ZERO
9D001990  0F403166   JAL __extendsfdf2
9D001994  00000000   NOP
9D001998  27C40338   ADDIU A0, FP, 824
9D00199C  3C059D00   LUI A1, -25344
9D0019A0  24A539C0   ADDIU A1, A1, 14784
9D0019A4  00403021   ADDU A2, V0, ZERO
9D0019A8  00603821   ADDU A3, V1, ZERO
9D0019AC  0F40350B   JAL _sprintf_cdfFnopsuxX
9D0019B0  00000000   NOP
431:                                 sprintf((char*)Line2, "L'humidite est de %.1f %%\r\n", (double)BME280.Humidite);
9D0019B4  3C02A000   LUI V0, -24576
9D0019B8  24420270   ADDIU V0, V0, 624
9D0019BC  8C420008   LW V0, 8(V0)
9D0019C0  00402021   ADDU A0, V0, ZERO
9D0019C4  0F403166   JAL __extendsfdf2
9D0019C8  00000000   NOP
9D0019CC  27C40358   ADDIU A0, FP, 856
9D0019D0  3C059D00   LUI A1, -25344
9D0019D4  24A539E0   ADDIU A1, A1, 14816
9D0019D8  00403021   ADDU A2, V0, ZERO
9D0019DC  00603821   ADDU A3, V1, ZERO
9D0019E0  0F40350B   JAL _sprintf_cdfFnopsuxX
9D0019E4  00000000   NOP
432:                                 sprintf((char*)Line3, "Et la pression est de %.1f hPa\r\n\r\n", (double)BME280.Pression);
9D0019E8  3C02A000   LUI V0, -24576
9D0019EC  24420270   ADDIU V0, V0, 624
9D0019F0  8C420010   LW V0, 16(V0)
9D0019F4  00402021   ADDU A0, V0, ZERO
9D0019F8  0F403166   JAL __extendsfdf2
9D0019FC  00000000   NOP
9D001A00  27C40378   ADDIU A0, FP, 888
9D001A04  3C059D00   LUI A1, -25344
9D001A08  24A539FC   ADDIU A1, A1, 14844
9D001A0C  00403021   ADDU A2, V0, ZERO
9D001A10  00603821   ADDU A3, V1, ZERO
9D001A14  0F40350B   JAL _sprintf_cdfFnopsuxX
9D001A18  00000000   NOP
433:                 
434:                                 SendUSBMessage(Line1, strlen((char*)Line1));
9D001A1C  27C20338   ADDIU V0, FP, 824
9D001A20  00402021   ADDU A0, V0, ZERO
9D001A24  0F402789   JAL strlen
9D001A28  00000000   NOP
9D001A2C  304200FF   ANDI V0, V0, 255
9D001A30  27C30338   ADDIU V1, FP, 824
9D001A34  00602021   ADDU A0, V1, ZERO
9D001A38  00402821   ADDU A1, V0, ZERO
9D001A3C  0F403051   JAL SendUSBMessage
9D001A40  00000000   NOP
435:                                 SendUSBMessage(Line2, strlen((char*)Line2));
9D001A44  27C20358   ADDIU V0, FP, 856
9D001A48  00402021   ADDU A0, V0, ZERO
9D001A4C  0F402789   JAL strlen
9D001A50  00000000   NOP
9D001A54  304200FF   ANDI V0, V0, 255
9D001A58  27C30358   ADDIU V1, FP, 856
9D001A5C  00602021   ADDU A0, V1, ZERO
9D001A60  00402821   ADDU A1, V0, ZERO
9D001A64  0F403051   JAL SendUSBMessage
9D001A68  00000000   NOP
436:                                 SendUSBMessage(Line3, strlen((char*)Line3));
9D001A6C  27C20378   ADDIU V0, FP, 888
9D001A70  00402021   ADDU A0, V0, ZERO
9D001A74  0F402789   JAL strlen
9D001A78  00000000   NOP
9D001A7C  304200FF   ANDI V0, V0, 255
9D001A80  27C30378   ADDIU V1, FP, 888
9D001A84  00602021   ADDU A0, V1, ZERO
9D001A88  00402821   ADDU A1, V0, ZERO
9D001A8C  0F403051   JAL SendUSBMessage
9D001A90  00000000   NOP
9D001A94  0B4006B9   J .LVL179, .LBE32
9D001A98  00000000   NOP
437:                             }
438:                             else
439:                             {
440:                                 int8_t Line4[] = "Pour le moment, aucunes mesures n'a ete faite\r\n";
9D001A9C  3C029D00   LUI V0, -25344
9D001AA0  27C403A0   ADDIU A0, FP, 928
9D001AA4  24433E60   ADDIU V1, V0, 15968
9D001AA8  24020030   ADDIU V0, ZERO, 48
9D001AAC  00602821   ADDU A1, V1, ZERO
9D001AB0  00403021   ADDU A2, V0, ZERO
9D001AB4  0F40272F   JAL .LFE1156, memcpy
9D001AB8  00000000   NOP
441:                                 SendUSBMessage(Line4, strlen((char*)Line4));
9D001ABC  27C203A0   ADDIU V0, FP, 928
9D001AC0  00402021   ADDU A0, V0, ZERO
9D001AC4  0F402789   JAL strlen
9D001AC8  00000000   NOP
9D001ACC  304200FF   ANDI V0, V0, 255
9D001AD0  27C303A0   ADDIU V1, FP, 928
9D001AD4  00602021   ADDU A0, V1, ZERO
9D001AD8  00402821   ADDU A1, V0, ZERO
9D001ADC  0F403051   JAL SendUSBMessage
9D001AE0  00000000   NOP
442:                             }
443:                             
444:                             MenuStatus = Menu_Set;
9D001AE4  24020003   ADDIU V0, ZERO, 3
9D001AE8  AF828034   SW V0, -32716(GP)
445:                             break;
9D001AEC  00000000   NOP
9D001AF0  0B40070F   J 0x9D001C3C
9D001AF4  00000000   NOP
446:                         }
447:                         case Altitude_Set:
448:                         {
449:                             int8_t Line1[] = "Entrez votre altitude actuelle [m]: ";
9D001AF8  3C029D00   LUI V0, -25344
9D001AFC  27C403A0   ADDIU A0, FP, 928
9D001B00  24433E90   ADDIU V1, V0, 16016
9D001B04  24020025   ADDIU V0, ZERO, 37
9D001B08  00602821   ADDU A1, V1, ZERO
9D001B0C  00403021   ADDU A2, V0, ZERO
9D001B10  0F40272F   JAL .LFE1156, memcpy
9D001B14  00000000   NOP
450:                             
451:                             SendUSBMessage(Line1, strlen((char*)Line1));
9D001B18  27C203A0   ADDIU V0, FP, 928
9D001B1C  00402021   ADDU A0, V0, ZERO
9D001B20  0F402789   JAL strlen
9D001B24  00000000   NOP
9D001B28  304200FF   ANDI V0, V0, 255
9D001B2C  27C303A0   ADDIU V1, FP, 928
9D001B30  00602021   ADDU A0, V1, ZERO
9D001B34  00402821   ADDU A1, V0, ZERO
9D001B38  0F403051   JAL SendUSBMessage
9D001B3C  00000000   NOP
452:                             MenuStatus = Altitude_Get;
9D001B40  24020019   ADDIU V0, ZERO, 25
9D001B44  AF828034   SW V0, -32716(GP)
453:                             break;
9D001B48  00000000   NOP
9D001B4C  0B40070F   J 0x9D001C3C
9D001B50  00000000   NOP
454:                         }    
455:                         case Altitude_Get:
456:                         {
457:                             int8_t nAltitude[5]={0};
9D001B54  AFC00398   SW ZERO, 920(FP)
9D001B58  A3C0039C   SB ZERO, 924(FP)
458:                             
459:                             if(GetUSBMessage(nAltitude, "\r") == OK)
9D001B5C  27C20398   ADDIU V0, FP, 920
9D001B60  00402021   ADDU A0, V0, ZERO
9D001B64  3C029D00   LUI V0, -25344
9D001B68  2445393C   ADDIU A1, V0, 14652
9D001B6C  0F402221   JAL GetUSBMessage
9D001B70  00000000   NOP
9D001B74  1440002D   BNE V0, ZERO, .LBE35
9D001B78  00000000   NOP
460:                             {
461:                                 BME280.Altitude = atoi((char*)nAltitude);
9D001B7C  27C20398   ADDIU V0, FP, 920
9D001B80  00402021   ADDU A0, V0, ZERO
9D001B84  0F40320F   JAL atoi
9D001B88  00000000   NOP
9D001B8C  3043FFFF   ANDI V1, V0, -1
9D001B90  3C02A000   LUI V0, -24576
9D001B94  24420270   ADDIU V0, V0, 624
9D001B98  A4430016   SH V1, 22(V0)
462:                                 
463:                                 int8_t Line1[] = "Nouvelle altitude enregistre!\r\n";
9D001B9C  3C029D00   LUI V0, -25344
9D001BA0  8C493EB8   LW T1, 16056(V0)
9D001BA4  24433EB8   ADDIU V1, V0, 16056
9D001BA8  8C680004   LW T0, 4(V1)
9D001BAC  24433EB8   ADDIU V1, V0, 16056
9D001BB0  8C670008   LW A3, 8(V1)
9D001BB4  24433EB8   ADDIU V1, V0, 16056
9D001BB8  8C66000C   LW A2, 12(V1)
9D001BBC  24433EB8   ADDIU V1, V0, 16056
9D001BC0  8C650010   LW A1, 16(V1)
9D001BC4  24433EB8   ADDIU V1, V0, 16056
9D001BC8  8C640014   LW A0, 20(V1)
9D001BCC  24433EB8   ADDIU V1, V0, 16056
9D001BD0  8C630018   LW V1, 24(V1)
9D001BD4  24423EB8   ADDIU V0, V0, 16056
9D001BD8  8C42001C   LW V0, 28(V0)
9D001BDC  AFC903A0   SW T1, 928(FP)
9D001BE0  AFC803A4   SW T0, 932(FP)
9D001BE4  AFC703A8   SW A3, 936(FP)
9D001BE8  AFC603AC   SW A2, 940(FP)
9D001BEC  AFC503B0   SW A1, 944(FP)
9D001BF0  AFC403B4   SW A0, 948(FP)
9D001BF4  AFC303B8   SW V1, 952(FP)
9D001BF8  AFC203BC   SW V0, 956(FP)
464:                                 SendUSBMessage(Line1, strlen((char*)Line1));
9D001BFC  27C203A0   ADDIU V0, FP, 928
9D001C00  00402021   ADDU A0, V0, ZERO
9D001C04  0F402789   JAL strlen
9D001C08  00000000   NOP
9D001C0C  304200FF   ANDI V0, V0, 255
9D001C10  27C303A0   ADDIU V1, FP, 928
9D001C14  00602021   ADDU A0, V1, ZERO
9D001C18  00402821   ADDU A1, V0, ZERO
9D001C1C  0F403051   JAL SendUSBMessage
9D001C20  00000000   NOP
465:                                 
466:                                 MenuStatus = Menu_Set;
9D001C24  24020003   ADDIU V0, ZERO, 3
9D001C28  AF828034   SW V0, -32716(GP)
467:                             }
468:                             break;
9D001C2C  00000000   NOP
9D001C30  0B40070F   J 0x9D001C3C
9D001C34  00000000   NOP
469:                         }    
470:                         default:
471:                             break;
9D001C38  00000000   NOP
472:                     }
473:                     APP_UpdateState(APP_STATE_WAIT);
9D001C3C  24040001   ADDIU A0, ZERO, 1
9D001C40  0F403724   JAL APP_UpdateState
9D001C44  00000000   NOP
474:                 }
9D001C48  03C0E821   ADDU SP, FP, ZERO
9D001C4C  8FBF04AC   LW RA, 1196(SP)
9D001C50  8FBE04A8   LW FP, 1192(SP)
9D001C54  27BD04B0   ADDIU SP, SP, 1200
9D001C58  03E00008   JR RA
9D001C5C  00000000   NOP
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/mc32nvmutil.c  -------------
1:                   // Mc32NVMUtil.C
2:                   // Utilitaire  NVM
3:                   //
4:                   //	Description : 	fonctions access NVM
5:                   //	Auteur 		: 	C. HUBER
6:                   //      Cration	: 	17.02.2015
7:                   //      Sur la base de l'exemple Harmony sous :
8:                   //      C:\microchip\harmony\v1_00\apps\examples\peripheral\nvm\flash_modify
9:                   //
10:                  //  LISTE DES MODIFICATIONS :
11:                  //      24.03.2016  CHR  correction dans NVMpageErase
12:                  //      
13:                  //
14:                  //      Version KIT     PCB 11020_B
15:                  //	Version		:	V1.6
16:                  //	Compilateur	:	XC32 V1.40 + Harmony 1.06
17:                  /*--------------------------------------------------------*/
18:                  
19:                  
20:                  
21:                  #include "Mc32NVMUtil.h"
22:                  #include "peripheral\NVM\plib_nvm.h"
23:                  #include <sys/kmem.h>
24:                  //#include "bsp_config.h"
25:                  
26:                  // Row dans flash pour data
27:                  const uint32_t  eedata_addr[DEVICE_ROW_SIZE_DIVIDED_BY_4 ] __attribute__((aligned(4096), space(prog)));
28:                  
29:                  // Zone ram source pour copie row
30:                  uint32_t databuff[DEVICE_ROW_SIZE_DIVIDED_BY_4] __attribute__((coherent));
31:                  
32:                  
33:                  
34:                  void Init_DataBuff(void)
35:                  {
00000000  00000000   NOP
36:                      int i;
37:                      for (i= 0 ; i < DEVICE_ROW_SIZE_DIVIDED_BY_4 ; i++) {
0000000C  00000000   NOP
00000044  00000000   NOP
38:                          databuff[i] = i * 10;
00000018  00000000   NOP
39:                      }
40:                  }
00000060  00000000   NOP
41:                  
42:                  
43:                  //*****************************************************************************
44:                  /*
45:                    Function:
46:                      uint32_t virtualToPhysical (uint32_t address)
47:                  
48:                    Summary:
49:                      Converts a virtual memory address to a physical one
50:                  */
51:                  uint32_t virtualToPhysical(uint32_t address)
52:                  {
9D00DCE8  27BDFFF8   ADDIU SP, SP, -8
9D00DCEC  AFBE0004   SW FP, 4(SP)
9D00DCF0  03A0F021   ADDU FP, SP, ZERO
9D00DCF4  AFC40008   SW A0, 8(FP)
53:                     return (address & 0x1FFFFFFF);
9D00DCF8  8FC20008   LW V0, 8(FP)
9D00DCFC  7C42E000   EXT V0, V0, 0, 29
54:                  }
9D00DD00  03C0E821   ADDU SP, FP, ZERO
9D00DD04  8FBE0004   LW FP, 4(SP)
9D00DD08  27BD0008   ADDIU SP, SP, 8
9D00DD0C  03E00008   JR RA
9D00DD10  00000000   NOP
55:                  
56:                  //******************************************************************************
57:                  /*
58:                    Function:
59:                      void NVMpageErase (uint32_t address)
60:                  
61:                    Summary:
62:                      Erases a page in flash memory (4 KB)
63:                  */
64:                  void NVMpageErase(uint32_t address)
65:                  {
9D00A95C  27BDFFE0   ADDIU SP, SP, -32
9D00A960  AFBF001C   SW RA, 28(SP)
9D00A964  AFBE0018   SW FP, 24(SP)
9D00A968  03A0F021   ADDU FP, SP, ZERO
9D00A96C  AFC40020   SW A0, 32(FP)
66:                     bool status;
67:                      
68:                     // Base address of page to be erased
69:                     PLIB_NVM_FlashAddressToModify(NVM_ID_0, virtualToPhysical(address));
9D00A970  8FC40020   LW A0, 32(FP)
9D00A974  0F40373A   JAL virtualToPhysical
9D00A978  00000000   NOP
9D00A97C  3C03BF80   LUI V1, -16512
9D00A980  3464F400   ORI A0, V1, -3072
9D00A984  00402821   ADDU A1, V0, ZERO
9D00A988  0F4038D8   JAL PLIB_NVM_FlashAddressToModify
9D00A98C  00000000   NOP
70:                     
71:                     // Disable flash write/erase operations
72:                     PLIB_NVM_MemoryModifyInhibit(NVM_ID_0);
9D00A990  3C02BF80   LUI V0, -16512
9D00A994  3444F400   ORI A0, V0, -3072
9D00A998  0F403871   JAL PLIB_NVM_MemoryModifyInhibit
9D00A99C  00000000   NOP
73:                  
74:                     // Select page erase function & enable flash write/erase operations
75:                     PLIB_NVM_MemoryOperationSelect(NVM_ID_0, PAGE_ERASE_OPERATION);
9D00A9A0  3C02BF80   LUI V0, -16512
9D00A9A4  3444F400   ORI A0, V0, -3072
9D00A9A8  24050004   ADDIU A1, ZERO, 4
9D00A9AC  0F403843   JAL PLIB_NVM_MemoryOperationSelect
9D00A9B0  00000000   NOP
76:                  
77:                     // Allow memory modifications
78:                     PLIB_NVM_MemoryModifyEnable(NVM_ID_0);
9D00A9B4  3C02BF80   LUI V0, -16512
9D00A9B8  3444F400   ORI A0, V0, -3072
9D00A9BC  0F40386C   JAL PLIB_NVM_MemoryModifyEnable
9D00A9C0  00000000   NOP
79:                  
80:                     // Write the unlock key sequence
81:                     PLIB_NVM_FlashWriteKeySequence(NVM_ID_0, 0x0);
9D00A9C4  3C02BF80   LUI V0, -16512
9D00A9C8  3444F400   ORI A0, V0, -3072
9D00A9CC  00002821   ADDU A1, ZERO, ZERO
9D00A9D0  0F4038DC   JAL PLIB_NVM_FlashWriteKeySequence
9D00A9D4  00000000   NOP
82:                     PLIB_NVM_FlashWriteKeySequence(NVM_ID_0, 0xAA996655);
9D00A9D8  3C02BF80   LUI V0, -16512
9D00A9DC  3444F400   ORI A0, V0, -3072
9D00A9E0  3C02AA99   LUI V0, -21863
9D00A9E4  34456655   ORI A1, V0, 26197
9D00A9E8  0F4038DC   JAL PLIB_NVM_FlashWriteKeySequence
9D00A9EC  00000000   NOP
83:                     PLIB_NVM_FlashWriteKeySequence(NVM_ID_0, 0x556699AA);
9D00A9F0  3C02BF80   LUI V0, -16512
9D00A9F4  3444F400   ORI A0, V0, -3072
9D00A9F8  3C025566   LUI V0, 21862
9D00A9FC  344599AA   ORI A1, V0, -26198
9D00AA00  0F4038DC   JAL PLIB_NVM_FlashWriteKeySequence
9D00AA04  00000000   NOP
84:                  
85:                     // Start the operation
86:                     // PLIB_NVM_FlashWriteStart(NVM_ID_0);
87:                     PLIB_NVM_FlashEraseStart(NVM_ID_0);   // CHR correction du 24.03.2016
9D00AA08  3C02BF80   LUI V0, -16512
9D00AA0C  3444F400   ORI A0, V0, -3072
9D00AA10  0F40387B   JAL PLIB_NVM_FlashEraseStart
9D00AA14  00000000   NOP
88:                  
89:                     // Wait until the operation has completed
90:                     do {
91:                         status = PLIB_NVM_FlashWriteCycleHasCompleted(NVM_ID_0);
9D00AA18  3C02BF80   LUI V0, -16512
9D00AA1C  3444F400   ORI A0, V0, -3072
9D00AA20  0F403880   JAL PLIB_NVM_FlashWriteCycleHasCompleted
9D00AA24  00000000   NOP
9D00AA28  A3C20010   SB V0, 16(FP)
92:                     }  while (status == false);
9D00AA2C  93C20010   LBU V0, 16(FP)
9D00AA30  38420001   XORI V0, V0, 1
9D00AA34  304200FF   ANDI V0, V0, 255
9D00AA38  1440FFF7   BNE V0, ZERO, .LVL13
9D00AA3C  00000000   NOP
93:                  
94:                     // Disable flash write/erase operations
95:                     PLIB_NVM_MemoryModifyInhibit(NVM_ID_0);
9D00AA40  3C02BF80   LUI V0, -16512
9D00AA44  3444F400   ORI A0, V0, -3072
9D00AA48  0F403871   JAL PLIB_NVM_MemoryModifyInhibit
9D00AA4C  00000000   NOP
96:                     
97:                     // Test si l'action c'est termine prematurment
98:                     if (PLIB_NVM_WriteOperationHasTerminated(NVM_ID_0) == false) {
9D00AA50  3C02BF80   LUI V0, -16512
9D00AA54  3444F400   ORI A0, V0, -3072
9D00AA58  0F4038D4   JAL PLIB_NVM_WriteOperationHasTerminated
9D00AA5C  00000000   NOP
99:                         // OK quittance par LED_7
100:                        // LED7_W = 0; 
101:                    }
102:                 }
9D00AA60  03C0E821   ADDU SP, FP, ZERO
9D00AA64  8FBF001C   LW RA, 28(SP)
9D00AA68  8FBE0018   LW FP, 24(SP)
9D00AA6C  27BD0020   ADDIU SP, SP, 32
9D00AA70  03E00008   JR RA
9D00AA74  00000000   NOP
103:                 
104:                 //******************************************************************************
105:                 /*
106:                   Function:
107:                     void NVMwriteRow(uint32_t address, uint32_t dataAddress)
108:                 
109:                   Summary:
110:                     Writes a row in flash memory (2KB)
111:                 */
112:                 void NVMwriteRow(uint32_t destAddr, uint32_t srcAddr)
113:                 {
9D00AFBC  27BDFFE8   ADDIU SP, SP, -24
9D00AFC0  AFBF0014   SW RA, 20(SP)
9D00AFC4  AFBE0010   SW FP, 16(SP)
9D00AFC8  03A0F021   ADDU FP, SP, ZERO
9D00AFCC  AFC40018   SW A0, 24(FP)
9D00AFD0  AFC5001C   SW A1, 28(FP)
114:                    // Base address of row to be written to (destination)
115:                    PLIB_NVM_FlashAddressToModify(NVM_ID_0, virtualToPhysical(destAddr));
9D00AFD4  8FC40018   LW A0, 24(FP)
9D00AFD8  0F40373A   JAL virtualToPhysical
9D00AFDC  00000000   NOP
9D00AFE0  3C03BF80   LUI V1, -16512
9D00AFE4  3464F400   ORI A0, V1, -3072
9D00AFE8  00402821   ADDU A1, V0, ZERO
9D00AFEC  0F4038D8   JAL PLIB_NVM_FlashAddressToModify
9D00AFF0  00000000   NOP
116:                     
117:                    // Data buffer address (source)
118:                    PLIB_NVM_DataBlockSourceAddress(NVM_ID_0, virtualToPhysical(srcAddr));
9D00AFF4  8FC4001C   LW A0, 28(FP)
9D00AFF8  0F40373A   JAL virtualToPhysical
9D00AFFC  00000000   NOP
9D00B000  3C03BF80   LUI V1, -16512
9D00B004  3464F400   ORI A0, V1, -3072
9D00B008  00402821   ADDU A1, V0, ZERO
9D00B00C  0F4038E0   JAL PLIB_NVM_DataBlockSourceAddress
9D00B010  00000000   NOP
119:                    
120:                    // Disable flash write/erase operations
121:                    PLIB_NVM_MemoryModifyInhibit(NVM_ID_0);
9D00B014  3C02BF80   LUI V0, -16512
9D00B018  3444F400   ORI A0, V0, -3072
9D00B01C  0F403871   JAL PLIB_NVM_MemoryModifyInhibit
9D00B020  00000000   NOP
122:                 
123:                    // Select row write function & enable flash write/erase operations
124:                    PLIB_NVM_MemoryOperationSelect(NVM_ID_0, ROW_PROGRAM_OPERATION);
9D00B024  3C02BF80   LUI V0, -16512
9D00B028  3444F400   ORI A0, V0, -3072
9D00B02C  24050003   ADDIU A1, ZERO, 3
9D00B030  0F403843   JAL PLIB_NVM_MemoryOperationSelect
9D00B034  00000000   NOP
125:                 
126:                    // Allow memory modifications
127:                    PLIB_NVM_MemoryModifyEnable(NVM_ID_0);
9D00B038  3C02BF80   LUI V0, -16512
9D00B03C  3444F400   ORI A0, V0, -3072
9D00B040  0F40386C   JAL PLIB_NVM_MemoryModifyEnable
9D00B044  00000000   NOP
128:                 
129:                    // Write the unlock key sequence
130:                    PLIB_NVM_FlashWriteKeySequence(NVM_ID_0, 0xAA996655);
9D00B048  3C02BF80   LUI V0, -16512
9D00B04C  3444F400   ORI A0, V0, -3072
9D00B050  3C02AA99   LUI V0, -21863
9D00B054  34456655   ORI A1, V0, 26197
9D00B058  0F4038DC   JAL PLIB_NVM_FlashWriteKeySequence
9D00B05C  00000000   NOP
131:                    PLIB_NVM_FlashWriteKeySequence(NVM_ID_0, 0x556699AA);
9D00B060  3C02BF80   LUI V0, -16512
9D00B064  3444F400   ORI A0, V0, -3072
9D00B068  3C025566   LUI V0, 21862
9D00B06C  344599AA   ORI A1, V0, -26198
9D00B070  0F4038DC   JAL PLIB_NVM_FlashWriteKeySequence
9D00B074  00000000   NOP
132:                 
133:                    // Start the operation
134:                    PLIB_NVM_FlashWriteStart(NVM_ID_0);
9D00B078  3C02BF80   LUI V0, -16512
9D00B07C  3444F400   ORI A0, V0, -3072
9D00B080  0F403876   JAL PLIB_NVM_FlashWriteStart
9D00B084  00000000   NOP
135:                 
136:                    while (PLIB_NVM_FlashWriteCycleHasCompleted(NVM_ID_0));
9D00B088  00000000   NOP
9D00B08C  3C02BF80   LUI V0, -16512
9D00B090  3444F400   ORI A0, V0, -3072
9D00B094  0F403880   JAL PLIB_NVM_FlashWriteCycleHasCompleted
9D00B098  00000000   NOP
9D00B09C  1440FFFB   BNE V0, ZERO, 0x9D00B08C
9D00B0A0  00000000   NOP
137:                 
138:                 }
9D00B0A4  03C0E821   ADDU SP, FP, ZERO
9D00B0A8  8FBF0014   LW RA, 20(SP)
9D00B0AC  8FBE0010   LW FP, 16(SP)
9D00B0B0  27BD0018   ADDIU SP, SP, 24
9D00B0B4  03E00008   JR RA
9D00B0B8  00000000   NOP
139:                 
140:                 
141:                 uint32_t NVM_ArrayRead(uint32_t index)
142:                 {
00000000  00000000   NOP
143:                     uint32_t Res;
144:                     Res = eedata_addr[index];
00000010  00000000   NOP
145:                     return Res;
0000002C  00000000   NOP
146:                 }
00000030  00000000   NOP
147:                 
148:                  
149:                  int NVMCheckLoop(void)
150:                  {
00000000  00000000   NOP
151:                    int i, stat;
152:                    
153:                    stat = 0;
0000000C  00000000   NOP
154:                    for (i=0; i < DEVICE_ROW_SIZE_DIVIDED_BY_4 ; i++) {
00000010  00000000   NOP
00000068  00000000   NOP
155:                        if (eedata_addr[i]  != databuff[i]) {
0000001C  00000000   NOP
156:                            stat = 100000 + i;
00000054  00000000   NOP
157:                        }
158:                    }
159:                    return stat;
00000084  00000000   NOP
160:                  };
00000088  00000000   NOP
161:                 
162:                 // Cette fonction crit un bloc de data au dbut de la zone flash
163:                 // PData correspond  l'adresse du bloc de donne
164:                 // DataSize est la taille en octets du bloc de donne
165:                 
166:                 void NVM_WriteBlock(uint32_t *pData, uint32_t DataSize)
167:                 {
9D00B2AC  27BDFFE0   ADDIU SP, SP, -32
9D00B2B0  AFBF001C   SW RA, 28(SP)
9D00B2B4  AFBE0018   SW FP, 24(SP)
9D00B2B8  03A0F021   ADDU FP, SP, ZERO
9D00B2BC  AFC40020   SW A0, 32(FP)
9D00B2C0  AFC50024   SW A1, 36(FP)
168:                     int i, iMax;
169:                    
170:                     // Efface la page dans la flash
171:                     NVMpageErase(NVM_PROGRAM_PAGE);
9D00B2C4  3C029D00   LUI V0, -25344
9D00B2C8  24424000   ADDIU V0, V0, 16384
9D00B2CC  00402021   ADDU A0, V0, ZERO
9D00B2D0  0F402A57   JAL NVMpageErase
9D00B2D4  00000000   NOP
172:                          
173:                     if ( (DataSize % 4) != 0  ) {
9D00B2D8  8FC20024   LW V0, 36(FP)
9D00B2DC  30420003   ANDI V0, V0, 3
9D00B2E0  10400007   BEQ V0, ZERO, .LVL48
9D00B2E4  00000000   NOP
174:                         iMax = (DataSize / 4 ) + 1;
9D00B2E8  8FC20024   LW V0, 36(FP)
9D00B2EC  00021082   SRL V0, V0, 2
9D00B2F0  24420001   ADDIU V0, V0, 1
9D00B2F4  AFC20014   SW V0, 20(FP)
9D00B2F8  0B402CC3   J .LVL49
9D00B2FC  00000000   NOP
175:                     } else {
176:                         iMax = DataSize / 4 ;
9D00B300  8FC20024   LW V0, 36(FP)
9D00B304  00021082   SRL V0, V0, 2
9D00B308  AFC20014   SW V0, 20(FP)
177:                     }
178:                 
179:                     // Copie le bloc dans databuff
180:                     for ( i = 0 ; i < iMax; i++ ) {
9D00B30C  AFC00010   SW ZERO, 16(FP)
9D00B310  0B402CD4   J 0x9D00B350
9D00B314  00000000   NOP
9D00B344  8FC20010   LW V0, 16(FP)
9D00B348  24420001   ADDIU V0, V0, 1
9D00B34C  AFC20010   SW V0, 16(FP)
9D00B350  8FC30010   LW V1, 16(FP)
9D00B354  8FC20014   LW V0, 20(FP)
9D00B358  0062102A   SLT V0, V1, V0
9D00B35C  1440FFEE   BNE V0, ZERO, .LVL51
9D00B360  00000000   NOP
181:                         databuff[i] = *pData;
9D00B318  8FC20020   LW V0, 32(FP)
9D00B31C  8C430000   LW V1, 0(V0)
9D00B320  3C02A000   LUI V0, -24576
9D00B324  8FC40010   LW A0, 16(FP)
9D00B328  00042080   SLL A0, A0, 2
9D00B32C  24420CF0   ADDIU V0, V0, 3312
9D00B330  00821021   ADDU V0, A0, V0
9D00B334  AC430000   SW V1, 0(V0)
182:                         pData++;
9D00B338  8FC20020   LW V0, 32(FP)
9D00B33C  24420004   ADDIU V0, V0, 4
9D00B340  AFC20020   SW V0, 32(FP)
183:                     }
184:                     NVMwriteRow(NVM_PROGRAM_PAGE, DATA_BUFFER_START);
9D00B364  3C029D00   LUI V0, -25344
9D00B368  24434000   ADDIU V1, V0, 16384
9D00B36C  3C02A000   LUI V0, -24576
9D00B370  24420CF0   ADDIU V0, V0, 3312
9D00B374  00602021   ADDU A0, V1, ZERO
9D00B378  00402821   ADDU A1, V0, ZERO
9D00B37C  0F402BEF   JAL NVMwriteRow
9D00B380  00000000   NOP
185:                 }
9D00B384  03C0E821   ADDU SP, FP, ZERO
9D00B388  8FBF001C   LW RA, 28(SP)
9D00B38C  8FBE0018   LW FP, 24(SP)
9D00B390  27BD0020   ADDIU SP, SP, 32
9D00B394  03E00008   JR RA
9D00B398  00000000   NOP
186:                 
187:                 void NVM_ReadBlock(uint32_t *pData, uint32_t DataSize)
188:                 {
9D00C388  27BDFFF0   ADDIU SP, SP, -16
9D00C38C  AFBE000C   SW FP, 12(SP)
9D00C390  03A0F021   ADDU FP, SP, ZERO
9D00C394  AFC40010   SW A0, 16(FP)
9D00C398  AFC50014   SW A1, 20(FP)
189:                     int i, iMax;
190:                 
191:                     if ( (DataSize % 4) != 0  ) {
9D00C39C  8FC20014   LW V0, 20(FP)
9D00C3A0  30420003   ANDI V0, V0, 3
9D00C3A4  10400007   BEQ V0, ZERO, .LVL61
9D00C3A8  00000000   NOP
192:                         iMax = (DataSize / 4 ) + 1;
9D00C3AC  8FC20014   LW V0, 20(FP)
9D00C3B0  00021082   SRL V0, V0, 2
9D00C3B4  24420001   ADDIU V0, V0, 1
9D00C3B8  AFC20004   SW V0, 4(FP)
9D00C3BC  0B4030F4   J .LVL62
9D00C3C0  00000000   NOP
193:                     } else {
194:                         iMax = DataSize / 4 ;
9D00C3C4  8FC20014   LW V0, 20(FP)
9D00C3C8  00021082   SRL V0, V0, 2
9D00C3CC  AFC20004   SW V0, 4(FP)
195:                     }
196:                     for ( i = 0 ; i < iMax; i++ ) {
9D00C3D0  AFC00000   SW ZERO, 0(FP)
9D00C3D4  0B403105   J 0x9D00C414
9D00C3D8  00000000   NOP
9D00C408  8FC20000   LW V0, 0(FP)
9D00C40C  24420001   ADDIU V0, V0, 1
9D00C410  AFC20000   SW V0, 0(FP)
9D00C414  8FC30000   LW V1, 0(FP)
9D00C418  8FC20004   LW V0, 4(FP)
9D00C41C  0062102A   SLT V0, V1, V0
9D00C420  1440FFEE   BNE V0, ZERO, .LVL64
9D00C424  00000000   NOP
197:                         *pData = eedata_addr[i];
9D00C3DC  3C029D00   LUI V0, -25344
9D00C3E0  8FC30000   LW V1, 0(FP)
9D00C3E4  00031880   SLL V1, V1, 2
9D00C3E8  24424000   ADDIU V0, V0, 16384
9D00C3EC  00621021   ADDU V0, V1, V0
9D00C3F0  8C430000   LW V1, 0(V0)
9D00C3F4  8FC20010   LW V0, 16(FP)
9D00C3F8  AC430000   SW V1, 0(V0)
198:                         pData++;
9D00C3FC  8FC20010   LW V0, 16(FP)
9D00C400  24420004   ADDIU V0, V0, 4
9D00C404  AFC20010   SW V0, 16(FP)
199:                     }
200:                 }
9D00C428  03C0E821   ADDU SP, FP, ZERO
9D00C42C  8FBE000C   LW FP, 12(SP)
9D00C430  27BD0010   ADDIU SP, SP, 16
9D00C434  03E00008   JR RA
9D00C438  00000000   NOP
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/mc32gest_rs232.c  ----------
1:                   /*--------------------------------------------------------*/
2:                   // Mc32gest_R232.c
3:                   /*--------------------------------------------------------*/
4:                   //
5:                   //	Auteur 		: 	Diego Rickenbach
6:                   //
7:                   //	Version		:	V1
8:                   //
9:                   // Mc32Gest_RS232.c
10:                  /*--------------------------------------------------------*/
11:                  
12:                  //Includes
13:                  #include <xc.h>
14:                  #include <sys/attribs.h>
15:                  #include "system_definitions.h"
16:                  #include <string.h>
17:                  
18:                  #include <GenericTypeDefs.h>
19:                  #include "app.h"
20:                  #include "GesFifoTh32.h"
21:                  #include "Mc32gest_RS232.h"
22:                  #include "Mc32Delays.h"
23:                  
24:                  
25:                  typedef union {
26:                          uint16_t val;
27:                          struct {uint8_t lsb;
28:                                  uint8_t msb;} shl;
29:                  } U_manip16;
30:                  
31:                  
32:                  // Definition pour les messages
33:                  //#define MESS_SIZE  30
34:                  
35:                  // Declaration des FIFO pour rception et mission
36:                  //#define FIFO_RX_SIZE ((4*MESS_SIZE) + 1)  // 4 messages
37:                  //#define FIFO_TX_SIZE ((4*MESS_SIZE) + 1)  // 4 messages
38:                  #define FIFO_WIFI_RX_SIZE 500
39:                  #define FIFO_WIFI_TX_SIZE 500
40:                  
41:                  #define FIFO_USB_RX_SIZE 500
42:                  #define FIFO_USB_TX_SIZE 500
43:                  
44:                  int8_t fifoWifiRX[FIFO_WIFI_RX_SIZE];
45:                  int8_t fifoUSBRX[FIFO_USB_RX_SIZE];
46:                  
47:                  // Declaration du descripteur du FIFO de rception
48:                  S_fifo descrFifoWifiRX;
49:                  S_fifo descrFifoUSBRX;
50:                  
51:                  int8_t fifoWifiTX[FIFO_WIFI_TX_SIZE];
52:                  int8_t fifoUSBTX[FIFO_USB_TX_SIZE];
53:                  
54:                  // Declaration du descripteur du FIFO d'mission
55:                  S_fifo descrFifoWifiTX;
56:                  S_fifo descrFifoUSBTX;
57:                  
58:                  // Initialisation de la communication srielle
59:                  void FifoComm_Init(void)
60:                  {    
9D00C644  27BDFFE8   ADDIU SP, SP, -24
9D00C648  AFBF0014   SW RA, 20(SP)
9D00C64C  AFBE0010   SW FP, 16(SP)
9D00C650  03A0F021   ADDU FP, SP, ZERO
61:                      // Initialisation du fifo de rception Wifi
62:                      InitFifo (&descrFifoWifiRX, FIFO_WIFI_RX_SIZE, fifoWifiRX, 0);
9D00C654  3C02A000   LUI V0, -24576
9D00C658  244404B0   ADDIU A0, V0, 1200
9D00C65C  240501F4   ADDIU A1, ZERO, 500
9D00C660  3C02A000   LUI V0, -24576
9D00C664  24460AC8   ADDIU A2, V0, 2760
9D00C668  00003821   ADDU A3, ZERO, ZERO
9D00C66C  0F402FED   JAL InitFifo
9D00C670  00000000   NOP
63:                      // Initialisation du fifo d'mission
64:                      InitFifo (&descrFifoWifiTX, FIFO_WIFI_TX_SIZE, fifoWifiTX, 0);
9D00C674  3C02A000   LUI V0, -24576
9D00C678  24440AB4   ADDIU A0, V0, 2740
9D00C67C  240501F4   ADDIU A1, ZERO, 500
9D00C680  3C02A000   LUI V0, -24576
9D00C684  244608AC   ADDIU A2, V0, 2220
9D00C688  00003821   ADDU A3, ZERO, ZERO
9D00C68C  0F402FED   JAL InitFifo
9D00C690  00000000   NOP
65:                      
66:                      // Initialisation du fifo de rception USB
67:                      InitFifo (&descrFifoUSBRX, FIFO_USB_RX_SIZE, fifoUSBRX, 0);
9D00C694  3C02A000   LUI V0, -24576
9D00C698  2444049C   ADDIU A0, V0, 1180
9D00C69C  240501F4   ADDIU A1, ZERO, 500
9D00C6A0  3C02A000   LUI V0, -24576
9D00C6A4  244604C4   ADDIU A2, V0, 1220
9D00C6A8  00003821   ADDU A3, ZERO, ZERO
9D00C6AC  0F402FED   JAL InitFifo
9D00C6B0  00000000   NOP
68:                      // Initialisation du fifo d'mission
69:                      InitFifo (&descrFifoUSBTX, FIFO_USB_TX_SIZE, fifoUSBTX, 0);
9D00C6B4  3C02A000   LUI V0, -24576
9D00C6B8  24440AA0   ADDIU A0, V0, 2720
9D00C6BC  240501F4   ADDIU A1, ZERO, 500
9D00C6C0  3C02A000   LUI V0, -24576
9D00C6C4  244606B8   ADDIU A2, V0, 1720
9D00C6C8  00003821   ADDU A3, ZERO, ZERO
9D00C6CC  0F402FED   JAL InitFifo
9D00C6D0  00000000   NOP
70:                     
71:                  } // InitComm
9D00C6D4  03C0E821   ADDU SP, FP, ZERO
9D00C6D8  8FBF0014   LW RA, 20(SP)
9D00C6DC  8FBE0010   LW FP, 16(SP)
9D00C6E0  27BD0018   ADDIU SP, SP, 24
9D00C6E4  03E00008   JR RA
9D00C6E8  00000000   NOP
72:                  
73:                  /*******************************************************************************
74:                  * Auteur : Diego Rickenbach                                                    *                     
75:                  * Nom de la fonction :     FlushWifiRxBuf                                      *                                    
76:                  * Entre :      rien                                                           *                                                                      
77:                  * Sortie :      rien                                                           *
78:                  * Desription :  Cette fonction permet de supprimer tout ce qu'il y a dans le   *                                                     
79:                  *               Fifo SW                                                        *
80:                  * Remarques:    Voir le prototype dans Mc32gest_RS232.h                        *
81:                  *******************************************************************************/
82:                  void FlushWifiRxBuf(void)
83:                  {
9D00D5C0  27BDFFE0   ADDIU SP, SP, -32
9D00D5C4  AFBF001C   SW RA, 28(SP)
9D00D5C8  AFBE0018   SW FP, 24(SP)
9D00D5CC  03A0F021   ADDU FP, SP, ZERO
84:                      int8_t c;
85:                      while (GetReadSize(&descrFifoWifiRX) > 0)
9D00D5D0  0B40357C   J .LVL4
9D00D5D4  00000000   NOP
9D00D5F0  3C02A000   LUI V0, -24576
9D00D5F4  244404B0   ADDIU A0, V0, 1200
9D00D5F8  0F403525   JAL GetReadSize
9D00D5FC  00000000   NOP
9D00D600  1C40FFF5   BGTZ V0, 0x9D00D5D8
9D00D604  00000000   NOP
86:                          GetCharFromFifo(&descrFifoWifiRX, &c);        
9D00D5D8  3C02A000   LUI V0, -24576
9D00D5DC  244404B0   ADDIU A0, V0, 1200
9D00D5E0  27C20010   ADDIU V0, FP, 16
9D00D5E4  00402821   ADDU A1, V0, ZERO
9D00D5E8  0F403083   JAL GetCharFromFifo
9D00D5EC  00000000   NOP
87:                  }
9D00D608  03C0E821   ADDU SP, FP, ZERO
9D00D60C  8FBF001C   LW RA, 28(SP)
9D00D610  8FBE0018   LW FP, 24(SP)
9D00D614  27BD0020   ADDIU SP, SP, 32
9D00D618  03E00008   JR RA
9D00D61C  00000000   NOP
88:                  void FlushUSBRxBuf(void)
89:                  {
9D00D620  27BDFFE0   ADDIU SP, SP, -32
9D00D624  AFBF001C   SW RA, 28(SP)
9D00D628  AFBE0018   SW FP, 24(SP)
9D00D62C  03A0F021   ADDU FP, SP, ZERO
90:                      int8_t c;
91:                      while (GetReadSize(&descrFifoUSBRX) > 0)
9D00D630  0B403594   J .LVL6
9D00D634  00000000   NOP
9D00D650  3C02A000   LUI V0, -24576
9D00D654  2444049C   ADDIU A0, V0, 1180
9D00D658  0F403525   JAL GetReadSize
9D00D65C  00000000   NOP
9D00D660  1C40FFF5   BGTZ V0, 0x9D00D638
9D00D664  00000000   NOP
92:                          GetCharFromFifo(&descrFifoUSBRX, &c);        
9D00D638  3C02A000   LUI V0, -24576
9D00D63C  2444049C   ADDIU A0, V0, 1180
9D00D640  27C20010   ADDIU V0, FP, 16
9D00D644  00402821   ADDU A1, V0, ZERO
9D00D648  0F403083   JAL GetCharFromFifo
9D00D64C  00000000   NOP
93:                  }
9D00D668  03C0E821   ADDU SP, FP, ZERO
9D00D66C  8FBF001C   LW RA, 28(SP)
9D00D670  8FBE0018   LW FP, 24(SP)
9D00D674  27BD0020   ADDIU SP, SP, 32
9D00D678  03E00008   JR RA
9D00D67C  00000000   NOP
94:                  
95:                  /*******************************************************************************
96:                  * Auteur : Diego Rickenbach                                                    *                     
97:                  * Nom de la fonction :     GetWifiMessage                                      *                                    
98:                  * Entre :      int8_t *pDataRX, char* CompareStr, uint32_t nbMsWait           *                                                                      
99:                  * Sortie :      rien                                                           *
100:                 * Desription :  Cette fonction permet de rcuprer tous les caractres se      *
101:                 *               trouvant de la Fifo SW du Wifi.                                *
102:                 * Remarques:    Voir le prototype dans Mc32gest_RS232.h                        *
103:                 *******************************************************************************/
104:                 int8_t GetWifiMessage(int8_t *pDataRX, char* CompareStr, uint32_t nbMsWait)
105:                 {
9D0096D8  27BDFFD8   ADDIU SP, SP, -40
9D0096DC  AFBF0024   SW RA, 36(SP)
9D0096E0  AFBE0020   SW FP, 32(SP)
9D0096E4  03A0F021   ADDU FP, SP, ZERO
9D0096E8  AFC40028   SW A0, 40(FP)
9D0096EC  AFC5002C   SW A1, 44(FP)
9D0096F0  AFC60030   SW A2, 48(FP)
106:                 	//Dclaration des variables
107:                     uint32_t nbMs = 0;
9D0096F4  AFC00010   SW ZERO, 16(FP)
108:                     int32_t NbCharToRead = 0;
9D0096F8  AFC00018   SW ZERO, 24(FP)
109:                     uint8_t charCntr = 0;
9D0096FC  A3C00014   SB ZERO, 20(FP)
110:                     uint8_t i;
111:                     
112:                     //tant que le timeout n'est pas termin
113:                     do{
114:                         //vrifie le nombre de caratre dans le fifoSW
115:                         NbCharToRead = GetReadSize(&descrFifoWifiRX);
9D009700  3C02A000   LUI V0, -24576
9D009704  244404B0   ADDIU A0, V0, 1200
9D009708  0F403525   JAL GetReadSize
9D00970C  00000000   NOP
9D009710  AFC20018   SW V0, 24(FP)
116:                 
117:                         //test si il y en a plus que 0
118:                         if(NbCharToRead > 0)
9D009714  8FC20018   LW V0, 24(FP)
9D009718  18400035   BLEZ V0, .LVL25
9D00971C  00000000   NOP
119:                         {  
120:                            for(i=0; i < NbCharToRead; i++)
9D009720  A3C00015   SB ZERO, 21(FP)
9D009724  0B4025D9   J 0x9D009764
9D009728  00000000   NOP
9D009758  93C20015   LBU V0, 21(FP)
9D00975C  24420001   ADDIU V0, V0, 1
9D009760  A3C20015   SB V0, 21(FP)
9D009764  93C30015   LBU V1, 21(FP)
9D009768  8FC20018   LW V0, 24(FP)
9D00976C  0062102A   SLT V0, V1, V0
9D009770  1440FFEE   BNE V0, ZERO, .LVL15
9D009774  00000000   NOP
121:                            {
122:                                //rcupre les charactres du fifoSW
123:                                GetCharFromFifo(&descrFifoWifiRX, (int8_t*)&pDataRX[charCntr]);
9D00972C  93C20014   LBU V0, 20(FP)
9D009730  8FC30028   LW V1, 40(FP)
9D009734  00621021   ADDU V0, V1, V0
9D009738  3C03A000   LUI V1, -24576
9D00973C  246404B0   ADDIU A0, V1, 1200
9D009740  00402821   ADDU A1, V0, ZERO
9D009744  0F403083   JAL GetCharFromFifo
9D009748  00000000   NOP
124:                                charCntr++;
9D00974C  93C20014   LBU V0, 20(FP)
9D009750  24420001   ADDIU V0, V0, 1
9D009754  A3C20014   SB V0, 20(FP)
125:                            }
126:                            
127:                            //test si dans la trame reue, il y a un \r\n
128:                            if(strstr((char*)pDataRX, "\x0D\x0A") != 0)
9D009778  8FC40028   LW A0, 40(FP)
9D00977C  3C029D01   LUI V0, -25343
9D009780  2445E3DC   ADDIU A1, V0, -7204
9D009784  0F4032FD   JAL strstr
9D009788  00000000   NOP
9D00978C  10400018   BEQ V0, ZERO, .LVL25
9D009790  00000000   NOP
129:                            {
130:                                //si oui, teste si dans la trame il y a les mme caratre que l'on veut
131:                                if (strstr((char*)pDataRX, CompareStr) != 0)
9D009794  8FC40028   LW A0, 40(FP)
9D009798  8FC5002C   LW A1, 44(FP)
9D00979C  0F4032FD   JAL strstr
9D0097A0  00000000   NOP
9D0097A4  10400006   BEQ V0, ZERO, 0x9D0097C0
9D0097A8  00000000   NOP
132:                                {
133:                                     //si oui, on supprime tout ce qu'il y a dans le fifoSW et return OK
134:                                     FlushWifiRxBuf();
9D0097AC  0F403570   JAL FlushWifiRxBuf
9D0097B0  00000000   NOP
135:                                     return OK;
9D0097B4  00001021   ADDU V0, ZERO, ZERO
9D0097B8  0B402610   J .LVL31
9D0097BC  00000000   NOP
136:                                }
137:                                //si oui, teste sur le message ERROR a t reu 
138:                                if (strstr((char*)pDataRX, "ERROR") != 0)
9D0097C0  8FC40028   LW A0, 40(FP)
9D0097C4  3C029D01   LUI V0, -25343
9D0097C8  2445E3E0   ADDIU A1, V0, -7200
9D0097CC  0F4032FD   JAL strstr
9D0097D0  00000000   NOP
9D0097D4  10400006   BEQ V0, ZERO, .LVL25
9D0097D8  00000000   NOP
139:                                {
140:                                     //si oui, on supprime tout ce qu'il y a dans le fifoSW et return ERROR
141:                                     FlushWifiRxBuf();
9D0097DC  0F403570   JAL FlushWifiRxBuf
9D0097E0  00000000   NOP
142:                                     return ERROR;
9D0097E4  24020001   ADDIU V0, ZERO, 1
9D0097E8  0B402610   J .LVL31
9D0097EC  00000000   NOP
143:                                }         
144:                            }
145:                         }
146:                         delay_msCt(1);
9D0097F0  24040001   ADDIU A0, ZERO, 1
9D0097F4  0F40342A   JAL delay_msCt
9D0097F8  00000000   NOP
147:                         nbMs++;
9D0097FC  8FC20010   LW V0, 16(FP)
9D009800  24420001   ADDIU V0, V0, 1
9D009804  AFC20010   SW V0, 16(FP)
148:                     }while(nbMs <= nbMsWait);
9D009808  8FC30010   LW V1, 16(FP)
9D00980C  8FC20030   LW V0, 48(FP)
9D009810  0043102B   SLTU V0, V0, V1
9D009814  1040FFBA   BEQ V0, ZERO, .LVL11
9D009818  00000000   NOP
149:                     
150:                     //test si on a rcupr des caracteres dans le FifoSW
151:                     if (charCntr > 0)
9D00981C  93C20014   LBU V0, 20(FP)
9D009820  10400006   BEQ V0, ZERO, .LVL30
9D009824  00000000   NOP
152:                     {
153:                         //si oui, on supprime tout ce qu'il y a dans le fifoSW et return TIMEOUT
154:                         FlushWifiRxBuf();
9D009828  0F403570   JAL FlushWifiRxBuf
9D00982C  00000000   NOP
155:                         return TIMEOUT;
9D009830  24020003   ADDIU V0, ZERO, 3
9D009834  0B402610   J .LVL31
9D009838  00000000   NOP
156:                     }
157:                     //sinon
158:                     else
159:                         //return NO_DATA
160:                         return NO_DATA;    
9D00983C  24020002   ADDIU V0, ZERO, 2
161:                 } // GetWifiMessage
9D009840  03C0E821   ADDU SP, FP, ZERO
9D009844  8FBF0024   LW RA, 36(SP)
9D009848  8FBE0020   LW FP, 32(SP)
9D00984C  27BD0028   ADDIU SP, SP, 40
9D009850  03E00008   JR RA
9D009854  00000000   NOP
162:                 
163:                 /*******************************************************************************
164:                 * Auteur : Diego Rickenbach                                                    *                     
165:                 * Nom de la fonction :     GetUSBMessage                                       *                                    
166:                 * Entre :      int8_t *pDataRX, char* CompareStr                              *                                                                      
167:                 * Sortie :      rien                                                           *
168:                 * Desription :  Cette fonction permet de rcuprer tout les caractres se      *
169:                 *               trouvant de la Fifi SW de l'USB.                               *
170:                 * Remarques:    Voir le prototype dans Mc32gest_RS232.h                        *
171:                 *******************************************************************************/
172:                 int8_t GetUSBMessage(int8_t *pDataRX, char* CompareStr)
173:                 {
9D008884  27BDFFD0   ADDIU SP, SP, -48
9D008888  AFBF002C   SW RA, 44(SP)
9D00888C  AFBE0028   SW FP, 40(SP)
9D008890  AFB00024   SW S0, 36(SP)
9D008894  03A0F021   ADDU FP, SP, ZERO
9D008898  AFC40030   SW A0, 48(FP)
9D00889C  AFC50034   SW A1, 52(FP)
174:                 	//Dclaration des variables
175:                     int32_t NbCharToRead = 0;
9D0088A0  AFC00014   SW ZERO, 20(FP)
176:                     uint8_t charCntr = 0;
9D0088A4  A3C00010   SB ZERO, 16(FP)
177:                     uint8_t i, j;
178:                     static int8_t OldCharFromFifo[500] = {0};
179:                     
180:                     //vrifie le nombre de caratre dans le fifoSW
181:                     NbCharToRead = GetReadSize(&descrFifoUSBRX);
9D0088A8  3C02A000   LUI V0, -24576
9D0088AC  2444049C   ADDIU A0, V0, 1180
9D0088B0  0F403525   JAL GetReadSize
9D0088B4  00000000   NOP
9D0088B8  AFC20014   SW V0, 20(FP)
182:                 
183:                     //test si il y en a plus que 0
184:                     if(NbCharToRead > 0)   
9D0088BC  8FC20014   LW V0, 20(FP)
9D0088C0  1840003E   BLEZ V0, .LVL51
9D0088C4  00000000   NOP
185:                     {  
186:                         //rcupre les charactres du fifoSW et en fait une copie dans 
187:                         //OldCharFromFifo
188:                         for(i = 0; i < NbCharToRead; i++)
9D0088C8  A3C00011   SB ZERO, 17(FP)
9D0088CC  0B40224C   J 0x9D008930
9D0088D0  00000000   NOP
9D008924  93C20011   LBU V0, 17(FP)
9D008928  24420001   ADDIU V0, V0, 1
9D00892C  A3C20011   SB V0, 17(FP)
9D008930  93C30011   LBU V1, 17(FP)
9D008934  8FC20014   LW V0, 20(FP)
9D008938  0062102A   SLT V0, V1, V0
9D00893C  1440FFE5   BNE V0, ZERO, .LVL41
9D008940  00000000   NOP
189:                         {
190:                             GetCharFromFifo(&descrFifoUSBRX, (int8_t*)&pDataRX[charCntr]);
9D0088D4  93C20010   LBU V0, 16(FP)
9D0088D8  8FC30030   LW V1, 48(FP)
9D0088DC  00621021   ADDU V0, V1, V0
9D0088E0  3C03A000   LUI V1, -24576
9D0088E4  2464049C   ADDIU A0, V1, 1180
9D0088E8  00402821   ADDU A1, V0, ZERO
9D0088EC  0F403083   JAL GetCharFromFifo
9D0088F0  00000000   NOP
191:                             OldCharFromFifo[charCntr] = pDataRX[charCntr];
9D0088F4  93C40010   LBU A0, 16(FP)
9D0088F8  93C20010   LBU V0, 16(FP)
9D0088FC  8FC30030   LW V1, 48(FP)
9D008900  00621021   ADDU V0, V1, V0
9D008904  80430000   LB V1, 0(V0)
9D008908  3C02A000   LUI V0, -24576
9D00890C  24420EF0   ADDIU V0, V0, 3824
9D008910  00821021   ADDU V0, A0, V0
9D008914  A0430000   SB V1, 0(V0)
192:                             charCntr++;
9D008918  93C20010   LBU V0, 16(FP)
9D00891C  24420001   ADDIU V0, V0, 1
9D008920  A3C20010   SB V0, 16(FP)
193:                         }
194:                         //test si dans la trame il y a les mme caratre que l'on veut
195:                         if (strstr((char*)pDataRX, CompareStr) != 0)
9D008944  8FC40030   LW A0, 48(FP)
9D008948  8FC50034   LW A1, 52(FP)
9D00894C  0F4032FD   JAL strstr
9D008950  00000000   NOP
9D008954  10400045   BEQ V0, ZERO, .LVL60
9D008958  00000000   NOP
196:                         {
197:                             //si oui, on supprime tout ce qu'il y a dans le fifo SW,
198:                             //supprime ce qu'il y a dans le tableau et return OK
199:                             for(j = 0; j < strlen((char*)OldCharFromFifo); j++)
9D00895C  A3C00012   SB ZERO, 18(FP)
9D008960  0B402262   J 0x9D008988
9D008964  00000000   NOP
9D00897C  93C20012   LBU V0, 18(FP)
9D008980  24420001   ADDIU V0, V0, 1
9D008984  A3C20012   SB V0, 18(FP)
9D008988  93D00012   LBU S0, 18(FP)
9D00898C  3C02A000   LUI V0, -24576
9D008990  24440EF0   ADDIU A0, V0, 3824
9D008994  0F402789   JAL strlen
9D008998  00000000   NOP
9D00899C  0202102B   SLTU V0, S0, V0
9D0089A0  1440FFF1   BNE V0, ZERO, 0x9D008968
9D0089A4  00000000   NOP
200:                             {
201:                                 OldCharFromFifo[j] = 0;
9D008968  93C30012   LBU V1, 18(FP)
9D00896C  3C02A000   LUI V0, -24576
9D008970  24420EF0   ADDIU V0, V0, 3824
9D008974  00621021   ADDU V0, V1, V0
9D008978  A0400000   SB ZERO, 0(V0)
202:                             }
203:                             FlushUSBRxBuf();
9D0089A8  0F403588   JAL FlushUSBRxBuf
9D0089AC  00000000   NOP
204:                             return OK;
9D0089B0  00001021   ADDU V0, ZERO, ZERO
9D0089B4  0B40229C   J .LVL61
9D0089B8  00000000   NOP
205:                         }        
206:                     }
207:                     //sinon, test si dans l'ancienne trame il y a les mme caratre que l'on veut 
208:                     else if (strstr((char*)OldCharFromFifo, CompareStr) != 0)
9D0089BC  3C02A000   LUI V0, -24576
9D0089C0  24440EF0   ADDIU A0, V0, 3824
9D0089C4  8FC50034   LW A1, 52(FP)
9D0089C8  0F4032FD   JAL strstr
9D0089CC  00000000   NOP
9D0089D0  10400023   BEQ V0, ZERO, .LVL59, .LBE2
9D0089D4  00000000   NOP
209:                     {
210:                         //si oui, on supprime tout ce qu'il y a dans le tableau et retourne OK
211:                         uint8_t charCntr = strlen((char*)OldCharFromFifo);
9D0089D8  3C02A000   LUI V0, -24576
9D0089DC  24440EF0   ADDIU A0, V0, 3824
9D0089E0  0F402789   JAL strlen
9D0089E4  00000000   NOP
9D0089E8  A3C20018   SB V0, 24(FP)
212:                         for(j = 0; j < charCntr-1; j++)
9D0089EC  A3C00012   SB ZERO, 18(FP)
9D0089F0  0B40228F   J 0x9D008A3C
9D0089F4  00000000   NOP
9D008A30  93C20012   LBU V0, 18(FP)
9D008A34  24420001   ADDIU V0, V0, 1
9D008A38  A3C20012   SB V0, 18(FP)
9D008A3C  93C30012   LBU V1, 18(FP)
9D008A40  93C20018   LBU V0, 24(FP)
9D008A44  2442FFFF   ADDIU V0, V0, -1
9D008A48  0062102A   SLT V0, V1, V0
9D008A4C  1440FFEA   BNE V0, ZERO, .LVL57
9D008A50  00000000   NOP
213:                         {
214:                             pDataRX[j] = OldCharFromFifo[j];
9D0089F8  93C20012   LBU V0, 18(FP)
9D0089FC  8FC30030   LW V1, 48(FP)
9D008A00  00621021   ADDU V0, V1, V0
9D008A04  93C40012   LBU A0, 18(FP)
9D008A08  3C03A000   LUI V1, -24576
9D008A0C  24630EF0   ADDIU V1, V1, 3824
9D008A10  00831821   ADDU V1, A0, V1
9D008A14  80630000   LB V1, 0(V1)
9D008A18  A0430000   SB V1, 0(V0)
215:                             OldCharFromFifo[j] = 0;
9D008A1C  93C30012   LBU V1, 18(FP)
9D008A20  3C02A000   LUI V0, -24576
9D008A24  24420EF0   ADDIU V0, V0, 3824
9D008A28  00621021   ADDU V0, V1, V0
9D008A2C  A0400000   SB ZERO, 0(V0)
216:                         } 
217:                         return OK;
9D008A54  00001021   ADDU V0, ZERO, ZERO
9D008A58  0B40229C   J .LVL61
9D008A5C  00000000   NOP
218:                     }
219:                     else
220:                     {
221:                        //retourne NO_DATA
222:                         return NO_DATA;
9D008A60  24020002   ADDIU V0, ZERO, 2
9D008A64  0B40229C   J .LVL61
9D008A68  00000000   NOP
223:                     }
224:                     //retourne ERROR
225:                     return ERROR;
9D008A6C  24020001   ADDIU V0, ZERO, 1
226:                 } // GetUSBMessage
9D008A70  03C0E821   ADDU SP, FP, ZERO
9D008A74  8FBF002C   LW RA, 44(SP)
9D008A78  8FBE0028   LW FP, 40(SP)
9D008A7C  8FB00024   LW S0, 36(SP)
9D008A80  27BD0030   ADDIU SP, SP, 48
9D008A84  03E00008   JR RA
9D008A88  00000000   NOP
227:                 
228:                 /*******************************************************************************
229:                 * Auteur : Diego Rickenbach                                                    *                     
230:                 * Nom de la fonction :     SendWifiMessage                                     *                                    
231:                 * Entre :      int8_t *pDataRX, char* CompareStr                              *                                                                      
232:                 * Sortie :      rien                                                           *
233:                 * Desription :  Cette fonction permet de mettre les caractre dans le fifo SW  *
234:                 *               du Wifi.                                                       *
235:                 * Remarques:    Voir le prototype dans Mc32gest_RS232.h                        *
236:                 *******************************************************************************/
237:                 void SendWifiMessage(int8_t *pDataTX, uint8_t NbByte)
238:                 {
9D00C07C  27BDFFE0   ADDIU SP, SP, -32
9D00C080  AFBF001C   SW RA, 28(SP)
9D00C084  AFBE0018   SW FP, 24(SP)
9D00C088  03A0F021   ADDU FP, SP, ZERO
9D00C08C  AFC40020   SW A0, 32(FP)
9D00C090  00A01021   ADDU V0, A1, ZERO
9D00C094  A3C20024   SB V0, 36(FP)
239:                 //    uint8_t txFifoLvl;			// Niveau de remplissage du fifo
240:                     int i;
241:                     
242:                     PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_USART_2_TRANSMIT);
9D00C098  00002021   ADDU A0, ZERO, ZERO
9D00C09C  24050037   ADDIU A1, ZERO, 55
9D00C0A0  0F4037A4   JAL PLIB_INT_SourceDisable
9D00C0A4  00000000   NOP
243:                     
244:                     //remplit buffer tx
245:                     for(i = 0; i < NbByte; i++)
9D00C0A8  AFC00010   SW ZERO, 16(FP)
9D00C0AC  0B40303A   J 0x9D00C0E8
9D00C0B0  00000000   NOP
9D00C0DC  8FC20010   LW V0, 16(FP)
9D00C0E0  24420001   ADDIU V0, V0, 1
9D00C0E4  AFC20010   SW V0, 16(FP)
9D00C0E8  93C30024   LBU V1, 36(FP)
9D00C0EC  8FC20010   LW V0, 16(FP)
9D00C0F0  0043102A   SLT V0, V0, V1
9D00C0F4  1440FFEF   BNE V0, ZERO, 0x9D00C0B4
9D00C0F8  00000000   NOP
246:                     {
247:                         //rcupre les characteres et les met dans le fifoSW
248:                         PutCharInFifo(&descrFifoWifiTX, pDataTX[i]);
9D00C0B4  8FC20010   LW V0, 16(FP)
9D00C0B8  8FC30020   LW V1, 32(FP)
9D00C0BC  00621021   ADDU V0, V1, V0
9D00C0C0  80420000   LB V0, 0(V0)
9D00C0C4  304200FF   ANDI V0, V0, 255
9D00C0C8  3C03A000   LUI V1, -24576
9D00C0CC  24640AB4   ADDIU A0, V1, 2740
9D00C0D0  00402821   ADDU A1, V0, ZERO
9D00C0D4  0F40310F   JAL PutCharInFifo
9D00C0D8  00000000   NOP
249:                     }
250:                     
251:                     //vrifie le nombre de caratre dans le fifoSW
252:                 //    txFifoLvl = GetReadSize(&descrFifoWifiTX);
253:                     
254:                     //test si il y a plus que 0 charactere dans le fifo
255:                     if (GetReadSize(&descrFifoWifiTX) > 0)
9D00C0FC  3C02A000   LUI V0, -24576
9D00C100  24440AB4   ADDIU A0, V0, 2740
9D00C104  0F403525   JAL GetReadSize
9D00C108  00000000   NOP
9D00C10C  18400005   BLEZ V0, .LVL72
9D00C110  00000000   NOP
256:                     {
257:                         // Active interruption   
258:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_USART_2_TRANSMIT);
9D00C114  00002021   ADDU A0, ZERO, ZERO
9D00C118  24050037   ADDIU A1, ZERO, 55
9D00C11C  0F40379A   JAL PLIB_INT_SourceEnable
9D00C120  00000000   NOP
259:                     }
260:                     FlushWifiRxBuf();
9D00C124  0F403570   JAL FlushWifiRxBuf
9D00C128  00000000   NOP
261:                 }
9D00C12C  03C0E821   ADDU SP, FP, ZERO
9D00C130  8FBF001C   LW RA, 28(SP)
9D00C134  8FBE0018   LW FP, 24(SP)
9D00C138  27BD0020   ADDIU SP, SP, 32
9D00C13C  03E00008   JR RA
9D00C140  00000000   NOP
262:                 
263:                 /*******************************************************************************
264:                 * Auteur : Diego Rickenbach                                                    *                     
265:                 * Nom de la fonction :     SendUSBMessage                                      *                                    
266:                 * Entre :      int8_t *pDataTX, uint8_t NbByte                                *                                                                      
267:                 * Sortie :      rien                                                           *
268:                 * Desription :  Cette fonction permet de mettre les caractre dans le fifo SW  *
269:                 *               de l'USB.                                                      *
270:                 * Remarques:    Voir le prototype dans Mc32gest_RS232.h                        *
271:                 *******************************************************************************/
272:                 void SendUSBMessage(int8_t *pDataTX, uint8_t NbByte)
273:                 {
9D00C144  27BDFFE0   ADDIU SP, SP, -32
9D00C148  AFBF001C   SW RA, 28(SP)
9D00C14C  AFBE0018   SW FP, 24(SP)
9D00C150  03A0F021   ADDU FP, SP, ZERO
9D00C154  AFC40020   SW A0, 32(FP)
9D00C158  00A01021   ADDU V0, A1, ZERO
9D00C15C  A3C20024   SB V0, 36(FP)
274:                 //    uint8_t txFifoLvl;			// Niveau de remplissage du fifo
275:                     int i;
276:                     
277:                     PLIB_INT_SourceDisable(INT_ID_0, INT_SOURCE_USART_1_TRANSMIT);
9D00C160  00002021   ADDU A0, ZERO, ZERO
9D00C164  24050029   ADDIU A1, ZERO, 41
9D00C168  0F4037A4   JAL PLIB_INT_SourceDisable
9D00C16C  00000000   NOP
278:                     
279:                     //remplit buffer tx
280:                     for(i = 0; i < NbByte; i++)
9D00C170  AFC00010   SW ZERO, 16(FP)
9D00C174  0B40306C   J 0x9D00C1B0
9D00C178  00000000   NOP
9D00C1A4  8FC20010   LW V0, 16(FP)
9D00C1A8  24420001   ADDIU V0, V0, 1
9D00C1AC  AFC20010   SW V0, 16(FP)
9D00C1B0  93C30024   LBU V1, 36(FP)
9D00C1B4  8FC20010   LW V0, 16(FP)
9D00C1B8  0043102A   SLT V0, V0, V1
9D00C1BC  1440FFEF   BNE V0, ZERO, 0x9D00C17C
9D00C1C0  00000000   NOP
281:                     {
282:                         //rcupre les characteres et les met dans le fifoSW
283:                         PutCharInFifo(&descrFifoUSBTX, pDataTX[i]);
9D00C17C  8FC20010   LW V0, 16(FP)
9D00C180  8FC30020   LW V1, 32(FP)
9D00C184  00621021   ADDU V0, V1, V0
9D00C188  80420000   LB V0, 0(V0)
9D00C18C  304200FF   ANDI V0, V0, 255
9D00C190  3C03A000   LUI V1, -24576
9D00C194  24640AA0   ADDIU A0, V1, 2720
9D00C198  00402821   ADDU A1, V0, ZERO
9D00C19C  0F40310F   JAL PutCharInFifo
9D00C1A0  00000000   NOP
284:                     }
285:                     
286:                     //test si il y a plus que 0 charactere dans le fifo
287:                 //    txFifoLvl = GetReadSize(&descrFifoUSBTX);
288:                     if (GetReadSize(&descrFifoUSBTX) > 0)
9D00C1C4  3C02A000   LUI V0, -24576
9D00C1C8  24440AA0   ADDIU A0, V0, 2720
9D00C1CC  0F403525   JAL GetReadSize
9D00C1D0  00000000   NOP
9D00C1D4  18400005   BLEZ V0, .LVL84
9D00C1D8  00000000   NOP
289:                     {
290:                         // Active interruption   
291:                         PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_USART_1_TRANSMIT);
9D00C1DC  00002021   ADDU A0, ZERO, ZERO
9D00C1E0  24050029   ADDIU A1, ZERO, 41
9D00C1E4  0F40379A   JAL PLIB_INT_SourceEnable
9D00C1E8  00000000   NOP
292:                     }
293:                     FlushUSBRxBuf();
9D00C1EC  0F403588   JAL FlushUSBRxBuf
9D00C1F0  00000000   NOP
294:                 }
9D00C1F4  03C0E821   ADDU SP, FP, ZERO
9D00C1F8  8FBF001C   LW RA, 28(SP)
9D00C1FC  8FBE0018   LW FP, 24(SP)
9D00C200  27BD0020   ADDIU SP, SP, 32
9D00C204  03E00008   JR RA
9D00C208  00000000   NOP
295:                 
296:                 // Interruption USART2 - Wifi
297:                 void __ISR(_UART_2_VECTOR, ipl3AUTO) _IntHandlerDrvUsartInstance0(void)
298:                 {
9D0070E8  415DE800   RDPGPR SP, SP
9D0070EC  401B7000   MFC0 K1, EPC
9D0070F0  401A6002   MFC0 K0, SRSCtl
9D0070F4  27BDFF78   ADDIU SP, SP, -136
9D0070F8  AFBB0084   SW K1, 132(SP)
9D0070FC  401B6000   MFC0 K1, Status
9D007100  AFBA007C   SW K0, 124(SP)
9D007104  AFBB0080   SW K1, 128(SP)
9D007108  7C1B7844   INS K1, ZERO, 1, 15
9D00710C  377B0C00   ORI K1, K1, 3072
9D007110  409B6000   MTC0 K1, Status
9D007114  AFA3002C   SW V1, 44(SP)
9D007118  AFA20028   SW V0, 40(SP)
9D00711C  8FA3007C   LW V1, 124(SP)
9D007120  3063000F   ANDI V1, V1, 15
9D007124  14600012   BNE V1, ZERO, 0x9D007170
9D007128  00000000   NOP
9D00712C  AFBF006C   SW RA, 108(SP)
9D007130  AFBE0068   SW FP, 104(SP)
9D007134  AFB90064   SW T9, 100(SP)
9D007138  AFB80060   SW T8, 96(SP)
9D00713C  AFAF005C   SW T7, 92(SP)
9D007140  AFAE0058   SW T6, 88(SP)
9D007144  AFAD0054   SW T5, 84(SP)
9D007148  AFAC0050   SW T4, 80(SP)
9D00714C  AFAB004C   SW T3, 76(SP)
9D007150  AFAA0048   SW T2, 72(SP)
9D007154  AFA90044   SW T1, 68(SP)
9D007158  AFA80040   SW T0, 64(SP)
9D00715C  AFA7003C   SW A3, 60(SP)
9D007160  AFA60038   SW A2, 56(SP)
9D007164  AFA50034   SW A1, 52(SP)
9D007168  AFA40030   SW A0, 48(SP)
9D00716C  AFA10024   SW AT, 36(SP)
9D007170  00000000   NOP
9D007174  00001012   MFLO V0
9D007178  AFA20074   SW V0, 116(SP)
9D00717C  00001810   MFHI V1
9D007180  AFA30070   SW V1, 112(SP)
9D007184  03A0F021   ADDU FP, SP, ZERO
299:                 //    static uint8_t i = 0;
300:                     int8_t TXchar;
301:                     int8_t c = 0;
9D007188  A3C00010   SB ZERO, 16(FP)
302:                     USART_ERROR UsartStatus;   
303:                     
304:                      // Is this an Error interrupt ?
305:                     if ( PLIB_INT_SourceFlagGet(INT_ID_0, INT_SOURCE_USART_2_ERROR) &&
9D00718C  00002021   ADDU A0, ZERO, ZERO
9D007190  24050035   ADDIU A1, ZERO, 53
9D007194  0F4037E8   JAL PLIB_INT_SourceFlagGet
9D007198  00000000   NOP
9D00719C  1040000B   BEQ V0, ZERO, .LVL91
9D0071A0  00000000   NOP
9D0071B4  10400005   BEQ V0, ZERO, .LVL91
9D0071B8  00000000   NOP
306:                                  PLIB_INT_SourceIsEnabled(INT_ID_0, INT_SOURCE_USART_2_ERROR) ) 
9D0071A4  00002021   ADDU A0, ZERO, ZERO
9D0071A8  24050035   ADDIU A1, ZERO, 53
9D0071AC  0F4037F1   JAL PLIB_INT_SourceIsEnabled
9D0071B0  00000000   NOP
307:                     {
308:                         /* Clear pending interrupt */
309:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_USART_2_ERROR);
9D0071BC  00002021   ADDU A0, ZERO, ZERO
9D0071C0  24050035   ADDIU A1, ZERO, 53
9D0071C4  0F403790   JAL PLIB_INT_SourceFlagClear
9D0071C8  00000000   NOP
310:                         // Traitement de l'erreur  la rception.
311:                     } 
312:                 
313:                     // Is this an RX interrupt ?
314:                     if ( PLIB_INT_SourceFlagGet(INT_ID_0, INT_SOURCE_USART_2_RECEIVE) &&
9D0071CC  00002021   ADDU A0, ZERO, ZERO
9D0071D0  24050036   ADDIU A1, ZERO, 54
9D0071D4  0F4037E8   JAL PLIB_INT_SourceFlagGet
9D0071D8  00000000   NOP
9D0071DC  10400031   BEQ V0, ZERO, .LVL103
9D0071E0  00000000   NOP
9D0071F4  1040002B   BEQ V0, ZERO, .LVL103
9D0071F8  00000000   NOP
315:                                  PLIB_INT_SourceIsEnabled(INT_ID_0, INT_SOURCE_USART_2_RECEIVE))
9D0071E4  00002021   ADDU A0, ZERO, ZERO
9D0071E8  24050036   ADDIU A1, ZERO, 54
9D0071EC  0F4037F1   JAL PLIB_INT_SourceIsEnabled
9D0071F0  00000000   NOP
316:                     {
317:                 
318:                         // Oui Test si erreur parit ou overrun
319:                         UsartStatus = PLIB_USART_ErrorsGet(USART_ID_2);
9D0071FC  3C02BF80   LUI V0, -16512
9D007200  34446200   ORI A0, V0, 25088
9D007204  0F40391B   JAL PLIB_USART_ErrorsGet
9D007208  00000000   NOP
9D00720C  AFC20014   SW V0, 20(FP)
320:                 
321:                         if ((UsartStatus & (USART_ERROR_PARITY | USART_ERROR_FRAMING |  
9D007210  8FC20014   LW V0, 20(FP)
9D007214  30420007   ANDI V0, V0, 7
9D007218  1440001A   BNE V0, ZERO, 0x9D007284
9D00721C  00000000   NOP
322:                                 USART_ERROR_RECEIVER_OVERRUN)) == 0) 
323:                         {
324:                 
325:                             // Lecture des caractres depuis le buffer HW -> fifo SW
326:                 			//  (pour savoir s'il y a une data dans le buffer HW RX : 
327:                             // PLIB_USART_ReceiverDataIsAvailable())
328:                 			//  (Lecture via fonction PLIB_USART_ReceiverByteReceive())
329:                             
330:                 			//Tant qu'il des donnes dans le Fifo HW, on les mets dans le FifoSW
331:                             while(PLIB_USART_ReceiverDataIsAvailable(USART_ID_2))
9D007220  0B401C95   J .LVL100
9D007224  00000000   NOP
9D007254  3C02BF80   LUI V0, -16512
9D007258  34446200   ORI A0, V0, 25088
9D00725C  0F403921   JAL PLIB_USART_ReceiverDataIsAvailable
9D007260  00000000   NOP
9D007264  1440FFF0   BNE V0, ZERO, 0x9D007228
9D007268  00000000   NOP
332:                             {
333:                                 c = PLIB_USART_ReceiverByteReceive(USART_ID_2);
9D007228  3C02BF80   LUI V0, -16512
9D00722C  34446200   ORI A0, V0, 25088
9D007230  0F40391E   JAL PLIB_USART_ReceiverByteReceive
9D007234  00000000   NOP
9D007238  A3C20010   SB V0, 16(FP)
334:                                 PutCharInFifo(&descrFifoWifiRX, c);
9D00723C  93C20010   LBU V0, 16(FP)
9D007240  3C03A000   LUI V1, -24576
9D007244  246404B0   ADDIU A0, V1, 1200
9D007248  00402821   ADDU A1, V0, ZERO
9D00724C  0F40310F   JAL PutCharInFifo
9D007250  00000000   NOP
335:                             }
336:                             // buffer is empty, clear interrupt flag
337:                             PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_USART_2_RECEIVE);
9D00726C  00002021   ADDU A0, ZERO, ZERO
9D007270  24050036   ADDIU A1, ZERO, 54
9D007274  0F403790   JAL PLIB_INT_SourceFlagClear
9D007278  00000000   NOP
9D00727C  0B401CA9   J .LVL103
9D007280  00000000   NOP
338:                         } 
339:                         else 
340:                         {
341:                             // Suppression des erreurs
342:                             // La lecture des erreurs les efface sauf pour overrun
343:                             if ( (UsartStatus & USART_ERROR_RECEIVER_OVERRUN) 
9D007284  8FC20014   LW V0, 20(FP)
9D007288  30420001   ANDI V0, V0, 1
9D00728C  10400005   BEQ V0, ZERO, .LVL103
9D007290  00000000   NOP
344:                                     == USART_ERROR_RECEIVER_OVERRUN) 
345:                             {
346:                                    PLIB_USART_ReceiverOverrunErrorClear(USART_ID_2);
9D007294  3C02BF80   LUI V0, -16512
9D007298  34446200   ORI A0, V0, 25088
9D00729C  0F4038F0   JAL PLIB_USART_ReceiverOverrunErrorClear
9D0072A0  00000000   NOP
347:                             }
348:                         }
349:                     } // end if RX
350:                 
351:                     
352:                      // Is this an TX interrupt ?
353:                     if ( PLIB_INT_SourceFlagGet(INT_ID_0, INT_SOURCE_USART_2_TRANSMIT) 
9D0072A4  00002021   ADDU A0, ZERO, ZERO
9D0072A8  24050037   ADDIU A1, ZERO, 55
9D0072AC  0F4037E8   JAL PLIB_INT_SourceFlagGet
9D0072B0  00000000   NOP
9D0072B4  10400031   BEQ V0, ZERO, .LVL112
9D0072B8  00000000   NOP
354:                             && PLIB_INT_SourceIsEnabled(INT_ID_0, INT_SOURCE_USART_2_TRANSMIT)) 
9D0072BC  00002021   ADDU A0, ZERO, ZERO
9D0072C0  24050037   ADDIU A1, ZERO, 55
9D0072C4  0F4037F1   JAL PLIB_INT_SourceIsEnabled
9D0072C8  00000000   NOP
9D0072CC  1040002B   BEQ V0, ZERO, .LVL112
9D0072D0  00000000   NOP
355:                     {            
356:                         // Avant d'mettre, on vrifie 2 conditions :
357:                         //  S'il y a un caratres  mettre dans le fifo
358:                         //  S'il y a de la place dans le buffer d'mission 
359:                         // (PLIB_USART_TransmitterBufferIsFull)
360:                         //   (envoi avec PLIB_USART_TransmitterByteSend())
361:                          while((GetReadSize(&descrFifoWifiTX) > 0) && 
9D0072D4  0B401CC3   J .LVL107
9D0072D8  00000000   NOP
9D00730C  3C02A000   LUI V0, -24576
9D007310  24440AB4   ADDIU A0, V0, 2740
9D007314  0F403525   JAL GetReadSize
9D007318  00000000   NOP
9D00731C  18400009   BLEZ V0, 0x9D007344
9D007320  00000000   NOP
9D00733C  1440FFE7   BNE V0, ZERO, 0x9D0072DC
9D007340  00000000   NOP
362:                                  (PLIB_USART_TransmitterBufferIsFull(USART_ID_2) == false))
9D007324  3C02BF80   LUI V0, -16512
9D007328  34446200   ORI A0, V0, 25088
9D00732C  0F403927   JAL PLIB_USART_TransmitterBufferIsFull
9D007330  00000000   NOP
9D007334  38420001   XORI V0, V0, 1
9D007338  304200FF   ANDI V0, V0, 255
363:                         {
364:                             GetCharFromFifo(&descrFifoWifiTX, &TXchar);
9D0072DC  27C20018   ADDIU V0, FP, 24
9D0072E0  3C03A000   LUI V1, -24576
9D0072E4  24640AB4   ADDIU A0, V1, 2740
9D0072E8  00402821   ADDU A1, V0, ZERO
9D0072EC  0F403083   JAL GetCharFromFifo
9D0072F0  00000000   NOP
365:                             PLIB_USART_TransmitterByteSend(USART_ID_2, TXchar);
9D0072F4  83C20018   LB V0, 24(FP)
9D0072F8  3C03BF80   LUI V1, -16512
9D0072FC  34646200   ORI A0, V1, 25088
9D007300  00402821   ADDU A1, V0, ZERO
9D007304  0F403924   JAL PLIB_USART_TransmitterByteSend
9D007308  00000000   NOP
366:                 //            i++;
367:                         }
368:                             // disable TX interrupt (pour viter une interrupt. inutile si 
369:                             // plus rien  transmettre)
370:                         if (GetReadSize(&descrFifoWifiTX) == 0)
9D007344  3C02A000   LUI V0, -24576
9D007348  24440AB4   ADDIU A0, V0, 2740
9D00734C  0F403525   JAL GetReadSize
9D007350  00000000   NOP
9D007354  14400005   BNE V0, ZERO, .LVL111
9D007358  00000000   NOP
371:                             PLIB_INT_SourceDisable(INT_ID_0,INT_SOURCE_USART_2_TRANSMIT);
9D00735C  00002021   ADDU A0, ZERO, ZERO
9D007360  24050037   ADDIU A1, ZERO, 55
9D007364  0F4037A4   JAL PLIB_INT_SourceDisable
9D007368  00000000   NOP
372:                             
373:                         // Clear the TX interrupt Flag (Seulement apres TX) 
374:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_USART_2_TRANSMIT);
9D00736C  00002021   ADDU A0, ZERO, ZERO
9D007370  24050037   ADDIU A1, ZERO, 55
9D007374  0F403790   JAL PLIB_INT_SourceFlagClear
9D007378  00000000   NOP
375:                     }// end if TX
376:                 }
9D00737C  03C0E821   ADDU SP, FP, ZERO
9D007380  8FA20074   LW V0, 116(SP)
9D007384  00400013   MTLO V0
9D007388  8FA30070   LW V1, 112(SP)
9D00738C  00600011   MTHI V1
9D007390  8FA2007C   LW V0, 124(SP)
9D007394  3042000F   ANDI V0, V0, 15
9D007398  14400014   BNE V0, ZERO, 0x9D0073EC
9D00739C  00000000   NOP
9D0073A0  8FBF006C   LW RA, 108(SP)
9D0073A4  8FBE0068   LW FP, 104(SP)
9D0073A8  8FB90064   LW T9, 100(SP)
9D0073AC  8FB80060   LW T8, 96(SP)
9D0073B0  8FAF005C   LW T7, 92(SP)
9D0073B4  8FAE0058   LW T6, 88(SP)
9D0073B8  8FAD0054   LW T5, 84(SP)
9D0073BC  8FAC0050   LW T4, 80(SP)
9D0073C0  8FAB004C   LW T3, 76(SP)
9D0073C4  8FAA0048   LW T2, 72(SP)
9D0073C8  8FA90044   LW T1, 68(SP)
9D0073CC  8FA80040   LW T0, 64(SP)
9D0073D0  8FA7003C   LW A3, 60(SP)
9D0073D4  8FA60038   LW A2, 56(SP)
9D0073D8  8FA50034   LW A1, 52(SP)
9D0073DC  8FA40030   LW A0, 48(SP)
9D0073E0  8FA3002C   LW V1, 44(SP)
9D0073E4  8FA20028   LW V0, 40(SP)
9D0073E8  8FA10024   LW AT, 36(SP)
9D0073EC  00000000   NOP
9D0073F0  41606000   DI ZERO
9D0073F4  000000C0   EHB
9D0073F8  8FBA0084   LW K0, 132(SP)
9D0073FC  8FBB0080   LW K1, 128(SP)
9D007400  409A7000   MTC0 K0, EPC
9D007404  8FBA007C   LW K0, 124(SP)
9D007408  27BD0088   ADDIU SP, SP, 136
9D00740C  409A6002   MTC0 K0, SRSCtl
9D007410  41DDE800   WRPGPR SP, SP
9D007414  409B6000   MTC0 K1, Status
9D007418  42000018   ERET
377:                 
378:                 // Interruption USART1 - USB
379:                 void __ISR(_UART_1_VECTOR, ipl3AUTO) _IntHandlerDrvUsartInstance1(void)
380:                 {
9D00741C  415DE800   RDPGPR SP, SP
9D007420  401B7000   MFC0 K1, EPC
9D007424  401A6002   MFC0 K0, SRSCtl
9D007428  27BDFF78   ADDIU SP, SP, -136
9D00742C  AFBB0084   SW K1, 132(SP)
9D007430  401B6000   MFC0 K1, Status
9D007434  AFBA007C   SW K0, 124(SP)
9D007438  AFBB0080   SW K1, 128(SP)
9D00743C  7C1B7844   INS K1, ZERO, 1, 15
9D007440  377B0C00   ORI K1, K1, 3072
9D007444  409B6000   MTC0 K1, Status
9D007448  AFA3002C   SW V1, 44(SP)
9D00744C  AFA20028   SW V0, 40(SP)
9D007450  8FA3007C   LW V1, 124(SP)
9D007454  3063000F   ANDI V1, V1, 15
9D007458  14600012   BNE V1, ZERO, 0x9D0074A4
9D00745C  00000000   NOP
9D007460  AFBF006C   SW RA, 108(SP)
9D007464  AFBE0068   SW FP, 104(SP)
9D007468  AFB90064   SW T9, 100(SP)
9D00746C  AFB80060   SW T8, 96(SP)
9D007470  AFAF005C   SW T7, 92(SP)
9D007474  AFAE0058   SW T6, 88(SP)
9D007478  AFAD0054   SW T5, 84(SP)
9D00747C  AFAC0050   SW T4, 80(SP)
9D007480  AFAB004C   SW T3, 76(SP)
9D007484  AFAA0048   SW T2, 72(SP)
9D007488  AFA90044   SW T1, 68(SP)
9D00748C  AFA80040   SW T0, 64(SP)
9D007490  AFA7003C   SW A3, 60(SP)
9D007494  AFA60038   SW A2, 56(SP)
9D007498  AFA50034   SW A1, 52(SP)
9D00749C  AFA40030   SW A0, 48(SP)
9D0074A0  AFA10024   SW AT, 36(SP)
9D0074A4  00000000   NOP
9D0074A8  00001012   MFLO V0
9D0074AC  AFA20074   SW V0, 116(SP)
9D0074B0  00001810   MFHI V1
9D0074B4  AFA30070   SW V1, 112(SP)
9D0074B8  03A0F021   ADDU FP, SP, ZERO
381:                 //    static uint8_t i = 0;
382:                     int8_t TXchar;
383:                     int8_t c = 0;
9D0074BC  A3C00010   SB ZERO, 16(FP)
384:                     USART_ERROR UsartStatus;   
385:                     
386:                      // Is this an Error interrupt ?
387:                     if ( PLIB_INT_SourceFlagGet(INT_ID_0, INT_SOURCE_USART_1_ERROR) &&
9D0074C0  00002021   ADDU A0, ZERO, ZERO
9D0074C4  24050027   ADDIU A1, ZERO, 39
9D0074C8  0F4037E8   JAL PLIB_INT_SourceFlagGet
9D0074CC  00000000   NOP
9D0074D0  1040000B   BEQ V0, ZERO, .LVL116
9D0074D4  00000000   NOP
9D0074E8  10400005   BEQ V0, ZERO, .LVL116
9D0074EC  00000000   NOP
388:                                  PLIB_INT_SourceIsEnabled(INT_ID_0, INT_SOURCE_USART_1_ERROR) ) 
9D0074D8  00002021   ADDU A0, ZERO, ZERO
9D0074DC  24050027   ADDIU A1, ZERO, 39
9D0074E0  0F4037F1   JAL PLIB_INT_SourceIsEnabled
9D0074E4  00000000   NOP
389:                     {
390:                         // Clear pending interrupt 
391:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_USART_1_ERROR);
9D0074F0  00002021   ADDU A0, ZERO, ZERO
9D0074F4  24050027   ADDIU A1, ZERO, 39
9D0074F8  0F403790   JAL PLIB_INT_SourceFlagClear
9D0074FC  00000000   NOP
392:                         // Traitement de l'erreur  la rception.
393:                     }
394:                    
395:                 
396:                     // Is this an RX interrupt ?
397:                     if ( PLIB_INT_SourceFlagGet(INT_ID_0, INT_SOURCE_USART_1_RECEIVE) &&
9D007500  00002021   ADDU A0, ZERO, ZERO
9D007504  24050028   ADDIU A1, ZERO, 40
9D007508  0F4037E8   JAL PLIB_INT_SourceFlagGet
9D00750C  00000000   NOP
9D007510  10400031   BEQ V0, ZERO, .LVL128
9D007514  00000000   NOP
9D007528  1040002B   BEQ V0, ZERO, .LVL128
9D00752C  00000000   NOP
398:                                  PLIB_INT_SourceIsEnabled(INT_ID_0, INT_SOURCE_USART_1_RECEIVE))
9D007518  00002021   ADDU A0, ZERO, ZERO
9D00751C  24050028   ADDIU A1, ZERO, 40
9D007520  0F4037F1   JAL PLIB_INT_SourceIsEnabled
9D007524  00000000   NOP
399:                     {
400:                 
401:                         // Oui Test si erreur parit ou overrun
402:                         UsartStatus = PLIB_USART_ErrorsGet(USART_ID_1);
9D007530  3C02BF80   LUI V0, -16512
9D007534  34446000   ORI A0, V0, 24576
9D007538  0F40391B   JAL PLIB_USART_ErrorsGet
9D00753C  00000000   NOP
9D007540  AFC20014   SW V0, 20(FP)
403:                 
404:                         if ((UsartStatus & (USART_ERROR_PARITY | USART_ERROR_FRAMING |  
9D007544  8FC20014   LW V0, 20(FP)
9D007548  30420007   ANDI V0, V0, 7
9D00754C  1440001A   BNE V0, ZERO, 0x9D0075B8
9D007550  00000000   NOP
405:                                 USART_ERROR_RECEIVER_OVERRUN)) == 0) 
406:                         {
407:                             // Lecture des caractres depuis le buffer HW -> fifo SW
408:                 			//  (pour savoir s'il y a une data dans le buffer HW RX : 
409:                             // PLIB_USART_ReceiverDataIsAvailable())
410:                 			//  (Lecture via fonction PLIB_USART_ReceiverByteReceive())
411:                             
412:                 			//Tant qu'il des donnes dans le Fifo HW, on les mets dans le FifoSW
413:                             while(PLIB_USART_ReceiverDataIsAvailable(USART_ID_1))
9D007554  0B401D62   J .LVL125
9D007558  00000000   NOP
9D007588  3C02BF80   LUI V0, -16512
9D00758C  34446000   ORI A0, V0, 24576
9D007590  0F403921   JAL PLIB_USART_ReceiverDataIsAvailable
9D007594  00000000   NOP
9D007598  1440FFF0   BNE V0, ZERO, 0x9D00755C
9D00759C  00000000   NOP
414:                             {
415:                                 c = PLIB_USART_ReceiverByteReceive(USART_ID_1);
9D00755C  3C02BF80   LUI V0, -16512
9D007560  34446000   ORI A0, V0, 24576
9D007564  0F40391E   JAL PLIB_USART_ReceiverByteReceive
9D007568  00000000   NOP
9D00756C  A3C20010   SB V0, 16(FP)
416:                                 PutCharInFifo(&descrFifoUSBRX, c);
9D007570  93C20010   LBU V0, 16(FP)
9D007574  3C03A000   LUI V1, -24576
9D007578  2464049C   ADDIU A0, V1, 1180
9D00757C  00402821   ADDU A1, V0, ZERO
9D007580  0F40310F   JAL PutCharInFifo
9D007584  00000000   NOP
417:                             }
418:                             // buffer is empty, clear interrupt flag
419:                             PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_USART_1_RECEIVE);
9D0075A0  00002021   ADDU A0, ZERO, ZERO
9D0075A4  24050028   ADDIU A1, ZERO, 40
9D0075A8  0F403790   JAL PLIB_INT_SourceFlagClear
9D0075AC  00000000   NOP
9D0075B0  0B401D76   J .LVL128
9D0075B4  00000000   NOP
420:                         } 
421:                         else 
422:                         {
423:                             // Suppression des erreurs
424:                             // La lecture des erreurs les efface sauf pour overrun
425:                             if ( (UsartStatus & USART_ERROR_RECEIVER_OVERRUN) 
9D0075B8  8FC20014   LW V0, 20(FP)
9D0075BC  30420001   ANDI V0, V0, 1
9D0075C0  10400005   BEQ V0, ZERO, .LVL128
9D0075C4  00000000   NOP
426:                                     == USART_ERROR_RECEIVER_OVERRUN) 
427:                             {
428:                                    PLIB_USART_ReceiverOverrunErrorClear(USART_ID_1);
9D0075C8  3C02BF80   LUI V0, -16512
9D0075CC  34446000   ORI A0, V0, 24576
9D0075D0  0F4038F0   JAL PLIB_USART_ReceiverOverrunErrorClear
9D0075D4  00000000   NOP
429:                             }
430:                         }
431:                     } // end if RX
432:                 
433:                     
434:                      // Is this an TX interrupt ?
435:                     if ( PLIB_INT_SourceFlagGet(INT_ID_0, INT_SOURCE_USART_1_TRANSMIT) 
9D0075D8  00002021   ADDU A0, ZERO, ZERO
9D0075DC  24050029   ADDIU A1, ZERO, 41
9D0075E0  0F4037E8   JAL PLIB_INT_SourceFlagGet
9D0075E4  00000000   NOP
9D0075E8  10400031   BEQ V0, ZERO, .LVL137
9D0075EC  00000000   NOP
436:                             && PLIB_INT_SourceIsEnabled(INT_ID_0, INT_SOURCE_USART_1_TRANSMIT)) 
9D0075F0  00002021   ADDU A0, ZERO, ZERO
9D0075F4  24050029   ADDIU A1, ZERO, 41
9D0075F8  0F4037F1   JAL PLIB_INT_SourceIsEnabled
9D0075FC  00000000   NOP
9D007600  1040002B   BEQ V0, ZERO, .LVL137
9D007604  00000000   NOP
437:                     {
438:                         // Avant d'mettre, on vrifie 2 conditions :
439:                         //  S'il y a un caratres  mettre dans le fifo
440:                         //  S'il y a de la place dans le buffer d'mission 
441:                         // (PLIB_USART_TransmitterBufferIsFull)
442:                         //   (envoi avec PLIB_USART_TransmitterByteSend())
443:                          while((GetReadSize(&descrFifoUSBTX) > 0) && 
9D007608  0B401D90   J .LVL132
9D00760C  00000000   NOP
9D007640  3C02A000   LUI V0, -24576
9D007644  24440AA0   ADDIU A0, V0, 2720
9D007648  0F403525   JAL GetReadSize
9D00764C  00000000   NOP
9D007650  18400009   BLEZ V0, 0x9D007678
9D007654  00000000   NOP
9D007670  1440FFE7   BNE V0, ZERO, 0x9D007610
9D007674  00000000   NOP
444:                                  (PLIB_USART_TransmitterBufferIsFull(USART_ID_1) == false))
9D007658  3C02BF80   LUI V0, -16512
9D00765C  34446000   ORI A0, V0, 24576
9D007660  0F403927   JAL PLIB_USART_TransmitterBufferIsFull
9D007664  00000000   NOP
9D007668  38420001   XORI V0, V0, 1
9D00766C  304200FF   ANDI V0, V0, 255
445:                         {
446:                             GetCharFromFifo(&descrFifoUSBTX, &TXchar);
9D007610  27C20018   ADDIU V0, FP, 24
9D007614  3C03A000   LUI V1, -24576
9D007618  24640AA0   ADDIU A0, V1, 2720
9D00761C  00402821   ADDU A1, V0, ZERO
9D007620  0F403083   JAL GetCharFromFifo
9D007624  00000000   NOP
447:                             PLIB_USART_TransmitterByteSend(USART_ID_1, TXchar);
9D007628  83C20018   LB V0, 24(FP)
9D00762C  3C03BF80   LUI V1, -16512
9D007630  34646000   ORI A0, V1, 24576
9D007634  00402821   ADDU A1, V0, ZERO
9D007638  0F403924   JAL PLIB_USART_TransmitterByteSend
9D00763C  00000000   NOP
448:                 //            i++;
449:                         }
450:                             // disable TX interrupt (pour viter une interrupt. inutile si 
451:                             // plus rien  transmettre)
452:                         if (GetReadSize(&descrFifoUSBTX) == 0)
9D007678  3C02A000   LUI V0, -24576
9D00767C  24440AA0   ADDIU A0, V0, 2720
9D007680  0F403525   JAL GetReadSize
9D007684  00000000   NOP
9D007688  14400005   BNE V0, ZERO, .LVL136
9D00768C  00000000   NOP
453:                             PLIB_INT_SourceDisable(INT_ID_0,INT_SOURCE_USART_1_TRANSMIT);
9D007690  00002021   ADDU A0, ZERO, ZERO
9D007694  24050029   ADDIU A1, ZERO, 41
9D007698  0F4037A4   JAL PLIB_INT_SourceDisable
9D00769C  00000000   NOP
454:                             
455:                         // Clear the TX interrupt Flag (Seulement apres TX) 
456:                         PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_USART_1_TRANSMIT);
9D0076A0  00002021   ADDU A0, ZERO, ZERO
9D0076A4  24050029   ADDIU A1, ZERO, 41
9D0076A8  0F403790   JAL PLIB_INT_SourceFlagClear
9D0076AC  00000000   NOP
457:                         
458:                     }// end if TX
459:                 }
9D0076B0  03C0E821   ADDU SP, FP, ZERO
9D0076B4  8FA20074   LW V0, 116(SP)
9D0076B8  00400013   MTLO V0
9D0076BC  8FA30070   LW V1, 112(SP)
9D0076C0  00600011   MTHI V1
9D0076C4  8FA2007C   LW V0, 124(SP)
9D0076C8  3042000F   ANDI V0, V0, 15
9D0076CC  14400014   BNE V0, ZERO, 0x9D007720
9D0076D0  00000000   NOP
9D0076D4  8FBF006C   LW RA, 108(SP)
9D0076D8  8FBE0068   LW FP, 104(SP)
9D0076DC  8FB90064   LW T9, 100(SP)
9D0076E0  8FB80060   LW T8, 96(SP)
9D0076E4  8FAF005C   LW T7, 92(SP)
9D0076E8  8FAE0058   LW T6, 88(SP)
9D0076EC  8FAD0054   LW T5, 84(SP)
9D0076F0  8FAC0050   LW T4, 80(SP)
9D0076F4  8FAB004C   LW T3, 76(SP)
9D0076F8  8FAA0048   LW T2, 72(SP)
9D0076FC  8FA90044   LW T1, 68(SP)
9D007700  8FA80040   LW T0, 64(SP)
9D007704  8FA7003C   LW A3, 60(SP)
9D007708  8FA60038   LW A2, 56(SP)
9D00770C  8FA50034   LW A1, 52(SP)
9D007710  8FA40030   LW A0, 48(SP)
9D007714  8FA3002C   LW V1, 44(SP)
9D007718  8FA20028   LW V0, 40(SP)
9D00771C  8FA10024   LW AT, 36(SP)
9D007720  00000000   NOP
9D007724  41606000   DI ZERO
9D007728  000000C0   EHB
9D00772C  8FBA0084   LW K0, 132(SP)
9D007730  8FBB0080   LW K1, 128(SP)
9D007734  409A7000   MTC0 K0, EPC
9D007738  8FBA007C   LW K0, 124(SP)
9D00773C  27BD0088   ADDIU SP, SP, 136
9D007740  409A6002   MTC0 K0, SRSCtl
9D007744  41DDE800   WRPGPR SP, SP
9D007748  409B6000   MTC0 K1, Status
9D00774C  42000018   ERET
460:                 
461:                 
462:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/mc32gest_i2c.c  ------------
1:                   //--------------------------------------------------------
2:                   // Mc32gestI2cSensor.C
3:                   //--------------------------------------------------------
4:                   // Gestion I2C pour la communication I2C
5:                   //	Description     :	Fonctions pour la communication en I2C
6:                   //
7:                   //	Auteur          : 	D. Rickenbach
8:                   //  Date            :   18.05.2020
9:                   //	Version         :	V1
10:                  //	Compilateur     :	XC32 V5.15 & Harmony 2_06
11:                  // Modifications    :
12:                  //
13:                  /*--------------------------------------------------------*/
14:                  
15:                  
16:                  #include "Mc32gest_I2C.h"
17:                  #include "Mc32_I2cUtilCCS.h"
18:                  
19:                  // Initialisation de la communication I2C
20:                  void I2C_Init(void)
21:                  {
9D00DB40  27BDFFE0   ADDIU SP, SP, -32
9D00DB44  AFBF001C   SW RA, 28(SP)
9D00DB48  AFBE0018   SW FP, 24(SP)
9D00DB4C  03A0F021   ADDU FP, SP, ZERO
22:                     bool Fast = false;
9D00DB50  A3C00010   SB ZERO, 16(FP)
23:                     i2c_init( Fast );
9D00DB54  93C20010   LBU V0, 16(FP)
9D00DB58  00402021   ADDU A0, V0, ZERO
9D00DB5C  0F402D60   JAL i2c_init
9D00DB60  00000000   NOP
24:                  } //end I2CSensor_Init
9D00DB64  03C0E821   ADDU SP, FP, ZERO
9D00DB68  8FBF001C   LW RA, 28(SP)
9D00DB6C  8FBE0018   LW FP, 24(SP)
9D00DB70  27BD0020   ADDIU SP, SP, 32
9D00DB74  03E00008   JR RA
9D00DB78  00000000   NOP
25:                  
26:                  // Ecriture d'un bloc  
27:                  void I2CSensor_Write( uint8_t Device, uint8_t Reg, uint8_t* Data, uint8_t NbBytes)
28:                  {
00000000  00000000   NOP
29:                      uint8_t i;
30:                      //uint8_t* pData = Data;
31:                      
32:                      Device = Device << 1; // dcalage d'un bit pour le bit W/R
00000028  00000000   NOP
33:                      
34:                      i2c_start();
00000034  00000000   NOP
35:                      
36:                      i2c_write(Device + 0); // "+0" pour que l'adresse soit en mode criture
0000003C  00000000   NOP
37:                      i2c_write(Reg);
0000004C  00000000   NOP
38:                      
39:                      for(i = 0; i < NbBytes; i++)
0000005C  00000000   NOP
00000088  00000000   NOP
40:                      {
41:                          i2c_write(*Data);
00000068  00000000   NOP
42:                          Data++;
0000007C  00000000   NOP
43:                      }
44:                      
45:                      i2c_stop();
000000A8  00000000   NOP
46:                  } // end I2CSensor_Write
000000B0  00000000   NOP
47:                  
48:                  // Ecriture d'un byte
49:                  void I2CSensor_Write8(uint8_t Device, uint8_t Reg, uint8_t Data)
50:                  {
9D00CD9C  27BDFFE8   ADDIU SP, SP, -24
9D00CDA0  AFBF0014   SW RA, 20(SP)
9D00CDA4  AFBE0010   SW FP, 16(SP)
9D00CDA8  03A0F021   ADDU FP, SP, ZERO
9D00CDAC  00A01821   ADDU V1, A1, ZERO
9D00CDB0  00C01021   ADDU V0, A2, ZERO
9D00CDB4  A3C40018   SB A0, 24(FP)
9D00CDB8  A3C3001C   SB V1, 28(FP)
9D00CDBC  A3C20020   SB V0, 32(FP)
51:                      Device = Device << 1; // dcalage d'un bit pour le bit W/R
9D00CDC0  93C20018   LBU V0, 24(FP)
9D00CDC4  00021040   SLL V0, V0, 1
9D00CDC8  A3C20018   SB V0, 24(FP)
52:                      
53:                      i2c_start();
9D00CDCC  0F402C6F   JAL i2c_start
9D00CDD0  00000000   NOP
54:                      
55:                      i2c_write(Device +0); // "+0" pour que l'adresse soit en mode criture
9D00CDD4  93C20018   LBU V0, 24(FP)
9D00CDD8  00402021   ADDU A0, V0, ZERO
9D00CDDC  0F402DD5   JAL i2c_write
9D00CDE0  00000000   NOP
56:                      i2c_write(Reg);
9D00CDE4  93C2001C   LBU V0, 28(FP)
9D00CDE8  00402021   ADDU A0, V0, ZERO
9D00CDEC  0F402DD5   JAL i2c_write
9D00CDF0  00000000   NOP
57:                      i2c_write(Data);
9D00CDF4  93C20020   LBU V0, 32(FP)
9D00CDF8  00402021   ADDU A0, V0, ZERO
9D00CDFC  0F402DD5   JAL i2c_write
9D00CE00  00000000   NOP
58:                      
59:                      i2c_stop();
9D00CE04  0F4033AA   JAL i2c_stop
9D00CE08  00000000   NOP
60:                  } // end I2CSensor_Write8
9D00CE0C  03C0E821   ADDU SP, FP, ZERO
9D00CE10  8FBF0014   LW RA, 20(SP)
9D00CE14  8FBE0010   LW FP, 16(SP)
9D00CE18  27BD0018   ADDIU SP, SP, 24
9D00CE1C  03E00008   JR RA
9D00CE20  00000000   NOP
61:                  
62:                  // Lecture d'un bloc
63:                  void I2CSensor_Read(uint8_t Device, uint8_t Reg, uint8_t* Data, uint8_t NbBytes)
64:                  {
00000000  00000000   NOP
65:                      uint8_t i;
66:                      uint8_t* pByteData = Data;
0000002C  00000000   NOP
67:                      Device = Device << 1; // dcalage d'un bit pour le bit W/R
00000034  00000000   NOP
68:                      
69:                      i2c_start();
00000040  00000000   NOP
70:                      i2c_write(Device +0); // "+0" pour que l'adresse soit en mode criture
00000048  00000000   NOP
71:                      i2c_write(Reg);    
00000058  00000000   NOP
72:                      
73:                      i2c_reStart();
00000068  00000000   NOP
74:                      i2c_write(Device +1); // "+1" pour que l'adresse soit en mode lecture
00000070  00000000   NOP
75:                      for(i = 0; i < NbBytes - 1; i++)
00000088  00000000   NOP
000000B0  00000000   NOP
76:                      {
77:                          pByteData[i] = i2c_read(1); // lecture du registre avec acknowledge
00000094  00000000   NOP
78:                      }
79:                      i++;
000000D4  00000000   NOP
80:                      pByteData[i] = i2c_read(0); // lecture du registre sans acknowledge
000000E0  00000000   NOP
81:                      i2c_stop();
000000FC  00000000   NOP
82:                      
83:                  } // end I2CSensor_Read
00000104  00000000   NOP
84:                  
85:                  // Lecture d'un byte
86:                  uint8_t I2CSensor_Read8(uint8_t Device, uint8_t Reg)
87:                  {
9D00C6EC  27BDFFE0   ADDIU SP, SP, -32
9D00C6F0  AFBF001C   SW RA, 28(SP)
9D00C6F4  AFBE0018   SW FP, 24(SP)
9D00C6F8  03A0F021   ADDU FP, SP, ZERO
9D00C6FC  00801821   ADDU V1, A0, ZERO
9D00C700  00A01021   ADDU V0, A1, ZERO
9D00C704  A3C30020   SB V1, 32(FP)
9D00C708  A3C20024   SB V0, 36(FP)
88:                      uint8_t Data;
89:                      
90:                      Device = Device << 1; // dcalage d'un bit pour le bit W/R
9D00C70C  93C20020   LBU V0, 32(FP)
9D00C710  00021040   SLL V0, V0, 1
9D00C714  A3C20020   SB V0, 32(FP)
91:                      
92:                      i2c_start();
9D00C718  0F402C6F   JAL i2c_start
9D00C71C  00000000   NOP
93:                      
94:                      i2c_write(Device +0); // "+0" pour que l'adresse soit en mode criture
9D00C720  93C20020   LBU V0, 32(FP)
9D00C724  00402021   ADDU A0, V0, ZERO
9D00C728  0F402DD5   JAL i2c_write
9D00C72C  00000000   NOP
95:                      i2c_write(Reg);
9D00C730  93C20024   LBU V0, 36(FP)
9D00C734  00402021   ADDU A0, V0, ZERO
9D00C738  0F402DD5   JAL i2c_write
9D00C73C  00000000   NOP
96:                      
97:                      i2c_reStart();
9D00C740  0F402F55   JAL i2c_reStart
9D00C744  00000000   NOP
98:                      i2c_write(Device +1); // "+1" pour que l'adresse soit en mode lecture
9D00C748  93C20020   LBU V0, 32(FP)
9D00C74C  24420001   ADDIU V0, V0, 1
9D00C750  304200FF   ANDI V0, V0, 255
9D00C754  00402021   ADDU A0, V0, ZERO
9D00C758  0F402DD5   JAL i2c_write
9D00C75C  00000000   NOP
99:                      Data = i2c_read(0);   // lecture du registre sans acknowledge
9D00C760  00002021   ADDU A0, ZERO, ZERO
9D00C764  0F40283C   JAL i2c_read
9D00C768  00000000   NOP
9D00C76C  A3C20010   SB V0, 16(FP)
100:                     
101:                     i2c_stop();
9D00C770  0F4033AA   JAL i2c_stop
9D00C774  00000000   NOP
102:                     
103:                     return Data;
9D00C778  93C20010   LBU V0, 16(FP)
104:                 } // end I2CSensor_Read8
9D00C77C  03C0E821   ADDU SP, FP, ZERO
9D00C780  8FBF001C   LW RA, 28(SP)
9D00C784  8FBE0018   LW FP, 24(SP)
9D00C788  27BD0020   ADDIU SP, SP, 32
9D00C78C  03E00008   JR RA
9D00C790  00000000   NOP
105:                 
106:                 // Lecture de deux byte non-sign
107:                 uint16_t I2CSensor_Read16(uint8_t Device, uint8_t Reg)
108:                 {
9D00BBB4  27BDFFE0   ADDIU SP, SP, -32
9D00BBB8  AFBF001C   SW RA, 28(SP)
9D00BBBC  AFBE0018   SW FP, 24(SP)
9D00BBC0  03A0F021   ADDU FP, SP, ZERO
9D00BBC4  00801821   ADDU V1, A0, ZERO
9D00BBC8  00A01021   ADDU V0, A1, ZERO
9D00BBCC  A3C30020   SB V1, 32(FP)
9D00BBD0  A3C20024   SB V0, 36(FP)
109:                     uint16_t Data;
110:                     Device = Device << 1; // dcalage d'un bit pour le bit W/R
9D00BBD4  93C20020   LBU V0, 32(FP)
9D00BBD8  00021040   SLL V0, V0, 1
9D00BBDC  A3C20020   SB V0, 32(FP)
111:                     
112:                     i2c_start();
9D00BBE0  0F402C6F   JAL i2c_start
9D00BBE4  00000000   NOP
113:                     i2c_write(Device +0); // "+0" pour que l'adresse soit en mode criture
9D00BBE8  93C20020   LBU V0, 32(FP)
9D00BBEC  00402021   ADDU A0, V0, ZERO
9D00BBF0  0F402DD5   JAL i2c_write
9D00BBF4  00000000   NOP
114:                     i2c_write(Reg);
9D00BBF8  93C20024   LBU V0, 36(FP)
9D00BBFC  00402021   ADDU A0, V0, ZERO
9D00BC00  0F402DD5   JAL i2c_write
9D00BC04  00000000   NOP
115:                     
116:                     i2c_reStart();
9D00BC08  0F402F55   JAL i2c_reStart
9D00BC0C  00000000   NOP
117:                     i2c_write(Device +1); // "+1" pour que l'adresse soit en mode lecture
9D00BC10  93C20020   LBU V0, 32(FP)
9D00BC14  24420001   ADDIU V0, V0, 1
9D00BC18  304200FF   ANDI V0, V0, 255
9D00BC1C  00402021   ADDU A0, V0, ZERO
9D00BC20  0F402DD5   JAL i2c_write
9D00BC24  00000000   NOP
118:                     Data = i2c_read(1);
9D00BC28  24040001   ADDIU A0, ZERO, 1
9D00BC2C  0F40283C   JAL i2c_read
9D00BC30  00000000   NOP
9D00BC34  A7C20010   SH V0, 16(FP)
119:                     Data <<= 8;
9D00BC38  97C20010   LHU V0, 16(FP)
9D00BC3C  00021200   SLL V0, V0, 8
9D00BC40  A7C20010   SH V0, 16(FP)
120:                     Data |= i2c_read(0);
9D00BC44  00002021   ADDU A0, ZERO, ZERO
9D00BC48  0F40283C   JAL i2c_read
9D00BC4C  00000000   NOP
9D00BC50  00401821   ADDU V1, V0, ZERO
9D00BC54  97C20010   LHU V0, 16(FP)
9D00BC58  00621025   OR V0, V1, V0
9D00BC5C  A7C20010   SH V0, 16(FP)
121:                     i2c_stop();
9D00BC60  0F4033AA   JAL i2c_stop
9D00BC64  00000000   NOP
122:                     
123:                     return Data;
9D00BC68  97C20010   LHU V0, 16(FP)
124:                 } // end I2CSensor_Read16
9D00BC6C  03C0E821   ADDU SP, FP, ZERO
9D00BC70  8FBF001C   LW RA, 28(SP)
9D00BC74  8FBE0018   LW FP, 24(SP)
9D00BC78  27BD0020   ADDIU SP, SP, 32
9D00BC7C  03E00008   JR RA
9D00BC80  00000000   NOP
125:                 
126:                 // Lecture de deux byte en Little endian
127:                 uint16_t I2CSensor_Read16_LE(uint8_t Device, uint8_t Reg)
128:                 {
9D00D124  27BDFFE0   ADDIU SP, SP, -32
9D00D128  AFBF001C   SW RA, 28(SP)
9D00D12C  AFBE0018   SW FP, 24(SP)
9D00D130  03A0F021   ADDU FP, SP, ZERO
9D00D134  00801821   ADDU V1, A0, ZERO
9D00D138  00A01021   ADDU V0, A1, ZERO
9D00D13C  A3C30020   SB V1, 32(FP)
9D00D140  A3C20024   SB V0, 36(FP)
129:                     uint16_t Data = I2CSensor_Read16(Device, Reg);
9D00D144  93C30020   LBU V1, 32(FP)
9D00D148  93C20024   LBU V0, 36(FP)
9D00D14C  00602021   ADDU A0, V1, ZERO
9D00D150  00402821   ADDU A1, V0, ZERO
9D00D154  0F402EED   JAL I2CSensor_Read16
9D00D158  00000000   NOP
9D00D15C  A7C20010   SH V0, 16(FP)
130:                     return (Data >> 8) | (Data << 8);
9D00D160  97C20010   LHU V0, 16(FP)
9D00D164  00021202   SRL V0, V0, 8
9D00D168  3042FFFF   ANDI V0, V0, -1
9D00D16C  7C021E20   SEH V1, V0
9D00D170  97C20010   LHU V0, 16(FP)
9D00D174  00021200   SLL V0, V0, 8
9D00D178  7C021620   SEH V0, V0
9D00D17C  00621025   OR V0, V1, V0
9D00D180  7C021620   SEH V0, V0
9D00D184  3042FFFF   ANDI V0, V0, -1
131:                 } // end I2CSensor_Read16_LE
9D00D188  03C0E821   ADDU SP, FP, ZERO
9D00D18C  8FBF001C   LW RA, 28(SP)
9D00D190  8FBE0018   LW FP, 24(SP)
9D00D194  27BD0020   ADDIU SP, SP, 32
9D00D198  03E00008   JR RA
9D00D19C  00000000   NOP
132:                 
133:                 // Lecture de deux byte en sign
134:                 int16_t I2CSensor_ReadS16(uint8_t Device, uint8_t Reg)
135:                 {
00000000  00000000   NOP
136:                     return (int16_t)I2CSensor_Read16(Device, Reg);
00000020  00000000   NOP
137:                 } // end I2CSensor_ReadS16
0000003C  00000000   NOP
138:                 
139:                 // Lecture de deux byte signs en Little endian
140:                 int16_t I2CSensor_ReadS16_LE(uint8_t Device, uint8_t Reg)
141:                 {
9D00D740  27BDFFE8   ADDIU SP, SP, -24
9D00D744  AFBF0014   SW RA, 20(SP)
9D00D748  AFBE0010   SW FP, 16(SP)
9D00D74C  03A0F021   ADDU FP, SP, ZERO
9D00D750  00801821   ADDU V1, A0, ZERO
9D00D754  00A01021   ADDU V0, A1, ZERO
9D00D758  A3C30018   SB V1, 24(FP)
9D00D75C  A3C2001C   SB V0, 28(FP)
142:                     return (int16_t)I2CSensor_Read16_LE(Device,  Reg);
9D00D760  93C30018   LBU V1, 24(FP)
9D00D764  93C2001C   LBU V0, 28(FP)
9D00D768  00602021   ADDU A0, V1, ZERO
9D00D76C  00402821   ADDU A1, V0, ZERO
9D00D770  0F403449   JAL I2CSensor_Read16_LE
9D00D774  00000000   NOP
9D00D778  7C021620   SEH V0, V0
143:                 } // end I2CSensor_ReadS16_LE
9D00D77C  03C0E821   ADDU SP, FP, ZERO
9D00D780  8FBF0014   LW RA, 20(SP)
9D00D784  8FBE0010   LW FP, 16(SP)
9D00D788  27BD0018   ADDIU SP, SP, 24
9D00D78C  03E00008   JR RA
9D00D790  00000000   NOP
144:                 
145:                 // Lecture de trois byte
146:                 uint32_t I2CSensor_Read24(uint8_t Device, uint8_t Reg)
147:                 {
9D00B39C  27BDFFE0   ADDIU SP, SP, -32
9D00B3A0  AFBF001C   SW RA, 28(SP)
9D00B3A4  AFBE0018   SW FP, 24(SP)
9D00B3A8  03A0F021   ADDU FP, SP, ZERO
9D00B3AC  00801821   ADDU V1, A0, ZERO
9D00B3B0  00A01021   ADDU V0, A1, ZERO
9D00B3B4  A3C30020   SB V1, 32(FP)
9D00B3B8  A3C20024   SB V0, 36(FP)
148:                     uint32_t Data;
149:                     Device = Device << 1; // dcalage d'un bit pour le bit W/R
9D00B3BC  93C20020   LBU V0, 32(FP)
9D00B3C0  00021040   SLL V0, V0, 1
9D00B3C4  A3C20020   SB V0, 32(FP)
150:                     
151:                     i2c_start();
9D00B3C8  0F402C6F   JAL i2c_start
9D00B3CC  00000000   NOP
152:                     i2c_write(Device +0); // "+0" pour que l'adresse soit en mode criture
9D00B3D0  93C20020   LBU V0, 32(FP)
9D00B3D4  00402021   ADDU A0, V0, ZERO
9D00B3D8  0F402DD5   JAL i2c_write
9D00B3DC  00000000   NOP
153:                     i2c_write(Reg);
9D00B3E0  93C20024   LBU V0, 36(FP)
9D00B3E4  00402021   ADDU A0, V0, ZERO
9D00B3E8  0F402DD5   JAL i2c_write
9D00B3EC  00000000   NOP
154:                     
155:                     i2c_reStart();
9D00B3F0  0F402F55   JAL i2c_reStart
9D00B3F4  00000000   NOP
156:                     i2c_write(Device +1); // "+1" pour que l'adresse soit en mode lecture
9D00B3F8  93C20020   LBU V0, 32(FP)
9D00B3FC  24420001   ADDIU V0, V0, 1
9D00B400  304200FF   ANDI V0, V0, 255
9D00B404  00402021   ADDU A0, V0, ZERO
9D00B408  0F402DD5   JAL i2c_write
9D00B40C  00000000   NOP
157:                     
158:                     Data = i2c_read(1);
9D00B410  24040001   ADDIU A0, ZERO, 1
9D00B414  0F40283C   JAL i2c_read
9D00B418  00000000   NOP
9D00B41C  AFC20010   SW V0, 16(FP)
159:                     Data <<= 8;
9D00B420  8FC20010   LW V0, 16(FP)
9D00B424  00021200   SLL V0, V0, 8
9D00B428  AFC20010   SW V0, 16(FP)
160:                     Data |= i2c_read(1);
9D00B42C  24040001   ADDIU A0, ZERO, 1
9D00B430  0F40283C   JAL i2c_read
9D00B434  00000000   NOP
9D00B438  8FC30010   LW V1, 16(FP)
9D00B43C  00621025   OR V0, V1, V0
9D00B440  AFC20010   SW V0, 16(FP)
161:                     Data <<= 8;
9D00B444  8FC20010   LW V0, 16(FP)
9D00B448  00021200   SLL V0, V0, 8
9D00B44C  AFC20010   SW V0, 16(FP)
162:                     Data |= i2c_read(0);
9D00B450  00002021   ADDU A0, ZERO, ZERO
9D00B454  0F40283C   JAL i2c_read
9D00B458  00000000   NOP
9D00B45C  8FC30010   LW V1, 16(FP)
9D00B460  00621025   OR V0, V1, V0
9D00B464  AFC20010   SW V0, 16(FP)
163:                     i2c_stop();
9D00B468  0F4033AA   JAL i2c_stop
9D00B46C  00000000   NOP
164:                     
165:                     return Data;
9D00B470  8FC20010   LW V0, 16(FP)
166:                 } // end I2CSensor_Read24
9D00B474  03C0E821   ADDU SP, FP, ZERO
9D00B478  8FBF001C   LW RA, 28(SP)
9D00B47C  8FBE0018   LW FP, 24(SP)
9D00B480  27BD0020   ADDIU SP, SP, 32
9D00B484  03E00008   JR RA
9D00B488  00000000   NOP
167:                 
168:                    
169:                 
170:                 
171:                 
172:                 
173:                 
174:                  
175:                 
176:                 
177:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/mc32delays.c  --------------
1:                   /*--------------------------------------------------------*/
2:                   //	Mc32Delays.c
3:                   /*--------------------------------------------------------*/
4:                   //	Description :	Fonctions de delay afin
5:                   //			de pouvoir utiliser la mme syntaxe
6:                   //			que sous CCS.
7:                   //
8:                   //	Auteurs 		: 	F. Domin / C. Huber
9:                   //
10:                  //	Version		:	V2.0
11:                  //	Compilateur	:	ncessaire pour XC32 V 1.40
12:                  //
13:                  // Revu / modifi:
14:                  // CHR 17.12.2015    besoin du fichier maison Mc32CoreTimer.h
15:                  // SCA 11.10.2016   ajout fonction dlais core timer
16:                  /*--------------------------------------------------------*/
17:                  
18:                  
19:                  #include "Mc32Delays.h"
20:                  // Ncessaire pour la fonction delay_msCt
21:                  //#include "Mc32CoreTimer.h"
22:                  #include <xc.h> //pour les fonctions d'accs au Core Timer
23:                  #include <stdint.h>
24:                  #include <stdbool.h>
25:                  
26:                  /*--------------------------------------------------------*/
27:                  // Fonctions de dlais utilisant le Core Timer
28:                  /*--------------------------------------------------------*/
29:                  //SCA 11.10.2016:
30:                  // 1. mis les fonctions du Core Timer
31:                  //  _CP0_GET_COUNT() : lecture valeur Core Timer
32:                  //  et _CP0_SET_COUNT() : criture nouvelle valeur Core Timer
33:                  //  en dur dans ce fichier
34:                  // 2. Forc l'optimisation 0 des fonctions delay_msCt() et delay_usCt()
35:                  // ci-dessous
36:                  // Tout ceci pour viter toute optimisation et obtenir un comportement reproductible
37:                  //
38:                  // Fonctions testes avec MPLABX 3.40, xc32 1.42 et Harmony 1.08.01 sur Starter-kit ES
39:                  // PIC32MXF795L @ 80 MHz. Mesures :
40:                  //  Fonction    |    delta(cycles@80MHz, optimisation 0) delta(cycles@80MHz, optimisation 1)
41:                  //  ------------+---------------------------------------------------------------------------
42:                  //  delay_msCt  |    0 (exact)                           0 (exact)
43:                  //  delay_usCt  |    +3                                  +4
44:                  //  delay500nsCt|    0 (exact)                           +3 (537.5ns)
45:                  
46:                  // Les dlais sont exacts en optimisation 1. 4 cycles CPU de surplus en optimisation 0
47:                  // (appels aux fonctions ? / toggle des IO ?)
48:                  
49:                  #ifndef SYS_FREQ
50:                      #define SYS_FREQ (20000000L)    //80 MHz
51:                  #endif
52:                  
53:                  //le core timer est incrment tous les 2 SYSCLK
54:                  #define TICK_CT_MS (SYS_FREQ / 2000L)
55:                  #define TICK_CT_US (SYS_FREQ / 2000000L)
56:                  #define TICK_OVERHEAD 0    //pour ajustement. mesur 15 cycles Core Timer de surplus
57:                  //valeur quasi-fixe (pu observer 3 cycles CPU en plus en optimisation 0
58:                  //par rapport  1.
59:                  
60:                  /*--------------------------------------------------------*/
61:                  // Fonction delay_msCt Core Timer
62:                  /*--------------------------------------------------------*/
63:                  //attente passive n * ms
64:                  //utilise le Core Timer
65:                  void __attribute__((optimize("-O0"))) delay_msCt(uint32_t NbMs)
66:                  {
9D00D0A8  27BDFFF0   ADDIU SP, SP, -16
9D00D0AC  AFBF000C   SW RA, 12(SP)
9D00D0B0  AFBE0008   SW FP, 8(SP)
9D00D0B4  03A0F021   ADDU FP, SP, ZERO
9D00D0B8  AFC40010   SW A0, 16(FP)
67:                      uint32_t time_to_wait;
68:                  
69:                      _CP0_SET_COUNT(0);
9D00D0BC  00001021   ADDU V0, ZERO, ZERO
9D00D0C0  40824800   MTC0 V0, Count
9D00D0C4  000000C0   EHB
70:                      time_to_wait = (TICK_CT_MS * NbMs) - TICK_OVERHEAD;
9D00D0C8  8FC40010   LW A0, 16(FP)
9D00D0CC  00801821   ADDU V1, A0, ZERO
9D00D0D0  00031080   SLL V0, V1, 2
9D00D0D4  00401821   ADDU V1, V0, ZERO
9D00D0D8  00031140   SLL V0, V1, 5
9D00D0DC  00431023   SUBU V0, V0, V1
9D00D0E0  00441021   ADDU V0, V0, A0
9D00D0E4  00021880   SLL V1, V0, 2
9D00D0E8  00431021   ADDU V0, V0, V1
9D00D0EC  00021100   SLL V0, V0, 4
9D00D0F0  AFC20000   SW V0, 0(FP)
71:                      while(_CP0_GET_COUNT()  < time_to_wait) {
9D00D0F4  00000000   NOP
9D00D0F8  40034800   MFC0 V1, Count
9D00D0FC  8FC20000   LW V0, 0(FP)
9D00D100  0062102B   SLTU V0, V1, V0
9D00D104  1440FFFC   BNE V0, ZERO, .LVL2
9D00D108  00000000   NOP
72:                          // Waiting
73:                      }
74:                  }
9D00D10C  03C0E821   ADDU SP, FP, ZERO
9D00D110  8FBF000C   LW RA, 12(SP)
9D00D114  8FBE0008   LW FP, 8(SP)
9D00D118  27BD0010   ADDIU SP, SP, 16
9D00D11C  03E00008   JR RA
9D00D120  00000000   NOP
75:                  
76:                  /*--------------------------------------------------------*/
77:                  // Fonction delay_usCt Core Timer
78:                  /*--------------------------------------------------------*/
79:                  //attente passive n * us
80:                  //utilise le Core Timer
81:                  void __attribute__((optimize("-O0"))) delay_usCt(uint32_t NbUs)
82:                  {
00000000  00000000   NOP
83:                      uint32_t time_to_wait;
84:                  
85:                      _CP0_SET_COUNT(0);
00000014  00000000   NOP
86:                      time_to_wait = (TICK_CT_US * NbUs) - TICK_OVERHEAD;
00000020  00000000   NOP
87:                      while(_CP0_GET_COUNT()  < time_to_wait) {
00000034  00000000   NOP
88:                          // Waiting
89:                      }
90:                  }
0000004C  00000000   NOP
91:                  
92:                  /*--------------------------------------------------------*/
93:                  // Fonction delay500nsCt Core Timer
94:                  /*--------------------------------------------------------*/
95:                  //attente passive 500ns
96:                  //utilise le Core Timer
97:                  void __attribute__((optimize("-O0"))) delay500nsCt(void)
98:                  {
00000000  00000000   NOP
99:                      _CP0_SET_COUNT(0);
00000010  00000000   NOP
100:                 
101:                     while(_CP0_GET_COUNT()  < 5L) {
0000001C  00000000   NOP
102:                         // Waiting
103:                     }
104:                 }
00000030  00000000   NOP
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/mc32_i2cutilccs.c  ---------
1:                   /*--------------------------------------------------------*/
2:                   //      Mc32_I2cUtilCCS.c
3:                   /*--------------------------------------------------------*/
4:                   //	Description :	utilitaire I2C compatible syntaxe CCS
5:                   //                      Obtenu par modification de l'exemple harmony
6:                   //
7:                   //	Auteur 		: 	C. HUBER
8:                   //
9:                   //	Version		:	V1.2
10:                  //	Compilateur	:	XC32 V1.40 & Harmony V1.06
11:                  // Modifications :
12:                  //      CHR 19.03.2015  Migration sur plib_i2c de Harmony 1.00   CHR
13:                  //      CHR 12.04.2016  adaptaion dtails pour plib_i2c de Harmony 1.06   CHR
14:                  //		SCA 04.04.2017  Complments commentaires i2c_init HighFrequencyEnable/Disable
15:                  //
16:                  /*--------------------------------------------------------*/
17:                  
18:                  #include "app.h"
19:                  #include "Mc32_I2cUtilCCS.h"
20:                  #include "peripheral\i2c\plib_i2c.h"
21:                  #include "peripheral\osc\plib_osc.h"
22:                  
23:                  
24:                  
25:                  // KIT 32MX795F512L Constants
26:                  #define KIT_I2C_BUS   I2C_ID_2
27:                  #define I2C_CLOCK_FAST 400000
28:                  #define I2C_CLOCK_SLOW 100000
29:                  
30:                  //------------------------------------------------------------------------------
31:                  // i2c_init
32:                  //
33:                  // Initialisationde l'I2c
34:                  //      si bool Fast = false  LOW speed   100 KHz
35:                  //      si bool Fast = true   HIGH speed  400 KHz
36:                  //------------------------------------------------------------------------------
37:                  // Adaptation plib_i2c  : 19.03.2015 CHR
38:                  // CHR 12.04.2016 reprise principe init du driver I2C de Harmony 1.06
39:                  // = pas OK reprise ancien principe            
40:                  
41:                  uint32_t I2cConReg, I2cBrg;     // pour controle de la configuration
42:                  
43:                  void i2c_init( bool Fast )
44:                  {
9D00B580  27BDFFE8   ADDIU SP, SP, -24
9D00B584  AFBF0014   SW RA, 20(SP)
9D00B588  AFBE0010   SW FP, 16(SP)
9D00B58C  03A0F021   ADDU FP, SP, ZERO
9D00B590  00801021   ADDU V0, A0, ZERO
9D00B594  A3C20018   SB V0, 24(FP)
45:                      PLIB_I2C_Disable(KIT_I2C_BUS);      // Ajout CHR
9D00B598  3C02BF80   LUI V0, -16512
9D00B59C  34445100   ORI A0, V0, 20736
9D00B5A0  0F4038A0   JAL PLIB_I2C_Disable
9D00B5A4  00000000   NOP
46:                      
47:                  	// LOW frequency is enabled (**NOTE** PLIB function logic reverted)
48:                  	// A 100k et 400kHz, on devrait activer le "slope control" 
49:                  	// (cf.  I2C datasheet PIC32). Toutefois, le LM92 a des problmes 
50:                  	// d'incompatibilit avec les flancs trop lents => dsactiv
51:                  	// Voir application note 
52:                  	// "AN-2113 Applying I2C Compatible Temperature Sensors in Systems with Slow Clock Edges"
53:                      PLIB_I2C_HighFrequencyEnable(KIT_I2C_BUS);
9D00B5A8  3C02BF80   LUI V0, -16512
9D00B5AC  34445100   ORI A0, V0, 20736
9D00B5B0  0F403898   JAL PLIB_I2C_HighFrequencyEnable
9D00B5B4  00000000   NOP
54:                      if (Fast)  {
9D00B5B8  93C20018   LBU V0, 24(FP)
9D00B5BC  1040000D   BEQ V0, ZERO, 0x9D00B5F4
9D00B5C0  00000000   NOP
55:                         PLIB_I2C_BaudRateSet(KIT_I2C_BUS,
9D00B5C4  00002021   ADDU A0, ZERO, ZERO
9D00B5C8  0F403745   JAL SYS_CLK_PeripheralFrequencyGet
9D00B5CC  00000000   NOP
9D00B5D0  3C03BF80   LUI V1, -16512
9D00B5D4  34645100   ORI A0, V1, 20736
9D00B5D8  00402821   ADDU A1, V0, ZERO
9D00B5DC  3C020006   LUI V0, 6
9D00B5E0  34461A80   ORI A2, V0, 6784
9D00B5E4  0F4036FD   JAL PLIB_I2C_BaudRateSet
9D00B5E8  00000000   NOP
9D00B5EC  0B402D87   J .LVL7
9D00B5F0  00000000   NOP
56:                                 SYS_CLK_PeripheralFrequencyGet(CLK_BUS_PERIPHERAL_1), I2C_CLOCK_FAST);
57:                      } else {
58:                          PLIB_I2C_BaudRateSet(KIT_I2C_BUS,
9D00B5F4  00002021   ADDU A0, ZERO, ZERO
9D00B5F8  0F403745   JAL SYS_CLK_PeripheralFrequencyGet
9D00B5FC  00000000   NOP
9D00B600  3C03BF80   LUI V1, -16512
9D00B604  34645100   ORI A0, V1, 20736
9D00B608  00402821   ADDU A1, V0, ZERO
9D00B60C  3C020001   LUI V0, 1
9D00B610  344686A0   ORI A2, V0, -31072
9D00B614  0F4036FD   JAL PLIB_I2C_BaudRateSet
9D00B618  00000000   NOP
59:                                 SYS_CLK_PeripheralFrequencyGet(CLK_BUS_PERIPHERAL_1), I2C_CLOCK_SLOW);
60:                      }
61:                  	
62:                  	// selon driver. Voir commentaire PLIB_I2C_HighFrequencyEnable ci-dessus
63:                      // PLIB_I2C_HighFrequencyDisable(KIT_I2C_BUS);   
64:                      
65:                      PLIB_I2C_SlaveClockStretchingEnable(KIT_I2C_BUS);  // ajout CHR
9D00B61C  3C02BF80   LUI V0, -16512
9D00B620  34445100   ORI A0, V0, 20736
9D00B624  0F403894   JAL PLIB_I2C_SlaveClockStretchingEnable
9D00B628  00000000   NOP
66:                      
67:                      PLIB_I2C_Enable(KIT_I2C_BUS);
9D00B62C  3C02BF80   LUI V0, -16512
9D00B630  34445100   ORI A0, V0, 20736
9D00B634  0F40389C   JAL PLIB_I2C_Enable
9D00B638  00000000   NOP
68:                  
69:                      I2cConReg = I2C2CON;
9D00B63C  3C02BF80   LUI V0, -16512
9D00B640  8C425100   LW V0, 20736(V0)
9D00B644  AF828038   SW V0, -32712(GP)
70:                      I2cBrg = I2C2BRG;
9D00B648  3C02BF80   LUI V0, -16512
9D00B64C  8C425140   LW V0, 20800(V0)
9D00B650  AF82803C   SW V0, -32708(GP)
71:                  }
9D00B654  03C0E821   ADDU SP, FP, ZERO
9D00B658  8FBF0014   LW RA, 20(SP)
9D00B65C  8FBE0010   LW FP, 16(SP)
9D00B660  27BD0018   ADDIU SP, SP, 24
9D00B664  03E00008   JR RA
9D00B668  00000000   NOP
72:                  
73:                  
74:                  //------------------------------------------------------------------------------
75:                  // i2c_start()
76:                  //
77:                  // Dbut la transaction I2C master
78:                  //
79:                  // Adaptation plib_i2c  : 19.03.2015 CHR
80:                  
81:                  void i2c_start(void)
82:                  {
9D00B1BC  27BDFFE8   ADDIU SP, SP, -24
9D00B1C0  AFBF0014   SW RA, 20(SP)
9D00B1C4  AFBE0010   SW FP, 16(SP)
9D00B1C8  03A0F021   ADDU FP, SP, ZERO
83:                      // int DebugCode = 0;
84:                  
85:                      // Wait for the bus to be idle, then start the transfer
86:                      while(PLIB_I2C_BusIsIdle(KIT_I2C_BUS) == false);
9D00B1CC  00000000   NOP
9D00B1D0  3C02BF80   LUI V0, -16512
9D00B1D4  34445100   ORI A0, V0, 20736
9D00B1D8  0F4037DF   JAL .LFE1152, PLIB_I2C_BusIsIdle
9D00B1DC  00000000   NOP
9D00B1E0  38420001   XORI V0, V0, 1
9D00B1E4  304200FF   ANDI V0, V0, 255
9D00B1E8  1440FFF9   BNE V0, ZERO, 0x9D00B1D0
9D00B1EC  00000000   NOP
87:                  
88:                       /* Check for recieve overflow */
89:                      if ( PLIB_I2C_ReceiverOverflowHasOccurred(KIT_I2C_BUS))
9D00B1F0  3C02BF80   LUI V0, -16512
9D00B1F4  34445100   ORI A0, V0, 20736
9D00B1F8  0F403912   JAL PLIB_I2C_ReceiverOverflowHasOccurred
9D00B1FC  00000000   NOP
9D00B200  10400005   BEQ V0, ZERO, .LVL12
9D00B204  00000000   NOP
90:                      {
91:                          PLIB_I2C_ReceiverOverflowClear(KIT_I2C_BUS);
9D00B208  3C02BF80   LUI V0, -16512
9D00B20C  34445100   ORI A0, V0, 20736
9D00B210  0F4038D0   JAL PLIB_I2C_ReceiverOverflowClear
9D00B214  00000000   NOP
92:                      }
93:                  
94:                      /* Check for transmit overflow */
95:                      if (PLIB_I2C_TransmitterOverflowHasOccurred(KIT_I2C_BUS))
9D00B218  3C02BF80   LUI V0, -16512
9D00B21C  34445100   ORI A0, V0, 20736
9D00B220  0F403909   JAL PLIB_I2C_TransmitterOverflowHasOccurred
9D00B224  00000000   NOP
9D00B228  10400005   BEQ V0, ZERO, .LVL14
9D00B22C  00000000   NOP
96:                      {
97:                          PLIB_I2C_TransmitterOverflowClear(KIT_I2C_BUS);
9D00B230  3C02BF80   LUI V0, -16512
9D00B234  34445100   ORI A0, V0, 20736
9D00B238  0F4038C8   JAL PLIB_I2C_TransmitterOverflowClear
9D00B23C  00000000   NOP
98:                      }
99:                  
100:                     PLIB_I2C_MasterStart(KIT_I2C_BUS);
9D00B240  3C02BF80   LUI V0, -16512
9D00B244  34445100   ORI A0, V0, 20736
9D00B248  0F4038AC   JAL PLIB_I2C_MasterStart
9D00B24C  00000000   NOP
101:                 
102:                     if (PLIB_I2C_ArbitrationLossHasOccurred(KIT_I2C_BUS));
9D00B250  3C02BF80   LUI V0, -16512
9D00B254  34445100   ORI A0, V0, 20736
9D00B258  0F403900   JAL PLIB_I2C_ArbitrationLossHasOccurred
9D00B25C  00000000   NOP
103:                     {
104:                         // DBPRINTF("Error: Bus collision during transfer Start\n");
105:                         // DebugCode = 1;
106:                         // Handel bus collision
107:                         PLIB_I2C_ArbitrationLossClear(KIT_I2C_BUS);
9D00B260  3C02BF80   LUI V0, -16512
9D00B264  34445100   ORI A0, V0, 20736
9D00B268  0F4038A4   JAL PLIB_I2C_ArbitrationLossClear
9D00B26C  00000000   NOP
108:                     }
109:                    
110:                     // Wait for the signal to complete
111:                     while (PLIB_I2C_StartWasDetected(KIT_I2C_BUS) == false);
9D00B270  00000000   NOP
9D00B274  3C02BF80   LUI V0, -16512
9D00B278  34445100   ORI A0, V0, 20736
9D00B27C  0F4038FA   JAL PLIB_I2C_StartWasDetected
9D00B280  00000000   NOP
9D00B284  38420001   XORI V0, V0, 1
9D00B288  304200FF   ANDI V0, V0, 255
9D00B28C  1440FFF9   BNE V0, ZERO, 0x9D00B274
9D00B290  00000000   NOP
112:                    
113:                  } // end i2c_start
9D00B294  03C0E821   ADDU SP, FP, ZERO
9D00B298  8FBF0014   LW RA, 20(SP)
9D00B29C  8FBE0010   LW FP, 16(SP)
9D00B2A0  27BD0018   ADDIU SP, SP, 24
9D00B2A4  03E00008   JR RA
9D00B2A8  00000000   NOP
114:                 
115:                 void i2c_reStart(void)
116:                 {
9D00BD54  27BDFFE8   ADDIU SP, SP, -24
9D00BD58  AFBF0014   SW RA, 20(SP)
9D00BD5C  AFBE0010   SW FP, 16(SP)
9D00BD60  03A0F021   ADDU FP, SP, ZERO
117:                    // int DebugCode = 0;
118:                   
119:                    // Pas d'attente bus en Idle
120:                 
121:                    /* Check for recieve overflow */
122:                    if ( PLIB_I2C_ReceiverOverflowHasOccurred(KIT_I2C_BUS))
9D00BD64  3C02BF80   LUI V0, -16512
9D00BD68  34445100   ORI A0, V0, 20736
9D00BD6C  0F403912   JAL PLIB_I2C_ReceiverOverflowHasOccurred
9D00BD70  00000000   NOP
9D00BD74  10400005   BEQ V0, ZERO, .LVL20
9D00BD78  00000000   NOP
123:                    {
124:                        PLIB_I2C_ReceiverOverflowClear(KIT_I2C_BUS);
9D00BD7C  3C02BF80   LUI V0, -16512
9D00BD80  34445100   ORI A0, V0, 20736
9D00BD84  0F4038D0   JAL PLIB_I2C_ReceiverOverflowClear
9D00BD88  00000000   NOP
125:                    }
126:                 
127:                    /* Check for transmit overflow */
128:                    if (PLIB_I2C_TransmitterOverflowHasOccurred(KIT_I2C_BUS))
9D00BD8C  3C02BF80   LUI V0, -16512
9D00BD90  34445100   ORI A0, V0, 20736
9D00BD94  0F403909   JAL PLIB_I2C_TransmitterOverflowHasOccurred
9D00BD98  00000000   NOP
9D00BD9C  10400005   BEQ V0, ZERO, .LVL22
9D00BDA0  00000000   NOP
129:                    {
130:                         PLIB_I2C_TransmitterOverflowClear(KIT_I2C_BUS);
9D00BDA4  3C02BF80   LUI V0, -16512
9D00BDA8  34445100   ORI A0, V0, 20736
9D00BDAC  0F4038C8   JAL PLIB_I2C_TransmitterOverflowClear
9D00BDB0  00000000   NOP
131:                    }
132:                 
133:                    // PLIB_I2C_StartClear(KIT_I2C_BUS);
134:                    PLIB_I2C_MasterStartRepeat(KIT_I2C_BUS);
9D00BDB4  3C02BF80   LUI V0, -16512
9D00BDB8  34445100   ORI A0, V0, 20736
9D00BDBC  0F4038B0   JAL PLIB_I2C_MasterStartRepeat
9D00BDC0  00000000   NOP
135:                    
136:                    if (PLIB_I2C_ArbitrationLossHasOccurred(KIT_I2C_BUS));
9D00BDC4  3C02BF80   LUI V0, -16512
9D00BDC8  34445100   ORI A0, V0, 20736
9D00BDCC  0F403900   JAL PLIB_I2C_ArbitrationLossHasOccurred
9D00BDD0  00000000   NOP
137:                     {
138:                         // DBPRINTF("Error: Bus collision during transfer Start\n");
139:                         // DebugCode = 1;
140:                         // Handel bus collision
141:                         PLIB_I2C_ArbitrationLossClear(KIT_I2C_BUS);
9D00BDD4  3C02BF80   LUI V0, -16512
9D00BDD8  34445100   ORI A0, V0, 20736
9D00BDDC  0F4038A4   JAL PLIB_I2C_ArbitrationLossClear
9D00BDE0  00000000   NOP
142:                     }
143:                     
144:                    // Wait for the signal to complete
145:                    while (PLIB_I2C_StartWasDetected(KIT_I2C_BUS) == false);
9D00BDE4  00000000   NOP
9D00BDE8  3C02BF80   LUI V0, -16512
9D00BDEC  34445100   ORI A0, V0, 20736
9D00BDF0  0F4038FA   JAL PLIB_I2C_StartWasDetected
9D00BDF4  00000000   NOP
9D00BDF8  38420001   XORI V0, V0, 1
9D00BDFC  304200FF   ANDI V0, V0, 255
9D00BE00  1440FFF9   BNE V0, ZERO, 0x9D00BDE8
9D00BE04  00000000   NOP
146:                   
147:                 } // end i2c_reStart
9D00BE08  03C0E821   ADDU SP, FP, ZERO
9D00BE0C  8FBF0014   LW RA, 20(SP)
9D00BE10  8FBE0010   LW FP, 16(SP)
9D00BE14  27BD0018   ADDIU SP, SP, 24
9D00BE18  03E00008   JR RA
9D00BE1C  00000000   NOP
148:                 
149:                 
150:                 //------------------------------------------------------------------------------
151:                 // i2c_write()
152:                 //
153:                 // Syntaxe : 	i2c_write (data);
154:                 // Le paramtre data est la valeur 8 bits  transmettre.
155:                 // En mode matre, la fonction gnre le signal d'horloge, en mode esclave elle attend le signal d'horloge du matre.
156:                 // En outre cette fonction retourne le bit ACK, 0 = ACK, 1 = NO_ACK.
157:                 //
158:                 //------------------------------------------------------------------------------
159:                 //
160:                 // Modification de  BOOL TransmitOneByte( UINT8 data )
161:                 // - Ajout retour du bit Ack
162:                 // Adaptation plib_i2c  : 19.03.2015 CHR
163:                 
164:                 bool i2c_write( uint8_t data )
165:                 {
9D00B754  27BDFFE0   ADDIU SP, SP, -32
9D00B758  AFBF001C   SW RA, 28(SP)
9D00B75C  AFBE0018   SW FP, 24(SP)
9D00B760  03A0F021   ADDU FP, SP, ZERO
9D00B764  00801021   ADDU V0, A0, ZERO
9D00B768  A3C20020   SB V0, 32(FP)
166:                     bool  AckBit;
167:                   
168:                     // Wait for the bus to be idle (ncessaire aprs un reStart)
169:                     while(PLIB_I2C_BusIsIdle(KIT_I2C_BUS) == false);
9D00B76C  00000000   NOP
9D00B770  3C02BF80   LUI V0, -16512
9D00B774  34445100   ORI A0, V0, 20736
9D00B778  0F4037DF   JAL .LFE1152, PLIB_I2C_BusIsIdle
9D00B77C  00000000   NOP
9D00B780  38420001   XORI V0, V0, 1
9D00B784  304200FF   ANDI V0, V0, 255
9D00B788  1440FFF9   BNE V0, ZERO, .LVL28
9D00B78C  00000000   NOP
170:                 
171:                     // Wait for the transmitter to be ready
172:                     while( PLIB_I2C_TransmitterIsReady(KIT_I2C_BUS) == false);
9D00B790  00000000   NOP
9D00B794  3C02BF80   LUI V0, -16512
9D00B798  34445100   ORI A0, V0, 20736
9D00B79C  0F4038BC   JAL PLIB_I2C_TransmitterIsReady
9D00B7A0  00000000   NOP
9D00B7A4  38420001   XORI V0, V0, 1
9D00B7A8  304200FF   ANDI V0, V0, 255
9D00B7AC  1440FFF9   BNE V0, ZERO, 0x9D00B794
9D00B7B0  00000000   NOP
173:                 
174:                     
175:                     // Transmit the byte
176:                     PLIB_I2C_TransmitterByteSend(KIT_I2C_BUS, data);
9D00B7B4  93C20020   LBU V0, 32(FP)
9D00B7B8  3C03BF80   LUI V1, -16512
9D00B7BC  34645100   ORI A0, V1, 20736
9D00B7C0  00402821   ADDU A1, V0, ZERO
9D00B7C4  0F403906   JAL PLIB_I2C_TransmitterByteSend
9D00B7C8  00000000   NOP
177:                     
178:                     while(PLIB_I2C_TransmitterIsBusy(KIT_I2C_BUS));              //Wait as long as TBF = 1
9D00B7CC  00000000   NOP
9D00B7D0  3C02BF80   LUI V0, -16512
9D00B7D4  34445100   ORI A0, V0, 20736
9D00B7D8  0F403903   JAL PLIB_I2C_TransmitterIsBusy
9D00B7DC  00000000   NOP
9D00B7E0  1440FFFB   BNE V0, ZERO, 0x9D00B7D0
9D00B7E4  00000000   NOP
179:                     while(!PLIB_I2C_TransmitterByteHasCompleted(KIT_I2C_BUS));   //Wait as long as TRSTAT == 1
9D00B7E8  00000000   NOP
9D00B7EC  3C02BF80   LUI V0, -16512
9D00B7F0  34445100   ORI A0, V0, 20736
9D00B7F4  0F4038C0   JAL PLIB_I2C_TransmitterByteHasCompleted
9D00B7F8  00000000   NOP
9D00B7FC  38420001   XORI V0, V0, 1
9D00B800  304200FF   ANDI V0, V0, 255
9D00B804  1440FFF9   BNE V0, ZERO, 0x9D00B7EC
9D00B808  00000000   NOP
180:                   
181:                     AckBit = PLIB_I2C_TransmitterByteWasAcknowledged(KIT_I2C_BUS);
9D00B80C  3C02BF80   LUI V0, -16512
9D00B810  34445100   ORI A0, V0, 20736
9D00B814  0F4038C4   JAL PLIB_I2C_TransmitterByteWasAcknowledged
9D00B818  00000000   NOP
9D00B81C  A3C20010   SB V0, 16(FP)
182:                    
183:                     return AckBit;
9D00B820  93C20010   LBU V0, 16(FP)
184:                 } // end i2c_write
9D00B824  03C0E821   ADDU SP, FP, ZERO
9D00B828  8FBF001C   LW RA, 28(SP)
9D00B82C  8FBE0018   LW FP, 24(SP)
9D00B830  27BD0020   ADDIU SP, SP, 32
9D00B834  03E00008   JR RA
9D00B838  00000000   NOP
185:                 
186:                 
187:                 
188:                 //------------------------------------------------------------------------------
189:                 // i2c_stop()
190:                 //
191:                 // termine la transaction I2C master
192:                 //
193:                 //------------------------------------------------------------------------------
194:                 //
195:                 // Modification de  void StopTransfer( void )
196:                 // - pas de modif sauf le nom de la fonction
197:                 // Adaptation plib_i2c  : 19.03.2015 CHR
198:                 
199:                 
200:                 void i2c_stop( void )
201:                 {
9D00CEA8  27BDFFE8   ADDIU SP, SP, -24
9D00CEAC  AFBF0014   SW RA, 20(SP)
9D00CEB0  AFBE0010   SW FP, 16(SP)
9D00CEB4  03A0F021   ADDU FP, SP, ZERO
202:                     // Attente bus au repos
203:                     while(PLIB_I2C_BusIsIdle(KIT_I2C_BUS) == false);
9D00CEB8  00000000   NOP
9D00CEBC  3C02BF80   LUI V0, -16512
9D00CEC0  34445100   ORI A0, V0, 20736
9D00CEC4  0F4037DF   JAL .LFE1152, PLIB_I2C_BusIsIdle
9D00CEC8  00000000   NOP
9D00CECC  38420001   XORI V0, V0, 1
9D00CED0  304200FF   ANDI V0, V0, 255
9D00CED4  1440FFF9   BNE V0, ZERO, 0x9D00CEBC
9D00CED8  00000000   NOP
204:                 
205:                     PLIB_I2C_MasterStop(KIT_I2C_BUS);
9D00CEDC  3C02BF80   LUI V0, -16512
9D00CEE0  34445100   ORI A0, V0, 20736
9D00CEE4  0F4038B8   JAL PLIB_I2C_MasterStop
9D00CEE8  00000000   NOP
206:                 
207:                     // Wait for the signal to complete
208:                     while (PLIB_I2C_StopWasDetected(KIT_I2C_BUS) == false);
9D00CEEC  00000000   NOP
9D00CEF0  3C02BF80   LUI V0, -16512
9D00CEF4  34445100   ORI A0, V0, 20736
9D00CEF8  0F4038FD   JAL PLIB_I2C_StopWasDetected
9D00CEFC  00000000   NOP
9D00CF00  38420001   XORI V0, V0, 1
9D00CF04  304200FF   ANDI V0, V0, 255
9D00CF08  1440FFF9   BNE V0, ZERO, 0x9D00CEF0
9D00CF0C  00000000   NOP
209:                    
210:                 } // end i2c_stop
9D00CF10  03C0E821   ADDU SP, FP, ZERO
9D00CF14  8FBF0014   LW RA, 20(SP)
9D00CF18  8FBE0010   LW FP, 16(SP)
9D00CF1C  27BD0018   ADDIU SP, SP, 24
9D00CF20  03E00008   JR RA
9D00CF24  00000000   NOP
211:                 
212:                 //------------------------------------------------------------------------------
213:                 // i2c_read()
214:                 //
215:                 // Syntaxe : 	data = i2c_read (ack);
216:                 // La fonction retourne l'octet lu.
217:                 // Le paramtre ack :
218:                 // 1 (true)  signifie qu'il faut effectuer l'acquittement.
219:                 // 0 (false) signifie qu'il ne faut pas effectuer l'acquittement.
220:                 //
221:                 // Adaptation plib_i2c  : 19.03.2015 CHR
222:                 
223:                 uint8_t i2c_read(bool ackTodo)
224:                 {
9D00A0F0  27BDFFE0   ADDIU SP, SP, -32
9D00A0F4  AFBF001C   SW RA, 28(SP)
9D00A0F8  AFBE0018   SW FP, 24(SP)
9D00A0FC  03A0F021   ADDU FP, SP, ZERO
9D00A100  00801021   ADDU V0, A0, ZERO
9D00A104  A3C20020   SB V0, 32(FP)
225:                     uint8_t i2cByte;
226:                 
227:                     // BSP_LEDOn(BSP_LED_5);  // provisoire : pour observation
228:                    
229:                     // ajout idem driver statique I2C de Harmony 1_03
230:                     if ( PLIB_I2C_ReceiverOverflowHasOccurred(KIT_I2C_BUS))
9D00A108  3C02BF80   LUI V0, -16512
9D00A10C  34445100   ORI A0, V0, 20736
9D00A110  0F403912   JAL PLIB_I2C_ReceiverOverflowHasOccurred
9D00A114  00000000   NOP
9D00A118  1040000A   BEQ V0, ZERO, .LVL47
9D00A11C  00000000   NOP
231:                     {
232:                         i2cByte = PLIB_I2C_ReceivedByteGet(KIT_I2C_BUS);
9D00A120  3C02BF80   LUI V0, -16512
9D00A124  34445100   ORI A0, V0, 20736
9D00A128  0F40390F   JAL PLIB_I2C_ReceivedByteGet
9D00A12C  00000000   NOP
9D00A130  A3C20010   SB V0, 16(FP)
233:                         PLIB_I2C_ReceiverOverflowClear(KIT_I2C_BUS);
9D00A134  3C02BF80   LUI V0, -16512
9D00A138  34445100   ORI A0, V0, 20736
9D00A13C  0F4038D0   JAL PLIB_I2C_ReceiverOverflowClear
9D00A140  00000000   NOP
234:                     }
235:                     
236:                     // en relation avec stetching
237:                     PLIB_I2C_SlaveClockRelease(KIT_I2C_BUS);
9D00A144  3C02BF80   LUI V0, -16512
9D00A148  34445100   ORI A0, V0, 20736
9D00A14C  0F4038A8   JAL PLIB_I2C_SlaveClockRelease
9D00A150  00000000   NOP
238:                 
239:                     // Set Rx enable in MSTR which causes SLAVE to send data
240:                     PLIB_I2C_MasterReceiverClock1Byte(KIT_I2C_BUS);
9D00A154  3C02BF80   LUI V0, -16512
9D00A158  34445100   ORI A0, V0, 20736
9D00A15C  0F4038B4   JAL PLIB_I2C_MasterReceiverClock1Byte
9D00A160  00000000   NOP
241:                 
242:                     // Wait till RBF = 1; Which means data is available in I2C2RCV reg
243:                     while(!PLIB_I2C_ReceivedByteIsAvailable(KIT_I2C_BUS));
9D00A164  00000000   NOP
9D00A168  3C02BF80   LUI V0, -16512
9D00A16C  34445100   ORI A0, V0, 20736
9D00A170  0F40390C   JAL PLIB_I2C_ReceivedByteIsAvailable
9D00A174  00000000   NOP
9D00A178  38420001   XORI V0, V0, 1
9D00A17C  304200FF   ANDI V0, V0, 255
9D00A180  1440FFF9   BNE V0, ZERO, 0x9D00A168
9D00A184  00000000   NOP
244:                     
245:                     i2cByte = PLIB_I2C_ReceivedByteGet(KIT_I2C_BUS); //Read from I2CxRCV
9D00A188  3C02BF80   LUI V0, -16512
9D00A18C  34445100   ORI A0, V0, 20736
9D00A190  0F40390F   JAL PLIB_I2C_ReceivedByteGet
9D00A194  00000000   NOP
9D00A198  A3C20010   SB V0, 16(FP)
246:                 
247:                     while ( PLIB_I2C_MasterReceiverReadyToAcknowledge ( KIT_I2C_BUS ) == false );
9D00A19C  00000000   NOP
9D00A1A0  3C02BF80   LUI V0, -16512
9D00A1A4  34445100   ORI A0, V0, 20736
9D00A1A8  0F4038CC   JAL PLIB_I2C_MasterReceiverReadyToAcknowledge
9D00A1AC  00000000   NOP
9D00A1B0  38420001   XORI V0, V0, 1
9D00A1B4  304200FF   ANDI V0, V0, 255
9D00A1B8  1440FFF9   BNE V0, ZERO, .LVL53
9D00A1BC  00000000   NOP
248:                 
249:                      if (ackTodo) {
9D00A1C0  93C20020   LBU V0, 32(FP)
9D00A1C4  10400008   BEQ V0, ZERO, 0x9D00A1E8
9D00A1C8  00000000   NOP
250:                           PLIB_I2C_ReceivedByteAcknowledge ( KIT_I2C_BUS, true );
9D00A1CC  3C02BF80   LUI V0, -16512
9D00A1D0  34445100   ORI A0, V0, 20736
9D00A1D4  24050001   ADDIU A1, ZERO, 1
9D00A1D8  0F403750   JAL .LFE1154, PLIB_I2C_ReceivedByteAcknowledge
9D00A1DC  00000000   NOP
251:                      } else {
252:                           PLIB_I2C_ReceivedByteAcknowledge ( KIT_I2C_BUS, false );
9D00A1E8  3C02BF80   LUI V0, -16512
9D00A1EC  34445100   ORI A0, V0, 20736
9D00A1F0  00002821   ADDU A1, ZERO, ZERO
9D00A1F4  0F403750   JAL .LFE1154, PLIB_I2C_ReceivedByteAcknowledge
9D00A1F8  00000000   NOP
253:                      }
254:                 
255:                     // wait till ACK/NACK sequence is complete i.e ACKEN = 0
256:                     while( PLIB_I2C_MasterReceiverReadyToAcknowledge (KIT_I2C_BUS) == false);
9D00A1E0  0B40287F   J .LVL56
9D00A1E4  00000000   NOP
9D00A1FC  00000000   NOP
9D00A200  3C02BF80   LUI V0, -16512
9D00A204  34445100   ORI A0, V0, 20736
9D00A208  0F4038CC   JAL PLIB_I2C_MasterReceiverReadyToAcknowledge
9D00A20C  00000000   NOP
9D00A210  38420001   XORI V0, V0, 1
9D00A214  304200FF   ANDI V0, V0, 255
9D00A218  1440FFF9   BNE V0, ZERO, 0x9D00A200
9D00A21C  00000000   NOP
257:                    
258:                     // BSP_LEDOff(BSP_LED_5); // provisoire : pour observation
259:                 
260:                     return i2cByte;
9D00A220  93C20010   LBU V0, 16(FP)
261:                 } // end i2c_read
9D00A224  03C0E821   ADDU SP, FP, ZERO
9D00A228  8FBF001C   LW RA, 28(SP)
9D00A22C  8FBE0018   LW FP, 24(SP)
9D00A230  27BD0020   ADDIU SP, SP, 32
9D00A234  03E00008   JR RA
9D00A238  00000000   NOP
262:                 
263:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/main.c  --------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for an MPLAB Harmony project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include <stddef.h>                     // Defines NULL
59:                  #include <stdbool.h>                    // Defines true
60:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
61:                  #include "system/common/sys_module.h"   // SYS function prototypes
62:                  
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Main Entry Point
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  int main ( void )
71:                  {
9D00DCBC  27BDFFE8   ADDIU SP, SP, -24
9D00DCC0  AFBF0014   SW RA, 20(SP)
9D00DCC4  AFBE0010   SW FP, 16(SP)
9D00DCC8  03A0F021   ADDU FP, SP, ZERO
72:                      /* Initialize all MPLAB Harmony modules, including application(s). */
73:                      SYS_Initialize ( NULL );
9D00DCCC  00002021   ADDU A0, ZERO, ZERO
9D00DCD0  0F402A9E   JAL SYS_Initialize
9D00DCD4  00000000   NOP
74:                  
75:                  
76:                      while ( true )
77:                      {
78:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
79:                          SYS_Tasks ( );
9D00DCD8  0F403718   JAL SYS_Tasks
9D00DCDC  00000000   NOP
80:                  
81:                      }
9D00DCE0  0B403736   J .LVL0
9D00DCE4  00000000   NOP
82:                  
83:                      /* Execution should not come here during normal operation */
84:                  
85:                      return ( EXIT_FAILURE );
86:                  }
87:                  
88:                  /*******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/gesfifoth32.c  -------------
1:                   // ETML Ecole Technique
2:                   // Fichier GesFifoTh.c
3:                   
4:                   // Exemple gestion d'un fifo de caractre, utilisation de pointeur et
5:                   // d'un descripteur de fifo
6:                   
7:                   //	Auteur 		: 	C. Huber
8:                   //
9:                   //	Version		:	V1.6
10:                  //	Compilateur	:	XC32 V1.42 + Harmony 1.08
11:                  //
12:                  //      Modifications :
13:                  //      CHR 19.12.2014  remplacement typedef32 par stdint
14:                  //      CHR 20.12.2016  fifosize en int32_t pour permettre des
15:                  //                      fifo de grande taille
16:                  //
17:                  /*--------------------------------------------------------*/
18:                  
19:                  #include "GesFifoTh32.h"
20:                  
21:                  /*---------------*/
22:                  /* InitFifo      */
23:                  /*===============*/
24:                  // Init avec possibilit de fournir une valeur de remplissage
25:                  // Initialisation du descripteur de FIFO
26:                  
27:                  void InitFifo ( S_fifo *pDescrFifo, int32_t FifoSize, int8_t *pDebFifo, int8_t InitVal )
28:                  {
9D00BFB4  27BDFFF0   ADDIU SP, SP, -16
9D00BFB8  AFBE000C   SW FP, 12(SP)
9D00BFBC  03A0F021   ADDU FP, SP, ZERO
9D00BFC0  AFC40010   SW A0, 16(FP)
9D00BFC4  AFC50014   SW A1, 20(FP)
9D00BFC8  AFC60018   SW A2, 24(FP)
9D00BFCC  00E01021   ADDU V0, A3, ZERO
9D00BFD0  A3C2001C   SB V0, 28(FP)
29:                     int32_t i;
30:                     int8_t *pFif;
31:                     pDescrFifo->fifoSize =   FifoSize;
9D00BFD4  8FC20010   LW V0, 16(FP)
9D00BFD8  8FC30014   LW V1, 20(FP)
9D00BFDC  AC430000   SW V1, 0(V0)
32:                     pDescrFifo->pDebFifo =   pDebFifo; // dbut du fifo
9D00BFE0  8FC20010   LW V0, 16(FP)
9D00BFE4  8FC30018   LW V1, 24(FP)
9D00BFE8  AC430004   SW V1, 4(V0)
33:                     // fin du fifo
34:                     pDescrFifo->pFinFifo =   pDebFifo + (FifoSize - 1);
9D00BFEC  8FC20014   LW V0, 20(FP)
9D00BFF0  2442FFFF   ADDIU V0, V0, -1
9D00BFF4  8FC30018   LW V1, 24(FP)
9D00BFF8  00621821   ADDU V1, V1, V0
9D00BFFC  8FC20010   LW V0, 16(FP)
9D00C000  AC430008   SW V1, 8(V0)
35:                     pDescrFifo->pWrite   =   pDebFifo;  // dbut du fifo
9D00C004  8FC20010   LW V0, 16(FP)
9D00C008  8FC30018   LW V1, 24(FP)
9D00C00C  AC43000C   SW V1, 12(V0)
36:                     pDescrFifo->pRead     =   pDebFifo;  // dbut du fifo
9D00C010  8FC20010   LW V0, 16(FP)
9D00C014  8FC30018   LW V1, 24(FP)
9D00C018  AC430010   SW V1, 16(V0)
37:                     pFif = pDebFifo;
9D00C01C  8FC20018   LW V0, 24(FP)
9D00C020  AFC20004   SW V0, 4(FP)
38:                     for (i=0; i < FifoSize; i++) {
9D00C024  AFC00000   SW ZERO, 0(FP)
9D00C028  0B403015   J 0x9D00C054
9D00C02C  00000000   NOP
9D00C048  8FC20000   LW V0, 0(FP)
9D00C04C  24420001   ADDIU V0, V0, 1
9D00C050  AFC20000   SW V0, 0(FP)
9D00C054  8FC30000   LW V1, 0(FP)
9D00C058  8FC20014   LW V0, 20(FP)
9D00C05C  0062102A   SLT V0, V1, V0
9D00C060  1440FFF3   BNE V0, ZERO, .LVL3
9D00C064  00000000   NOP
39:                        *pFif  = InitVal;
9D00C030  8FC20004   LW V0, 4(FP)
9D00C034  93C3001C   LBU V1, 28(FP)
9D00C038  A0430000   SB V1, 0(V0)
40:                        pFif++;
9D00C03C  8FC20004   LW V0, 4(FP)
9D00C040  24420001   ADDIU V0, V0, 1
9D00C044  AFC20004   SW V0, 4(FP)
41:                     }
42:                  } /* InitFifo */
9D00C068  03C0E821   ADDU SP, FP, ZERO
9D00C06C  8FBE000C   LW FP, 12(SP)
9D00C070  27BD0010   ADDIU SP, SP, 16
9D00C074  03E00008   JR RA
9D00C078  00000000   NOP
43:                  
44:                  
45:                  /*---------------*/
46:                  /* GetWriteSpace */
47:                  /*===============*/
48:                  
49:                  // Retourne la place disponible en criture
50:                  
51:                  int32_t GetWriteSpace ( S_fifo *pDescrFifo)
52:                  {
9D00D2F4  27BDFFF0   ADDIU SP, SP, -16
9D00D2F8  AFBE000C   SW FP, 12(SP)
9D00D2FC  03A0F021   ADDU FP, SP, ZERO
9D00D300  AFC40010   SW A0, 16(FP)
53:                     int32_t writeSize;
54:                  
55:                     // Dtermine le nb de car.que l'on peut dposer
56:                     writeSize = pDescrFifo->pRead - pDescrFifo->pWrite -1;
9D00D304  8FC20010   LW V0, 16(FP)
9D00D308  8C420010   LW V0, 16(V0)
9D00D30C  00401821   ADDU V1, V0, ZERO
9D00D310  8FC20010   LW V0, 16(FP)
9D00D314  8C42000C   LW V0, 12(V0)
9D00D318  00621023   SUBU V0, V1, V0
9D00D31C  2442FFFF   ADDIU V0, V0, -1
9D00D320  AFC20000   SW V0, 0(FP)
57:                     if (writeSize < 0) {
9D00D324  8FC20000   LW V0, 0(FP)
9D00D328  04410006   BGEZ V0, 0x9D00D344
9D00D32C  00000000   NOP
58:                        writeSize = writeSize + pDescrFifo->fifoSize;
9D00D330  8FC20010   LW V0, 16(FP)
9D00D334  8C420000   LW V0, 0(V0)
9D00D338  8FC30000   LW V1, 0(FP)
9D00D33C  00621021   ADDU V0, V1, V0
9D00D340  AFC20000   SW V0, 0(FP)
59:                      }
60:                     return (writeSize);
9D00D344  8FC20000   LW V0, 0(FP)
61:                  } /* GetWriteSpace */
9D00D348  03C0E821   ADDU SP, FP, ZERO
9D00D34C  8FBE000C   LW FP, 12(SP)
9D00D350  27BD0010   ADDIU SP, SP, 16
9D00D354  03E00008   JR RA
9D00D358  00000000   NOP
62:                  
63:                  
64:                  /*-------------*/
65:                  /* GetReadSize */
66:                  /*=============*/
67:                  
68:                  // Retourne le nombre de caractres  lire
69:                  
70:                  int32_t GetReadSize (S_fifo *pDescrFifo)
71:                  {
9D00D494  27BDFFF0   ADDIU SP, SP, -16
9D00D498  AFBE000C   SW FP, 12(SP)
9D00D49C  03A0F021   ADDU FP, SP, ZERO
9D00D4A0  AFC40010   SW A0, 16(FP)
72:                     int32_t readSize;
73:                  
74:                     readSize = pDescrFifo->pWrite - pDescrFifo->pRead;
9D00D4A4  8FC20010   LW V0, 16(FP)
9D00D4A8  8C42000C   LW V0, 12(V0)
9D00D4AC  00401821   ADDU V1, V0, ZERO
9D00D4B0  8FC20010   LW V0, 16(FP)
9D00D4B4  8C420010   LW V0, 16(V0)
9D00D4B8  00621023   SUBU V0, V1, V0
9D00D4BC  AFC20000   SW V0, 0(FP)
75:                     if (readSize < 0) {
9D00D4C0  8FC20000   LW V0, 0(FP)
9D00D4C4  04410006   BGEZ V0, 0x9D00D4E0
9D00D4C8  00000000   NOP
76:                         readSize = readSize +  pDescrFifo->fifoSize;
9D00D4CC  8FC20010   LW V0, 16(FP)
9D00D4D0  8C420000   LW V0, 0(V0)
9D00D4D4  8FC30000   LW V1, 0(FP)
9D00D4D8  00621021   ADDU V0, V1, V0
9D00D4DC  AFC20000   SW V0, 0(FP)
77:                     }
78:                  
79:                     return (readSize);
9D00D4E0  8FC20000   LW V0, 0(FP)
80:                  } /* GetReadSize */
9D00D4E4  03C0E821   ADDU SP, FP, ZERO
9D00D4E8  8FBE000C   LW FP, 12(SP)
9D00D4EC  27BD0010   ADDIU SP, SP, 16
9D00D4F0  03E00008   JR RA
9D00D4F4  00000000   NOP
81:                  
82:                  /*---------------*/
83:                  /* PutCharInFifo */
84:                  /*===============*/
85:                  
86:                  // Dpose un caractre dans le FIFO
87:                  // Retourne 0 si OK, 1 si FIFO full
88:                  
89:                  uint8_t PutCharInFifo ( S_fifo *pDescrFifo, uint8_t charToPut )
90:                  {
9D00C43C  27BDFFE0   ADDIU SP, SP, -32
9D00C440  AFBF001C   SW RA, 28(SP)
9D00C444  AFBE0018   SW FP, 24(SP)
9D00C448  03A0F021   ADDU FP, SP, ZERO
9D00C44C  AFC40020   SW A0, 32(FP)
9D00C450  00A01021   ADDU V0, A1, ZERO
9D00C454  A3C20024   SB V0, 36(FP)
91:                     uint8_t writeStatus;
92:                  
93:                     // test si fifo est FULL
94:                     if (GetWriteSpace(pDescrFifo) == 0) {
9D00C458  8FC40020   LW A0, 32(FP)
9D00C45C  0F4034BD   JAL GetWriteSpace
9D00C460  00000000   NOP
9D00C464  14400005   BNE V0, ZERO, .LVL23
9D00C468  00000000   NOP
95:                        writeStatus = 1; // fifo FULL
9D00C46C  24020001   ADDIU V0, ZERO, 1
9D00C470  A3C20010   SB V0, 16(FP)
9D00C474  0B403134   J .LVL24
9D00C478  00000000   NOP
96:                     }
97:                     else {
98:                        // crit le caractre dans le FIFO
99:                        *(pDescrFifo->pWrite) = charToPut;
9D00C47C  8FC20020   LW V0, 32(FP)
9D00C480  8C42000C   LW V0, 12(V0)
9D00C484  83C30024   LB V1, 36(FP)
9D00C488  A0430000   SB V1, 0(V0)
100:                 
101:                       // incrment le pointeur d'criture
102:                       pDescrFifo->pWrite++;
9D00C48C  8FC20020   LW V0, 32(FP)
9D00C490  8C42000C   LW V0, 12(V0)
9D00C494  24430001   ADDIU V1, V0, 1
9D00C498  8FC20020   LW V0, 32(FP)
9D00C49C  AC43000C   SW V1, 12(V0)
103:                       // gestion du rebouclement
104:                       if (pDescrFifo->pWrite > pDescrFifo->pFinFifo) {
9D00C4A0  8FC20020   LW V0, 32(FP)
9D00C4A4  8C43000C   LW V1, 12(V0)
9D00C4A8  8FC20020   LW V0, 32(FP)
9D00C4AC  8C420008   LW V0, 8(V0)
9D00C4B0  0043102B   SLTU V0, V0, V1
9D00C4B4  10400005   BEQ V0, ZERO, 0x9D00C4CC
9D00C4B8  00000000   NOP
105:                           pDescrFifo->pWrite = pDescrFifo->pDebFifo;
9D00C4BC  8FC20020   LW V0, 32(FP)
9D00C4C0  8C430004   LW V1, 4(V0)
9D00C4C4  8FC20020   LW V0, 32(FP)
9D00C4C8  AC43000C   SW V1, 12(V0)
106:                       }
107:                 
108:                       writeStatus = 0; // OK
9D00C4CC  A3C00010   SB ZERO, 16(FP)
109:                    }
110:                    return (writeStatus);
9D00C4D0  93C20010   LBU V0, 16(FP)
111:                 } // PutCharInFifo 
9D00C4D4  03C0E821   ADDU SP, FP, ZERO
9D00C4D8  8FBF001C   LW RA, 28(SP)
9D00C4DC  8FBE0018   LW FP, 24(SP)
9D00C4E0  27BD0020   ADDIU SP, SP, 32
9D00C4E4  03E00008   JR RA
9D00C4E8  00000000   NOP
112:                 
113:                 
114:                 /*-----------------*/
115:                 /* GetCharFromFifo */
116:                 /*=================*/
117:                 
118:                 // Obtient (lecture) un caractre du fifo 
119:                 // retourne 0 si OK, 1 si empty
120:                 // le caractre lu est retourn par rference
121:                 
122:                 uint8_t GetCharFromFifo ( S_fifo *pDescrFifo, int8_t *carLu )
123:                 {
9D00C20C  27BDFFE0   ADDIU SP, SP, -32
9D00C210  AFBF001C   SW RA, 28(SP)
9D00C214  AFBE0018   SW FP, 24(SP)
9D00C218  03A0F021   ADDU FP, SP, ZERO
9D00C21C  AFC40020   SW A0, 32(FP)
9D00C220  AFC50024   SW A1, 36(FP)
124:                    int8_t readSize;
125:                    uint8_t readStatus;
126:                 
127:                    // dtermine le nb de car. que l'on peut lire
128:                    readSize = GetReadSize(pDescrFifo);
9D00C224  8FC40020   LW A0, 32(FP)
9D00C228  0F403525   JAL GetReadSize
9D00C22C  00000000   NOP
9D00C230  A3C20011   SB V0, 17(FP)
129:                 
130:                    // test si fifo est vide
131:                    if (readSize == 0) {
9D00C234  83C20011   LB V0, 17(FP)
9D00C238  14400007   BNE V0, ZERO, .LVL33
9D00C23C  00000000   NOP
132:                       readStatus = 1; // fifo EMPTY
9D00C240  24020001   ADDIU V0, ZERO, 1
9D00C244  A3C20010   SB V0, 16(FP)
133:                       *carLu = 0;     // carLu = NULL
9D00C248  8FC20024   LW V0, 36(FP)
9D00C24C  A0400000   SB ZERO, 0(V0)
9D00C250  0B4030AC   J .LVL34
9D00C254  00000000   NOP
134:                    }
135:                    else {
136:                       // lis le caractre dans le FIFO
137:                       *carLu = *(pDescrFifo->pRead);
9D00C258  8FC20020   LW V0, 32(FP)
9D00C25C  8C420010   LW V0, 16(V0)
9D00C260  80430000   LB V1, 0(V0)
9D00C264  8FC20024   LW V0, 36(FP)
9D00C268  A0430000   SB V1, 0(V0)
138:                 
139:                       // incrment du pointeur de lecture
140:                       pDescrFifo->pRead++;
9D00C26C  8FC20020   LW V0, 32(FP)
9D00C270  8C420010   LW V0, 16(V0)
9D00C274  24430001   ADDIU V1, V0, 1
9D00C278  8FC20020   LW V0, 32(FP)
9D00C27C  AC430010   SW V1, 16(V0)
141:                       // gestion du rebouclement
142:                       if (pDescrFifo->pRead > pDescrFifo->pFinFifo) {
9D00C280  8FC20020   LW V0, 32(FP)
9D00C284  8C430010   LW V1, 16(V0)
9D00C288  8FC20020   LW V0, 32(FP)
9D00C28C  8C420008   LW V0, 8(V0)
9D00C290  0043102B   SLTU V0, V0, V1
9D00C294  10400005   BEQ V0, ZERO, 0x9D00C2AC
9D00C298  00000000   NOP
143:                           pDescrFifo->pRead = pDescrFifo->pDebFifo;
9D00C29C  8FC20020   LW V0, 32(FP)
9D00C2A0  8C430004   LW V1, 4(V0)
9D00C2A4  8FC20020   LW V0, 32(FP)
9D00C2A8  AC430010   SW V1, 16(V0)
144:                       }
145:                       readStatus = 0; // OK
9D00C2AC  A3C00010   SB ZERO, 16(FP)
146:                    }
147:                    return (readStatus);
9D00C2B0  93C20010   LBU V0, 16(FP)
148:                 } // GetCharFromFifo 
9D00C2B4  03C0E821   ADDU SP, FP, ZERO
9D00C2B8  8FBF001C   LW RA, 28(SP)
9D00C2BC  8FBE0018   LW FP, 24(SP)
9D00C2C0  27BD0020   ADDIU SP, SP, 32
9D00C2C4  03E00008   JR RA
9D00C2C8  00000000   NOP
149:                 
150:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/esp8266.c  -----------------
1:                   //--------------------------------------------------------
2:                   // ESP8266.C
3:                   //--------------------------------------------------------
4:                   // Gestion des capteurs
5:                   //	Description     :	Fonctions pour l'utilisation de l'ESP8266
6:                   //
7:                   //	Auteur          : 	D. Rickenbach
8:                   //  Date            :   21.08.2020
9:                   //	Version         :	V0.5
10:                  //	Compilateur     :	XC32 V5.15 & Harmony 2_06
11:                  // Modifications    :
12:                  //
13:                  /*--------------------------------------------------------*/
14:                  
15:                  // *****************************************************************************
16:                  // *****************************************************************************
17:                  // Section: Included Files 
18:                  // *****************************************************************************
19:                  // *****************************************************************************
20:                  #include <string.h>
21:                  #include <stdint.h>
22:                  #include <stdlib.h>
23:                  #include <stdio.h>
24:                  #include <stdbool.h>
25:                  #include "peripheral/ports/plib_ports.h"
26:                  #include "driver/tmr/drv_tmr_static.h"
27:                  #include "Mc32gest_RS232.h"
28:                  #include "Mc32NVMUtil.h"
29:                  #include "Mc32Delays.h"
30:                  #include "ESP8266.h"
31:                  #include "BME280.h"
32:                  #include "app.h"
33:                  
34:                  
35:                  /*******************************************************************************
36:                  * Auteur : Diego Rickenbach                                                    *                     
37:                  * Nom de la fonction :     ESP8266_Init                                        *                                    
38:                  * Entre :      rien                                                           *                                                                      
39:                  * Sortie :      OK :    bool BME280.Status = 1                                 *
40:                  *               ERROR : bool BME280.Status = 0                                 *
41:                  * Desription :  Cette fonction permet d'initialiser de l'ESP8266 en le         *
42:                  *               connectant au Wifi par defaut et mettons  jour la Structure   *
43:                  *               ESP8266                                                        *                                                     
44:                  * Remarques:    Voir le prototype dans ESP8266.h.                              *
45:                  *******************************************************************************/
46:                  bool ESP8266_Init(void)
47:                  {     
9D006A24  27BDFFE8   ADDIU SP, SP, -24
9D006A28  AFBF0014   SW RA, 20(SP)
9D006A2C  AFBE0010   SW FP, 16(SP)
9D006A30  03A0F021   ADDU FP, SP, ZERO
48:                      //lecture dans la flash interne au microcontroleur la structure.
49:                      NVM_ReadBlock((uint32_t *)(&Struct_save),sizeof(S_SAVE));
9D006A34  3C02A000   LUI V0, -24576
9D006A38  24440290   ADDIU A0, V0, 656
9D006A3C  2405012C   ADDIU A1, ZERO, 300
9D006A40  0F4030E2   JAL NVM_ReadBlock
9D006A44  00000000   NOP
50:                      
51:                      //test aprs la lecture dans la flash, si on retrouve la valeur du Magic
52:                      if(Struct_save.ESP8266_save.Magic == 0x1234)
9D006A48  3C02A000   LUI V0, -24576
9D006A4C  24420290   ADDIU V0, V0, 656
9D006A50  8C430048   LW V1, 72(V0)
9D006A54  24021234   ADDIU V0, ZERO, 4660
9D006A58  14620009   BNE V1, V0, 0x9D006A80
9D006A5C  00000000   NOP
53:                      {
54:                          //si oui, on rcupre la valeur d'interval qui tait enregistre
55:                          ESP8266.Interval = Struct_save.ESP8266_save.Interval;
9D006A60  3C02A000   LUI V0, -24576
9D006A64  24420290   ADDIU V0, V0, 656
9D006A68  8C430040   LW V1, 64(V0)
9D006A6C  3C02A000   LUI V0, -24576
9D006A70  24420244   ADDIU V0, V0, 580
9D006A74  AC430020   SW V1, 32(V0)
9D006A78  0B401AA4   J 0x9D006A90
9D006A7C  00000000   NOP
56:                      }
57:                      else
58:                      {
59:                          //sinon, on met une valeur par dfaut (10min)
60:                          ESP8266.Interval = 12000;
9D006A80  3C02A000   LUI V0, -24576
9D006A84  24420244   ADDIU V0, V0, 580
9D006A88  24032EE0   ADDIU V1, ZERO, 12000
9D006A8C  AC430020   SW V1, 32(V0)
61:                      }
62:                      
63:                      //test aprs la lecture dans la flash, si on retrouve la valeur du Magic
64:                      if(Struct_save.Wifi_save.Magic == 0x1234)
9D006A90  3C02A000   LUI V0, -24576
9D006A94  24420290   ADDIU V0, V0, 656
9D006A98  8C430128   LW V1, 296(V0)
9D006A9C  24021234   ADDIU V0, ZERO, 4660
9D006AA0  14620030   BNE V1, V0, 0x9D006B64
9D006AA4  00000000   NOP
65:                      {
66:                          //si oui, on rcupre les valeurs qui taient enregistres
67:                          memmove(Wifi.SSID, Struct_save.Wifi_save.SSID, sizeof(Struct_save.Wifi_save.SSID));
9D006AA8  3C03A000   LUI V1, -24576
9D006AAC  3C02A000   LUI V0, -24576
9D006AB0  24420290   ADDIU V0, V0, 656
9D006AB4  246403BC   ADDIU A0, V1, 956
9D006AB8  2443004C   ADDIU V1, V0, 76
9D006ABC  24020064   ADDIU V0, ZERO, 100
9D006AC0  00602821   ADDU A1, V1, ZERO
9D006AC4  00403021   ADDU A2, V0, ZERO
9D006AC8  0F40272F   JAL .LFE1156, memcpy
9D006ACC  00000000   NOP
68:                          memmove(Wifi.PWD, Struct_save.Wifi_save.PWD, sizeof(Struct_save.Wifi_save.PWD));
9D006AD0  3C02A000   LUI V0, -24576
9D006AD4  244303BC   ADDIU V1, V0, 956
9D006AD8  3C02A000   LUI V0, -24576
9D006ADC  24420290   ADDIU V0, V0, 656
9D006AE0  24640064   ADDIU A0, V1, 100
9D006AE4  244300B0   ADDIU V1, V0, 176
9D006AE8  24020064   ADDIU V0, ZERO, 100
9D006AEC  00602821   ADDU A1, V1, ZERO
9D006AF0  00403021   ADDU A2, V0, ZERO
9D006AF4  0F40272F   JAL .LFE1156, memcpy
9D006AF8  00000000   NOP
69:                          memmove(Wifi.IPDom, Struct_save.Wifi_save.IPDom, sizeof(Struct_save.Wifi_save.IPDom));
9D006AFC  3C02A000   LUI V0, -24576
9D006B00  244203BC   ADDIU V0, V0, 956
9D006B04  3C03A000   LUI V1, -24576
9D006B08  24630290   ADDIU V1, V1, 656
9D006B0C  8C660114   LW A2, 276(V1)
9D006B10  8C650118   LW A1, 280(V1)
9D006B14  8C64011C   LW A0, 284(V1)
9D006B18  AC4600C8   SW A2, 200(V0)
9D006B1C  AC4500CC   SW A1, 204(V0)
9D006B20  AC4400D0   SW A0, 208(V0)
9D006B24  94640120   LHU A0, 288(V1)
9D006B28  A44400D4   SH A0, 212(V0)
9D006B2C  90630122   LBU V1, 290(V1)
9D006B30  A04300D6   SB V1, 214(V0)
70:                          memmove(Wifi.PortDom, Struct_save.Wifi_save.PortDom, sizeof(Struct_save.Wifi_save.PortDom));
9D006B34  3C02A000   LUI V0, -24576
9D006B38  244203BC   ADDIU V0, V0, 956
9D006B3C  3C03A000   LUI V1, -24576
9D006B40  24630290   ADDIU V1, V1, 656
9D006B44  88640126   LWL A0, 294(V1)
9D006B48  00802821   ADDU A1, A0, ZERO
9D006B4C  98650123   LWR A1, 291(V1)
9D006B50  00A01821   ADDU V1, A1, ZERO
9D006B54  A84300DA   SWL V1, 218(V0)
9D006B58  B84300D7   SWR V1, 215(V0)
9D006B5C  0B401B13   J 0x9D006C4C
9D006B60  00000000   NOP
71:                      }
72:                      else
73:                      {
74:                          //sinon, on met une valeur par dfaut
75:                          memmove(Wifi.SSID, "Wifi-Projet-2002", strlen("Wifi-Projet-2002"));
9D006B64  3C02A000   LUI V0, -24576
9D006B68  3C039D01   LUI V1, -25343
9D006B6C  8C64A4B4   LW A0, -23372(V1)
9D006B70  2465A4B4   ADDIU A1, V1, -23372
9D006B74  8CA60004   LW A2, 4(A1)
9D006B78  2465A4B4   ADDIU A1, V1, -23372
9D006B7C  8CA50008   LW A1, 8(A1)
9D006B80  2463A4B4   ADDIU V1, V1, -23372
9D006B84  8C63000C   LW V1, 12(V1)
9D006B88  AC4403BC   SW A0, 956(V0)
9D006B8C  244403BC   ADDIU A0, V0, 956
9D006B90  AC860004   SW A2, 4(A0)
9D006B94  244403BC   ADDIU A0, V0, 956
9D006B98  AC850008   SW A1, 8(A0)
9D006B9C  244203BC   ADDIU V0, V0, 956
9D006BA0  AC43000C   SW V1, 12(V0)
76:                          memmove(Wifi.PWD, "2002-CapteurMeteo", strlen("2002-CapteurMeteo"));
9D006BA4  3C02A000   LUI V0, -24576
9D006BA8  3C039D01   LUI V1, -25343
9D006BAC  8C64A4C8   LW A0, -23352(V1)
9D006BB0  2465A4C8   ADDIU A1, V1, -23352
9D006BB4  8CA70004   LW A3, 4(A1)
9D006BB8  2465A4C8   ADDIU A1, V1, -23352
9D006BBC  8CA60008   LW A2, 8(A1)
9D006BC0  2465A4C8   ADDIU A1, V1, -23352
9D006BC4  8CA5000C   LW A1, 12(A1)
9D006BC8  AC440420   SW A0, 1056(V0)
9D006BCC  24440420   ADDIU A0, V0, 1056
9D006BD0  AC870004   SW A3, 4(A0)
9D006BD4  24440420   ADDIU A0, V0, 1056
9D006BD8  AC860008   SW A2, 8(A0)
9D006BDC  24440420   ADDIU A0, V0, 1056
9D006BE0  AC85000C   SW A1, 12(A0)
9D006BE4  2463A4C8   ADDIU V1, V1, -23352
9D006BE8  24420420   ADDIU V0, V0, 1056
9D006BEC  90630010   LBU V1, 16(V1)
9D006BF0  A0430010   SB V1, 16(V0)
77:                          memmove(Wifi.IPDom, "192.168.0.104", strlen("192.168.0.104"));
9D006BF4  3C02A000   LUI V0, -24576
9D006BF8  3C039D01   LUI V1, -25343
9D006BFC  8C64A4DC   LW A0, -23332(V1)
9D006C00  2465A4DC   ADDIU A1, V1, -23332
9D006C04  8CA60004   LW A2, 4(A1)
9D006C08  2465A4DC   ADDIU A1, V1, -23332
9D006C0C  8CA50008   LW A1, 8(A1)
9D006C10  AC440484   SW A0, 1156(V0)
9D006C14  24440484   ADDIU A0, V0, 1156
9D006C18  AC860004   SW A2, 4(A0)
9D006C1C  24440484   ADDIU A0, V0, 1156
9D006C20  AC850008   SW A1, 8(A0)
9D006C24  2463A4DC   ADDIU V1, V1, -23332
9D006C28  24420484   ADDIU V0, V0, 1156
9D006C2C  9063000C   LBU V1, 12(V1)
9D006C30  A043000C   SB V1, 12(V0)
78:                          memmove(Wifi.PortDom, "8080", strlen("8080"));
9D006C34  3C02A000   LUI V0, -24576
9D006C38  244203BC   ADDIU V0, V0, 956
9D006C3C  3C039D01   LUI V1, -25343
9D006C40  8C63A4EC   LW V1, -23316(V1)
9D006C44  A84300DA   SWL V1, 218(V0)
9D006C48  B84300D7   SWR V1, 215(V0)
79:                      }
80:                      
81:                      //HW Reset 
82:                      WIFI_RST_Off();
9D006C4C  00002021   ADDU A0, ZERO, ZERO
9D006C50  24050001   ADDIU A1, ZERO, 1
9D006C54  24060007   ADDIU A2, ZERO, 7
9D006C58  0F4037B8   JAL PLIB_PORTS_PinClear
9D006C5C  00000000   NOP
83:                      WIFI_RST_On();
9D006C60  00002021   ADDU A0, ZERO, ZERO
9D006C64  24050001   ADDIU A1, ZERO, 1
9D006C68  24060007   ADDIU A2, ZERO, 7
9D006C6C  0F4037AE   JAL PLIB_PORTS_PinSet
9D006C70  00000000   NOP
84:                      
85:                      //dlais d'attente de 5s jusqu' ce que le module soit pret
86:                      delay_msCt(5000);
9D006C74  24041388   ADDIU A0, ZERO, 5000
9D006C78  0F40342A   JAL delay_msCt
9D006C7C  00000000   NOP
87:                      
88:                      //test la prsence du module Wifi
89:                      if(ESP8266_isStarted() == OK)
9D006C80  0F4032D8   JAL ESP8266_isStarted
9D006C84  00000000   NOP
9D006C88  1440003D   BNE V0, ZERO, 0x9D006D80
9D006C8C  00000000   NOP
90:                      {
91:                          //si oui, test de le connecter au Wifi
92:                          if(ESP8266_ConnectWifi(Wifi.SSID,Wifi.PWD) == OK)
9D006C90  3C02A000   LUI V0, -24576
9D006C94  244403BC   ADDIU A0, V0, 956
9D006C98  3C02A000   LUI V0, -24576
9D006C9C  24450420   ADDIU A1, V0, 1056
9D006CA0  0F4026D3   JAL ESP8266_ConnectWifi
9D006CA4  00000000   NOP
9D006CA8  1440001B   BNE V0, ZERO, 0x9D006D18
9D006CAC  00000000   NOP
93:                          {
94:                              //si oui, le met en mode station et on enregistre son adresse IP et MAC
95:                              ESP8266_Mode(ModeStation);
9D006CB0  24040031   ADDIU A0, ZERO, 49
9D006CB4  0F402FBB   JAL ESP8266_Mode
9D006CB8  00000000   NOP
96:                              ESP8266_IP(ESP8266.IP, ESP8266.MAC);
9D006CBC  3C02A000   LUI V0, -24576
9D006CC0  24440244   ADDIU A0, V0, 580
9D006CC4  3C02A000   LUI V0, -24576
9D006CC8  24450253   ADDIU A1, V0, 595
9D006CCC  0F402D9B   JAL ESP8266_IP
9D006CD0  00000000   NOP
97:                              
98:                              //test si l'adresse IP est diffrente de 0
99:                              if(ESP8266.IP[0] != 0)
9D006CD4  3C02A000   LUI V0, -24576
9D006CD8  80420244   LB V0, 580(V0)
9D006CDC  10400008   BEQ V0, ZERO, 0x9D006D00
9D006CE0  00000000   NOP
100:                             {
101:                                 //si oui, c'est que le module est fonctionnel
102:                                 ESP8266.Status = 1;
9D006CE4  3C02A000   LUI V0, -24576
9D006CE8  24420244   ADDIU V0, V0, 580
9D006CEC  24030001   ADDIU V1, ZERO, 1
9D006CF0  A0430024   SB V1, 36(V0)
103:                                 return true;
9D006CF4  24020001   ADDIU V0, ZERO, 1
9D006CF8  0B401B64   J 0x9D006D90
9D006CFC  00000000   NOP
104:                             } 
105:                             //sinon, le module n'est pas fonctionnel
106:                             else
107:                             {
108:                                 ESP8266.Status = 0;
9D006D00  3C02A000   LUI V0, -24576
9D006D04  24420244   ADDIU V0, V0, 580
9D006D08  A0400024   SB ZERO, 36(V0)
109:                                 return false;
9D006D0C  00001021   ADDU V0, ZERO, ZERO
9D006D10  0B401B64   J 0x9D006D90
9D006D14  00000000   NOP
110:                             }
111:                         }
112:                         else
113:                         {
114:                             ESP8266_Mode(ModeStation);
9D006D18  24040031   ADDIU A0, ZERO, 49
9D006D1C  0F402FBB   JAL ESP8266_Mode
9D006D20  00000000   NOP
115:                             ESP8266_IP(ESP8266.IP, ESP8266.MAC);
9D006D24  3C02A000   LUI V0, -24576
9D006D28  24440244   ADDIU A0, V0, 580
9D006D2C  3C02A000   LUI V0, -24576
9D006D30  24450253   ADDIU A1, V0, 595
9D006D34  0F402D9B   JAL ESP8266_IP
9D006D38  00000000   NOP
116:                 
117:                             if(ESP8266.IP[0] != 0)
9D006D3C  3C02A000   LUI V0, -24576
9D006D40  80420244   LB V0, 580(V0)
9D006D44  10400008   BEQ V0, ZERO, 0x9D006D68
9D006D48  00000000   NOP
118:                             {
119:                                 ESP8266.Status = 1;
9D006D4C  3C02A000   LUI V0, -24576
9D006D50  24420244   ADDIU V0, V0, 580
9D006D54  24030001   ADDIU V1, ZERO, 1
9D006D58  A0430024   SB V1, 36(V0)
120:                                 return true;
9D006D5C  24020001   ADDIU V0, ZERO, 1
9D006D60  0B401B64   J 0x9D006D90
9D006D64  00000000   NOP
121:                             }
122:                             else
123:                             {
124:                                 ESP8266.Status = 0;
9D006D68  3C02A000   LUI V0, -24576
9D006D6C  24420244   ADDIU V0, V0, 580
9D006D70  A0400024   SB ZERO, 36(V0)
125:                                 return false;
9D006D74  00001021   ADDU V0, ZERO, ZERO
9D006D78  0B401B64   J 0x9D006D90
9D006D7C  00000000   NOP
126:                             }   
127:                         }
128:                     }
129:                     ESP8266.Status = 0;
9D006D80  3C02A000   LUI V0, -24576
9D006D84  24420244   ADDIU V0, V0, 580
9D006D88  A0400024   SB ZERO, 36(V0)
130:                     return false;
9D006D8C  00001021   ADDU V0, ZERO, ZERO
131:                 }
9D006D90  03C0E821   ADDU SP, FP, ZERO
9D006D94  8FBF0014   LW RA, 20(SP)
9D006D98  8FBE0010   LW FP, 16(SP)
9D006D9C  27BD0018   ADDIU SP, SP, 24
9D006DA0  03E00008   JR RA
9D006DA4  00000000   NOP
132:                 
133:                 /*******************************************************************************
134:                 * Auteur : Diego Rickenbach                                                    *                     
135:                 * Nom de la fonction :     ESP8266_isStarted                                   *                                    
136:                 * Entre :      rien                                                           *                                                                      
137:                 * Sortie :      OK :        Status = 0                                         *
138:                 *               ERROR :     Status = 1                                         *
139:                 *               NO_DATA :   Status = 2                                         *
140:                 *               TIMEOUT :   Status = 3                                         *
141:                 * Desription :  Cette fonction permet de vrifier la prsence du module Wifi   *                                             
142:                 * Remarques:    Voir le prototype dans ESP8266.h.                              *
143:                 *******************************************************************************/
144:                 uint8_t ESP8266_isStarted(void)
145:                 {
9D00CB60  27BDFFD0   ADDIU SP, SP, -48
9D00CB64  AFBF002C   SW RA, 44(SP)
9D00CB68  AFBE0028   SW FP, 40(SP)
9D00CB6C  03A0F021   ADDU FP, SP, ZERO
146:                     
147:                     int8_t CommandisStarted[] = "AT\r\n";   //cration de la trame a envoyer
9D00CB70  3C020A0D   LUI V0, 2573
9D00CB74  34425441   ORI V0, V0, 21569
9D00CB78  AFC20014   SW V0, 20(FP)
9D00CB7C  A3C00018   SB ZERO, 24(FP)
148:                     int8_t StrRes[10] = {0};
9D00CB80  AFC0001C   SW ZERO, 28(FP)
9D00CB84  AFC00020   SW ZERO, 32(FP)
9D00CB88  A7C00024   SH ZERO, 36(FP)
149:                     uint8_t Status = 0;
9D00CB8C  A3C00010   SB ZERO, 16(FP)
150:                     
151:                     //envoie de la trame 
152:                     SendWifiMessage(CommandisStarted, strlen((char*)CommandisStarted));
9D00CB90  27C20014   ADDIU V0, FP, 20
9D00CB94  00402021   ADDU A0, V0, ZERO
9D00CB98  0F402789   JAL strlen
9D00CB9C  00000000   NOP
9D00CBA0  304200FF   ANDI V0, V0, 255
9D00CBA4  27C30014   ADDIU V1, FP, 20
9D00CBA8  00602021   ADDU A0, V1, ZERO
9D00CBAC  00402821   ADDU A1, V0, ZERO
9D00CBB0  0F40301F   JAL SendWifiMessage
9D00CBB4  00000000   NOP
153:                     
154:                     //rcuperation du status de la rception
155:                     Status = GetWifiMessage(StrRes, "OK", 2);
9D00CBB8  27C2001C   ADDIU V0, FP, 28
9D00CBBC  00402021   ADDU A0, V0, ZERO
9D00CBC0  3C029D01   LUI V0, -25343
9D00CBC4  2445A4F4   ADDIU A1, V0, -23308
9D00CBC8  24060002   ADDIU A2, ZERO, 2
9D00CBCC  0F4025B6   JAL GetWifiMessage
9D00CBD0  00000000   NOP
9D00CBD4  A3C20010   SB V0, 16(FP)
156:                     
157:                     return Status;
9D00CBD8  93C20010   LBU V0, 16(FP)
158:                 }
9D00CBDC  03C0E821   ADDU SP, FP, ZERO
9D00CBE0  8FBF002C   LW RA, 44(SP)
9D00CBE4  8FBE0028   LW FP, 40(SP)
9D00CBE8  27BD0030   ADDIU SP, SP, 48
9D00CBEC  03E00008   JR RA
9D00CBF0  00000000   NOP
159:                 
160:                 /*******************************************************************************
161:                 * Auteur : Diego Rickenbach                                                    *                     
162:                 * Nom de la fonction :     ESP8266_Reset                                       *                                    
163:                 * Entre :      rien                                                           *                                                                      
164:                 * Sortie :      OK :        Status = 0                                         *
165:                 *               ERROR :     Status = 1                                         *
166:                 *               NO_DATA :   Status = 2                                         *
167:                 *               TIMEOUT :   Status = 3                                         *
168:                 * Desription :  Cette fonction permet de faire un reset SW du module Wifi      *                                           
169:                 * Remarques:    Voir le prototype dans ESP8266.h.                              *
170:                 *******************************************************************************/
171:                 uint8_t ESP8266_Reset(void)
172:                 {
00000000  00000000   NOP
173:                     int8_t CommandReset[] = "AT+RST\r\n";   //cration de la trame a envoyer
00000010  00000000   NOP
174:                     int8_t StrRes[14] = {0};
00000034  00000000   NOP
175:                     uint8_t Status;
176:                     
177:                     //envoie de la trame 
178:                     SendWifiMessage(CommandReset, strlen((char*)CommandReset));
00000044  00000000   NOP
179:                     
180:                     //rcuperation du status de la rception
181:                     Status = GetWifiMessage(StrRes, "OK", 100);
0000006C  00000000   NOP
182:                 
183:                     return Status;
0000008C  00000000   NOP
184:                 }
00000090  00000000   NOP
185:                 
186:                 /*******************************************************************************
187:                 * Auteur : Diego Rickenbach                                                    *                     
188:                 * Nom de la fonction :     ESP8266_Mode                                        *                                    
189:                 * Entre :      uint8_t mode                                                   *                                                                      
190:                 * Sortie :      OK :        Status = 0                                         *
191:                 *               ERROR :     Status = 1                                         *
192:                 *               NO_DATA :   Status = 2                                         *
193:                 *               TIMEOUT :   Status = 3                                         *
194:                 * Desription :  Cette fonction permet de mettre le module dans un certain mode *                                             
195:                 *               (Station, Acces Point ou Station et Acces Point)               *
196:                 * Remarques:    Voir le prototype dans ESP8266.h.                              *
197:                 *******************************************************************************/
198:                 uint8_t ESP8266_Mode(uint8_t mode)
199:                 {
9D00BEEC  27BDFFC0   ADDIU SP, SP, -64
9D00BEF0  AFBF003C   SW RA, 60(SP)
9D00BEF4  AFBE0038   SW FP, 56(SP)
9D00BEF8  03A0F021   ADDU FP, SP, ZERO
9D00BEFC  00801021   ADDU V0, A0, ZERO
9D00BF00  A3C20040   SB V0, 64(FP)
200:                     int8_t CommandMode[] = "AT+CWMODE= \r\n";   //cration de la trame a envoyer
9D00BF04  3C029D01   LUI V0, -25343
9D00BF08  8C45A504   LW A1, -23292(V0)
9D00BF0C  2443A504   ADDIU V1, V0, -23292
9D00BF10  8C640004   LW A0, 4(V1)
9D00BF14  2443A504   ADDIU V1, V0, -23292
9D00BF18  8C630008   LW V1, 8(V1)
9D00BF1C  AFC50014   SW A1, 20(FP)
9D00BF20  AFC40018   SW A0, 24(FP)
9D00BF24  AFC3001C   SW V1, 28(FP)
9D00BF28  2442A504   ADDIU V0, V0, -23292
9D00BF2C  9442000C   LHU V0, 12(V0)
9D00BF30  A7C20020   SH V0, 32(FP)
201:                     CommandMode[10] = mode;
9D00BF34  83C20040   LB V0, 64(FP)
9D00BF38  A3C2001E   SB V0, 30(FP)
202:                     int8_t StrRes[18] = {0};
9D00BF3C  AFC00024   SW ZERO, 36(FP)
9D00BF40  AFC00028   SW ZERO, 40(FP)
9D00BF44  AFC0002C   SW ZERO, 44(FP)
9D00BF48  AFC00030   SW ZERO, 48(FP)
9D00BF4C  A7C00034   SH ZERO, 52(FP)
203:                     uint8_t Status;
204:                     
205:                     //envoie de la trame
206:                     SendWifiMessage(CommandMode, strlen((char*)CommandMode));
9D00BF50  27C20014   ADDIU V0, FP, 20
9D00BF54  00402021   ADDU A0, V0, ZERO
9D00BF58  0F402789   JAL strlen
9D00BF5C  00000000   NOP
9D00BF60  304200FF   ANDI V0, V0, 255
9D00BF64  27C30014   ADDIU V1, FP, 20
9D00BF68  00602021   ADDU A0, V1, ZERO
9D00BF6C  00402821   ADDU A1, V0, ZERO
9D00BF70  0F40301F   JAL SendWifiMessage
9D00BF74  00000000   NOP
207:                     
208:                     //rcuperation du status de la rception
209:                     Status = GetWifiMessage(StrRes, "OK", 2);
9D00BF78  27C20024   ADDIU V0, FP, 36
9D00BF7C  00402021   ADDU A0, V0, ZERO
9D00BF80  3C029D01   LUI V0, -25343
9D00BF84  2445A4F4   ADDIU A1, V0, -23308
9D00BF88  24060002   ADDIU A2, ZERO, 2
9D00BF8C  0F4025B6   JAL GetWifiMessage
9D00BF90  00000000   NOP
9D00BF94  A3C20010   SB V0, 16(FP)
210:                     
211:                     return Status;
9D00BF98  93C20010   LBU V0, 16(FP)
212:                 }
9D00BF9C  03C0E821   ADDU SP, FP, ZERO
9D00BFA0  8FBF003C   LW RA, 60(SP)
9D00BFA4  8FBE0038   LW FP, 56(SP)
9D00BFA8  27BD0040   ADDIU SP, SP, 64
9D00BFAC  03E00008   JR RA
9D00BFB0  00000000   NOP
213:                 
214:                 /*******************************************************************************
215:                 * Auteur : Diego Rickenbach                                                    *                     
216:                 * Nom de la fonction :     ESP8266_ConnectWifi                                 *                                    
217:                 * Entre :      char *SSID, char *PWD                                          *                                                                      
218:                 * Sortie :      OK :        Status = 0                                         *
219:                 *               ERROR :     Status = 1                                         *
220:                 *               NO_DATA :   Status = 2                                         *
221:                 *               TIMEOUT :   Status = 3                                         *
222:                 * Desription :  Cette fonction permet de connecter le module Wifi  un reseau  *
223:                 *               Wifi                                                           *
224:                 * Remarques:    Voir le prototype dans ESP8266.h.                              *
225:                 *******************************************************************************/
226:                 uint8_t ESP8266_ConnectWifi(char *SSID, char *PWD)
227:                 {
9D009B4C  27BDFF00   ADDIU SP, SP, -256
9D009B50  AFBF00FC   SW RA, 252(SP)
9D009B54  AFBE00F8   SW FP, 248(SP)
9D009B58  03A0F021   ADDU FP, SP, ZERO
9D009B5C  AFC40100   SW A0, 256(FP)
9D009B60  AFC50104   SW A1, 260(FP)
228:                     //cration de la trame a envoyer
229:                     int8_t CommandConnectWifi1[] = "AT+CWJAP=\"";
9D009B64  3C029D01   LUI V0, -25343
9D009B68  8C44A514   LW A0, -23276(V0)
9D009B6C  2443A514   ADDIU V1, V0, -23276
9D009B70  8C630004   LW V1, 4(V1)
9D009B74  AFC40014   SW A0, 20(FP)
9D009B78  AFC30018   SW V1, 24(FP)
9D009B7C  2442A514   ADDIU V0, V0, -23276
9D009B80  94430008   LHU V1, 8(V0)
9D009B84  A7C3001C   SH V1, 28(FP)
9D009B88  9042000A   LBU V0, 10(V0)
9D009B8C  A3C2001E   SB V0, 30(FP)
230:                     int8_t CommandConnectWifi2[] = "\",\"";
9D009B90  3C020022   LUI V0, 34
9D009B94  34422C22   ORI V0, V0, 11298
9D009B98  AFC20020   SW V0, 32(FP)
231:                     int8_t CommandConnectWifi3[] = "\"\r\n\n";
9D009B9C  3C020A0A   LUI V0, 2570
9D009BA0  34420D22   ORI V0, V0, 3362
9D009BA4  AFC20024   SW V0, 36(FP)
9D009BA8  A3C00028   SB ZERO, 40(FP)
232:                     int8_t StrRes[200] = {0};
9D009BAC  27C3002C   ADDIU V1, FP, 44
9D009BB0  240200C8   ADDIU V0, ZERO, 200
9D009BB4  00602021   ADDU A0, V1, ZERO
9D009BB8  00002821   ADDU A1, ZERO, ZERO
9D009BBC  00403021   ADDU A2, V0, ZERO
9D009BC0  0F4031E5   JAL .LFE4, memset
9D009BC4  00000000   NOP
233:                     uint8_t Status;
234:                     
235:                     //envoie des trames
236:                     SendWifiMessage(CommandConnectWifi1, strlen((char*)CommandConnectWifi1));
9D009BC8  27C20014   ADDIU V0, FP, 20
9D009BCC  00402021   ADDU A0, V0, ZERO
9D009BD0  0F402789   JAL strlen
9D009BD4  00000000   NOP
9D009BD8  304200FF   ANDI V0, V0, 255
9D009BDC  27C30014   ADDIU V1, FP, 20
9D009BE0  00602021   ADDU A0, V1, ZERO
9D009BE4  00402821   ADDU A1, V0, ZERO
9D009BE8  0F40301F   JAL SendWifiMessage
9D009BEC  00000000   NOP
237:                     SendWifiMessage((int8_t*)SSID, strlen((char*)SSID));
9D009BF0  8FC40100   LW A0, 256(FP)
9D009BF4  0F402789   JAL strlen
9D009BF8  00000000   NOP
9D009BFC  304200FF   ANDI V0, V0, 255
9D009C00  8FC40100   LW A0, 256(FP)
9D009C04  00402821   ADDU A1, V0, ZERO
9D009C08  0F40301F   JAL SendWifiMessage
9D009C0C  00000000   NOP
238:                     SendWifiMessage(CommandConnectWifi2, strlen((char*)CommandConnectWifi2));
9D009C10  27C20020   ADDIU V0, FP, 32
9D009C14  00402021   ADDU A0, V0, ZERO
9D009C18  0F402789   JAL strlen
9D009C1C  00000000   NOP
9D009C20  304200FF   ANDI V0, V0, 255
9D009C24  27C30020   ADDIU V1, FP, 32
9D009C28  00602021   ADDU A0, V1, ZERO
9D009C2C  00402821   ADDU A1, V0, ZERO
9D009C30  0F40301F   JAL SendWifiMessage
9D009C34  00000000   NOP
239:                     SendWifiMessage((int8_t*)PWD, strlen((char*)PWD));
9D009C38  8FC40104   LW A0, 260(FP)
9D009C3C  0F402789   JAL strlen
9D009C40  00000000   NOP
9D009C44  304200FF   ANDI V0, V0, 255
9D009C48  8FC40104   LW A0, 260(FP)
9D009C4C  00402821   ADDU A1, V0, ZERO
9D009C50  0F40301F   JAL SendWifiMessage
9D009C54  00000000   NOP
240:                     SendWifiMessage(CommandConnectWifi3, strlen((char*)CommandConnectWifi3));
9D009C58  27C20024   ADDIU V0, FP, 36
9D009C5C  00402021   ADDU A0, V0, ZERO
9D009C60  0F402789   JAL strlen
9D009C64  00000000   NOP
9D009C68  304200FF   ANDI V0, V0, 255
9D009C6C  27C30024   ADDIU V1, FP, 36
9D009C70  00602021   ADDU A0, V1, ZERO
9D009C74  00402821   ADDU A1, V0, ZERO
9D009C78  0F40301F   JAL SendWifiMessage
9D009C7C  00000000   NOP
241:                     
242:                     //rcuperation du status de la rception
243:                     Status = GetWifiMessage(StrRes, "OK", 11000);
9D009C80  27C2002C   ADDIU V0, FP, 44
9D009C84  00402021   ADDU A0, V0, ZERO
9D009C88  3C029D01   LUI V0, -25343
9D009C8C  2445A4F4   ADDIU A1, V0, -23308
9D009C90  24062AF8   ADDIU A2, ZERO, 11000
9D009C94  0F4025B6   JAL GetWifiMessage
9D009C98  00000000   NOP
9D009C9C  A3C20010   SB V0, 16(FP)
244:                     
245:                     return Status;
9D009CA0  93C20010   LBU V0, 16(FP)
246:                 }
9D009CA4  03C0E821   ADDU SP, FP, ZERO
9D009CA8  8FBF00FC   LW RA, 252(SP)
9D009CAC  8FBE00F8   LW FP, 248(SP)
9D009CB0  27BD0100   ADDIU SP, SP, 256
9D009CB4  03E00008   JR RA
9D009CB8  00000000   NOP
247:                 
248:                 /*******************************************************************************
249:                 * Auteur : Diego Rickenbach                                                    *                     
250:                 * Nom de la fonction :     getIpAndMac                                         *                                    
251:                 * Entre :      char* inputStr, char* IpStr, char* MacStr                      *                                                                      
252:                 * Sortie :      true                                                           *
253:                 *               false                                                          *
254:                 * Desription :  Cette fonction permet de rcuprer l'adresse IP et l'adresse MAC*
255:                 * Remarques:    Voir le prototype dans ESP8266.h.                              *
256:                 *******************************************************************************/
257:                 uint8_t getIpAndMac(char* inputStr, char* IpStr, char* MacStr)
258:                 {
9D00A838  27BDFFD8   ADDIU SP, SP, -40
9D00A83C  AFBF0024   SW RA, 36(SP)
9D00A840  AFBE0020   SW FP, 32(SP)
9D00A844  03A0F021   ADDU FP, SP, ZERO
9D00A848  AFC40028   SW A0, 40(FP)
9D00A84C  AFC5002C   SW A1, 44(FP)
9D00A850  AFC60030   SW A2, 48(FP)
259:                     char* quotePos[4];
260:                         
261:                     if (strstr(inputStr, "STAIP") != NULL && strstr(inputStr, "STAMAC") != NULL)
9D00A854  8FC40028   LW A0, 40(FP)
9D00A858  3C029D01   LUI V0, -25343
9D00A85C  2445A520   ADDIU A1, V0, -23264
9D00A860  0F4032FD   JAL strstr
9D00A864  00000000   NOP
9D00A868  10400035   BEQ V0, ZERO, 0x9D00A940
9D00A86C  00000000   NOP
9D00A870  8FC40028   LW A0, 40(FP)
9D00A874  3C029D01   LUI V0, -25343
9D00A878  2445A528   ADDIU A1, V0, -23256
9D00A87C  0F4032FD   JAL strstr
9D00A880  00000000   NOP
9D00A884  1040002E   BEQ V0, ZERO, 0x9D00A940
9D00A888  00000000   NOP
262:                     {
263:                         //cherche les guillemets
264:                         quotePos[0] = strchr(inputStr, '"');
9D00A88C  8FC40028   LW A0, 40(FP)
9D00A890  24050022   ADDIU A1, ZERO, 34
9D00A894  0F403771   JAL strchr
9D00A898  00000000   NOP
9D00A89C  AFC20010   SW V0, 16(FP)
265:                         quotePos[1] = strchr(quotePos[0]+1, '"');
9D00A8A0  8FC20010   LW V0, 16(FP)
9D00A8A4  24420001   ADDIU V0, V0, 1
9D00A8A8  00402021   ADDU A0, V0, ZERO
9D00A8AC  24050022   ADDIU A1, ZERO, 34
9D00A8B0  0F403771   JAL strchr
9D00A8B4  00000000   NOP
9D00A8B8  AFC20014   SW V0, 20(FP)
266:                         quotePos[2] = strchr(quotePos[1]+1, '"');
9D00A8BC  8FC20014   LW V0, 20(FP)
9D00A8C0  24420001   ADDIU V0, V0, 1
9D00A8C4  00402021   ADDU A0, V0, ZERO
9D00A8C8  24050022   ADDIU A1, ZERO, 34
9D00A8CC  0F403771   JAL strchr
9D00A8D0  00000000   NOP
9D00A8D4  AFC20018   SW V0, 24(FP)
267:                         quotePos[3] = strchr(quotePos[2]+1, '"');
9D00A8D8  8FC20018   LW V0, 24(FP)
9D00A8DC  24420001   ADDIU V0, V0, 1
9D00A8E0  00402021   ADDU A0, V0, ZERO
9D00A8E4  24050022   ADDIU A1, ZERO, 34
9D00A8E8  0F403771   JAL strchr
9D00A8EC  00000000   NOP
9D00A8F0  AFC2001C   SW V0, 28(FP)
268:                         
269:                         *(quotePos[1]) = 0;
9D00A8F4  8FC20014   LW V0, 20(FP)
9D00A8F8  A0400000   SB ZERO, 0(V0)
270:                         *(quotePos[3]) = 0;
9D00A8FC  8FC2001C   LW V0, 28(FP)
9D00A900  A0400000   SB ZERO, 0(V0)
271:                     
272:                         strcpy(IpStr ,quotePos[0]+1);
9D00A904  8FC20010   LW V0, 16(FP)
9D00A908  24420001   ADDIU V0, V0, 1
9D00A90C  8FC4002C   LW A0, 44(FP)
9D00A910  00402821   ADDU A1, V0, ZERO
9D00A914  0F4024EC   JAL strcpy
9D00A918  00000000   NOP
273:                         strcpy(MacStr ,quotePos[2]+1); 
9D00A91C  8FC20018   LW V0, 24(FP)
9D00A920  24420001   ADDIU V0, V0, 1
9D00A924  8FC40030   LW A0, 48(FP)
9D00A928  00402821   ADDU A1, V0, ZERO
9D00A92C  0F4024EC   JAL strcpy
9D00A930  00000000   NOP
274:                         return true;
9D00A934  24020001   ADDIU V0, ZERO, 1
9D00A938  0B402A51   J 0x9D00A944
9D00A93C  00000000   NOP
275:                     } else
276:                     {
277:                         return false;  //pas trouv les chaines
9D00A940  00001021   ADDU V0, ZERO, ZERO
278:                     }
279:                 }
9D00A944  03C0E821   ADDU SP, FP, ZERO
9D00A948  8FBF0024   LW RA, 36(SP)
9D00A94C  8FBE0020   LW FP, 32(SP)
9D00A950  27BD0028   ADDIU SP, SP, 40
9D00A954  03E00008   JR RA
9D00A958  00000000   NOP
280:                 
281:                 /*******************************************************************************
282:                 * Auteur : Diego Rickenbach                                                    *                     
283:                 * Nom de la fonction :     ESP8266_IP                                          *                                    
284:                 * Entre :      char* StrIP, char* StrMAC                                      *                                                                      
285:                 * Sortie :      OK :        Status = 0                                         *
286:                 *               ERROR :     Status = 1                                         *
287:                 *               NO_DATA :   Status = 2                                         *
288:                 *               TIMEOUT :   Status = 3                                         *
289:                 * Desription :  Cette fonction permet de demander au module Wifi de donner son *
290:                 *               adresse IP ainsi que MAC                                       * 
291:                 * Remarques:    Voir le prototype dans ESP8266.h.                              *
292:                 *******************************************************************************/
293:                 uint8_t ESP8266_IP(char* StrIP, char* StrMAC)
294:                 {
9D00B66C  27BDFF70   ADDIU SP, SP, -144
9D00B670  AFBF008C   SW RA, 140(SP)
9D00B674  AFBE0088   SW FP, 136(SP)
9D00B678  03A0F021   ADDU FP, SP, ZERO
9D00B67C  AFC40090   SW A0, 144(FP)
9D00B680  AFC50094   SW A1, 148(FP)
295:                     int8_t CommandIP[] = "AT+CIFSR\r\n";
9D00B684  3C029D01   LUI V0, -25343
9D00B688  8C44A530   LW A0, -23248(V0)
9D00B68C  2443A530   ADDIU V1, V0, -23248
9D00B690  8C630004   LW V1, 4(V1)
9D00B694  AFC40014   SW A0, 20(FP)
9D00B698  AFC30018   SW V1, 24(FP)
9D00B69C  2442A530   ADDIU V0, V0, -23248
9D00B6A0  94430008   LHU V1, 8(V0)
9D00B6A4  A7C3001C   SH V1, 28(FP)
9D00B6A8  9042000A   LBU V0, 10(V0)
9D00B6AC  A3C2001E   SB V0, 30(FP)
296:                     int8_t StrRes[100] = {0};
9D00B6B0  27C30020   ADDIU V1, FP, 32
9D00B6B4  24020064   ADDIU V0, ZERO, 100
9D00B6B8  00602021   ADDU A0, V1, ZERO
9D00B6BC  00002821   ADDU A1, ZERO, ZERO
9D00B6C0  00403021   ADDU A2, V0, ZERO
9D00B6C4  0F4031E5   JAL .LFE4, memset
9D00B6C8  00000000   NOP
297:                     uint8_t Status;
298:                     
299:                     SendWifiMessage(CommandIP, strlen((char*)CommandIP));
9D00B6CC  27C20014   ADDIU V0, FP, 20
9D00B6D0  00402021   ADDU A0, V0, ZERO
9D00B6D4  0F402789   JAL strlen
9D00B6D8  00000000   NOP
9D00B6DC  304200FF   ANDI V0, V0, 255
9D00B6E0  27C30014   ADDIU V1, FP, 20
9D00B6E4  00602021   ADDU A0, V1, ZERO
9D00B6E8  00402821   ADDU A1, V0, ZERO
9D00B6EC  0F40301F   JAL SendWifiMessage
9D00B6F0  00000000   NOP
300:                     delay_msCt(100);
9D00B6F4  24040064   ADDIU A0, ZERO, 100
9D00B6F8  0F40342A   JAL delay_msCt
9D00B6FC  00000000   NOP
301:                     Status = GetWifiMessage(StrRes, "OK", 5);
9D00B700  27C20020   ADDIU V0, FP, 32
9D00B704  00402021   ADDU A0, V0, ZERO
9D00B708  3C029D01   LUI V0, -25343
9D00B70C  2445A4F4   ADDIU A1, V0, -23308
9D00B710  24060005   ADDIU A2, ZERO, 5
9D00B714  0F4025B6   JAL GetWifiMessage
9D00B718  00000000   NOP
9D00B71C  A3C20010   SB V0, 16(FP)
302:                     
303:                     getIpAndMac((char*)StrRes, StrIP, StrMAC);
9D00B720  27C20020   ADDIU V0, FP, 32
9D00B724  00402021   ADDU A0, V0, ZERO
9D00B728  8FC50090   LW A1, 144(FP)
9D00B72C  8FC60094   LW A2, 148(FP)
9D00B730  0F402A0E   JAL getIpAndMac
9D00B734  00000000   NOP
304:                     
305:                     return Status;
9D00B738  93C20010   LBU V0, 16(FP)
306:                 }
9D00B73C  03C0E821   ADDU SP, FP, ZERO
9D00B740  8FBF008C   LW RA, 140(SP)
9D00B744  8FBE0088   LW FP, 136(SP)
9D00B748  27BD0090   ADDIU SP, SP, 144
9D00B74C  03E00008   JR RA
9D00B750  00000000   NOP
307:                 
308:                 /*******************************************************************************
309:                 * Auteur : Diego Rickenbach                                                    *                     
310:                 * Nom de la fonction :     ESP8266_ConnectToTCPServer                          *                                    
311:                 * Entre :      char *StrIP, char *StrPort                                     *                                                                      
312:                 * Sortie :      OK :        Status = 0                                         *
313:                 *               ERROR :     Status = 1                                         *
314:                 *               NO_DATA :   Status = 2                                         *
315:                 *               TIMEOUT :   Status = 3                                         *
316:                 * Desription :  Cette fonction permet de connecter le module Wifi  un serveur *
317:                 *               grce  son adresse IP et son Port                             *  
318:                 * Remarques:    Voir le prototype dans ESP8266.h.                              *
319:                 *******************************************************************************/
320:                 uint8_t ESP8266_ConnectToTCPServer(char *StrIP, char *StrPort)
321:                 {
9D009858  27BDFF88   ADDIU SP, SP, -120
9D00985C  AFBF0074   SW RA, 116(SP)
9D009860  AFBE0070   SW FP, 112(SP)
9D009864  03A0F021   ADDU FP, SP, ZERO
9D009868  AFC40078   SW A0, 120(FP)
9D00986C  AFC5007C   SW A1, 124(FP)
322:                     int8_t CommandConnectTCPServer1[] = "AT+CIPSTART=\"TCP\",\"";    
9D009870  3C029D01   LUI V0, -25343
9D009874  8C46A53C   LW A2, -23236(V0)
9D009878  2443A53C   ADDIU V1, V0, -23236
9D00987C  8C650004   LW A1, 4(V1)
9D009880  2443A53C   ADDIU V1, V0, -23236
9D009884  8C640008   LW A0, 8(V1)
9D009888  2443A53C   ADDIU V1, V0, -23236
9D00988C  8C63000C   LW V1, 12(V1)
9D009890  2442A53C   ADDIU V0, V0, -23236
9D009894  8C420010   LW V0, 16(V0)
9D009898  AFC60014   SW A2, 20(FP)
9D00989C  AFC50018   SW A1, 24(FP)
9D0098A0  AFC4001C   SW A0, 28(FP)
9D0098A4  AFC30020   SW V1, 32(FP)
9D0098A8  AFC20024   SW V0, 36(FP)
323:                     int8_t CommandConnectTCPServer2[] = "\",";
9D0098AC  24022C22   ADDIU V0, ZERO, 11298
9D0098B0  A7C20028   SH V0, 40(FP)
9D0098B4  A3C0002A   SB ZERO, 42(FP)
324:                     int8_t CommandConnectTCPServer3[] = "\r\n";
9D0098B8  24020A0D   ADDIU V0, ZERO, 2573
9D0098BC  A7C2002C   SH V0, 44(FP)
9D0098C0  A3C0002E   SB ZERO, 46(FP)
325:                     int8_t StrRes[60] = {0};
9D0098C4  27C30030   ADDIU V1, FP, 48
9D0098C8  2402003C   ADDIU V0, ZERO, 60
9D0098CC  00602021   ADDU A0, V1, ZERO
9D0098D0  00002821   ADDU A1, ZERO, ZERO
9D0098D4  00403021   ADDU A2, V0, ZERO
9D0098D8  0F4031E5   JAL .LFE4, memset
9D0098DC  00000000   NOP
326:                     uint8_t Status;
327:                     
328:                     SendWifiMessage(CommandConnectTCPServer1, strlen((char*)CommandConnectTCPServer1));
9D0098E0  27C20014   ADDIU V0, FP, 20
9D0098E4  00402021   ADDU A0, V0, ZERO
9D0098E8  0F402789   JAL strlen
9D0098EC  00000000   NOP
9D0098F0  304200FF   ANDI V0, V0, 255
9D0098F4  27C30014   ADDIU V1, FP, 20
9D0098F8  00602021   ADDU A0, V1, ZERO
9D0098FC  00402821   ADDU A1, V0, ZERO
9D009900  0F40301F   JAL SendWifiMessage
9D009904  00000000   NOP
329:                     SendWifiMessage((int8_t*)StrIP, strlen((char*)StrIP));
9D009908  8FC40078   LW A0, 120(FP)
9D00990C  0F402789   JAL strlen
9D009910  00000000   NOP
9D009914  304200FF   ANDI V0, V0, 255
9D009918  8FC40078   LW A0, 120(FP)
9D00991C  00402821   ADDU A1, V0, ZERO
9D009920  0F40301F   JAL SendWifiMessage
9D009924  00000000   NOP
330:                     SendWifiMessage(CommandConnectTCPServer2, strlen((char*)CommandConnectTCPServer2));
9D009928  27C20028   ADDIU V0, FP, 40
9D00992C  00402021   ADDU A0, V0, ZERO
9D009930  0F402789   JAL strlen
9D009934  00000000   NOP
9D009938  304200FF   ANDI V0, V0, 255
9D00993C  27C30028   ADDIU V1, FP, 40
9D009940  00602021   ADDU A0, V1, ZERO
9D009944  00402821   ADDU A1, V0, ZERO
9D009948  0F40301F   JAL SendWifiMessage
9D00994C  00000000   NOP
331:                     SendWifiMessage((int8_t*)StrPort, strlen((char*)StrPort));
9D009950  8FC4007C   LW A0, 124(FP)
9D009954  0F402789   JAL strlen
9D009958  00000000   NOP
9D00995C  304200FF   ANDI V0, V0, 255
9D009960  8FC4007C   LW A0, 124(FP)
9D009964  00402821   ADDU A1, V0, ZERO
9D009968  0F40301F   JAL SendWifiMessage
9D00996C  00000000   NOP
332:                     SendWifiMessage(CommandConnectTCPServer3, strlen((char*)CommandConnectTCPServer3));
9D009970  27C2002C   ADDIU V0, FP, 44
9D009974  00402021   ADDU A0, V0, ZERO
9D009978  0F402789   JAL strlen
9D00997C  00000000   NOP
9D009980  304200FF   ANDI V0, V0, 255
9D009984  27C3002C   ADDIU V1, FP, 44
9D009988  00602021   ADDU A0, V1, ZERO
9D00998C  00402821   ADDU A1, V0, ZERO
9D009990  0F40301F   JAL SendWifiMessage
9D009994  00000000   NOP
333:                     Status = GetWifiMessage(StrRes, "OK", 1000);
9D009998  27C20030   ADDIU V0, FP, 48
9D00999C  00402021   ADDU A0, V0, ZERO
9D0099A0  3C029D01   LUI V0, -25343
9D0099A4  2445A4F4   ADDIU A1, V0, -23308
9D0099A8  240603E8   ADDIU A2, ZERO, 1000
9D0099AC  0F4025B6   JAL GetWifiMessage
9D0099B0  00000000   NOP
9D0099B4  A3C20010   SB V0, 16(FP)
334:                     
335:                     return Status;
9D0099B8  93C20010   LBU V0, 16(FP)
336:                 }
9D0099BC  03C0E821   ADDU SP, FP, ZERO
9D0099C0  8FBF0074   LW RA, 116(SP)
9D0099C4  8FBE0070   LW FP, 112(SP)
9D0099C8  27BD0078   ADDIU SP, SP, 120
9D0099CC  03E00008   JR RA
9D0099D0  00000000   NOP
337:                 
338:                 /*******************************************************************************
339:                 * Auteur : Diego Rickenbach                                                    *                     
340:                 * Nom de la fonction :     ESP8266_DisconnectTCPServer                         *                                    
341:                 * Entre :      rien                                                           *                                                                      
342:                 * Sortie :      OK :        Status = 0                                         *
343:                 *               ERROR :     Status = 1                                         *
344:                 *               NO_DATA :   Status = 2                                         *
345:                 *               TIMEOUT :   Status = 3                                         *
346:                 * Desription :  Cette fonction permet de dconnecter le module Wifi au serveur *
347:                 *               auquel il est connect                                         *  
348:                 * Remarques:    Un Timeout est prdfinit par le module Wifi dans le cas ou    *
349:                 *               l'on oublirait de se dconnecter                               *
350:                 *               Voir le prototype dans ESP8266.h.                              *
351:                 *******************************************************************************/
352:                 uint8_t ESP8266_DisconnectTCPServer(void)
353:                 {
00000000  00000000   NOP
354:                     int8_t CommandDisconnectTCPServer[] = "AT+CIPCLOSE\r\n";
00000010  00000000   NOP
355:                     int8_t StrRes[30] = {0};
00000040  00000000   NOP
356:                     uint8_t Status;
357:                     
358:                     SendWifiMessage(CommandDisconnectTCPServer, strlen((char*)CommandDisconnectTCPServer));
00000060  00000000   NOP
359:                     
360:                     Status = GetWifiMessage(StrRes, "OK", 10);
00000088  00000000   NOP
361:                     
362:                     return Status;
000000A8  00000000   NOP
363:                 }
000000AC  00000000   NOP
364:                 
365:                 /*******************************************************************************
366:                 * Auteur : Diego Rickenbach                                                    *                     
367:                 * Nom de la fonction :     SendDomoticz                                        *                                    
368:                 * Entre :      uint8_t Index, float Temp, float Hum, uint8_t Hum_stat,        *
369:                 *               float Press, uint8_t Press_fore                                *                                                                      
370:                 * Sortie :      OK :        Status = 0                                         *
371:                 *               ERROR :     Status = 1                                         *
372:                 *               NO_DATA :   Status = 2                                         *
373:                 *               TIMEOUT :   Status = 3                                         *
374:                 * Desription :  Cette fonction permet d'envoyer une requtte HTTP                                         *  
375:                 * Remarques:    Voir le prototype dans ESP8266.h.                              *
376:                 *******************************************************************************/
377:                 uint8_t SendDomoticz(uint8_t Index, float Temp, float Hum, uint8_t Hum_stat, float Press, uint8_t Press_fore)
378:                 {  
9D009028  27BDFD20   ADDIU SP, SP, -736
9D00902C  AFBF02DC   SW RA, 732(SP)
9D009030  AFBE02D8   SW FP, 728(SP)
9D009034  AFB502D4   SW S5, 724(SP)
9D009038  AFB402D0   SW S4, 720(SP)
9D00903C  AFB302CC   SW S3, 716(SP)
9D009040  AFB202C8   SW S2, 712(SP)
9D009044  AFB102C4   SW S1, 708(SP)
9D009048  AFB002C0   SW S0, 704(SP)
9D00904C  03A0F021   ADDU FP, SP, ZERO
9D009050  00801821   ADDU V1, A0, ZERO
9D009054  AFC502E4   SW A1, 740(FP)
9D009058  AFC602E8   SW A2, 744(FP)
9D00905C  00E01021   ADDU V0, A3, ZERO
9D009060  A3C302E0   SB V1, 736(FP)
9D009064  A3C202EC   SB V0, 748(FP)
379:                     int8_t cmdString[20];
380:                     uint8_t cmdStringLen;
381:                     
382:                     int8_t httpString[120];
383:                     uint8_t httpStringLen;
384:                     
385:                     int8_t StrRes[500] = {0};
9D009068  27C300C8   ADDIU V1, FP, 200
9D00906C  240201F4   ADDIU V0, ZERO, 500
9D009070  00602021   ADDU A0, V1, ZERO
9D009074  00002821   ADDU A1, ZERO, ZERO
9D009078  00403021   ADDU A2, V0, ZERO
9D00907C  0F4031E5   JAL .LFE4, memset
9D009080  00000000   NOP
386:                     uint8_t Status;
387:                     //char IPDom[15]= "192.168.0.104";
388:                     //char PortDom[4]="8080";
389:                     
390:                     sprintf((char*)httpString, "GET /json.htm?type=command&param=udevice&idx=%d&nvalue=0&svalue=%.1f;%.1f;%d;%.1f;%d HTTP/1.0\r\n\r\n", 
9D009084  93D402E0   LBU S4, 736(FP)
9D009088  8FC402E4   LW A0, 740(FP)
9D00908C  0F403166   JAL __extendsfdf2
9D009090  00000000   NOP
9D009094  00409021   ADDU S2, V0, ZERO
9D009098  00609821   ADDU S3, V1, ZERO
9D00909C  8FC402E8   LW A0, 744(FP)
9D0090A0  0F403166   JAL __extendsfdf2
9D0090A4  00000000   NOP
9D0090A8  00408021   ADDU S0, V0, ZERO
9D0090AC  00608821   ADDU S1, V1, ZERO
9D0090B0  93D502EC   LBU S5, 748(FP)
9D0090B4  8FC402F0   LW A0, 752(FP)
9D0090B8  0F403166   JAL __extendsfdf2
9D0090BC  00000000   NOP
9D0090C0  93C502F4   LBU A1, 756(FP)
9D0090C4  27C40050   ADDIU A0, FP, 80
9D0090C8  AFB20010   SW S2, 16(SP)
9D0090CC  AFB30014   SW S3, 20(SP)
9D0090D0  AFB00018   SW S0, 24(SP)
9D0090D4  AFB1001C   SW S1, 28(SP)
9D0090D8  AFB50020   SW S5, 32(SP)
9D0090DC  AFA20028   SW V0, 40(SP)
9D0090E0  AFA3002C   SW V1, 44(SP)
9D0090E4  AFA50030   SW A1, 48(SP)
9D0090E8  3C029D01   LUI V0, -25343
9D0090EC  2445A560   ADDIU A1, V0, -23200
9D0090F0  02803021   ADDU A2, S4, ZERO
9D0090F4  0F40350B   JAL _sprintf_cdfFnopsuxX
9D0090F8  00000000   NOP
391:                             Index, (double)Temp, (double)Hum , Hum_stat, (double)Press, Press_fore);        
392:                     httpStringLen = strlen((char*)httpString);
9D0090FC  27C20050   ADDIU V0, FP, 80
9D009100  00402021   ADDU A0, V0, ZERO
9D009104  0F402789   JAL strlen
9D009108  00000000   NOP
9D00910C  A3C20038   SB V0, 56(FP)
393:                     
394:                     sprintf ((char*)cmdString, "AT+CIPSEND=%2d\r\n", httpStringLen);
9D009110  93C20038   LBU V0, 56(FP)
9D009114  27C3003C   ADDIU V1, FP, 60
9D009118  00602021   ADDU A0, V1, ZERO
9D00911C  3C039D01   LUI V1, -25343
9D009120  2465A5C4   ADDIU A1, V1, -23100
9D009124  00403021   ADDU A2, V0, ZERO
9D009128  0F40350B   JAL _sprintf_cdfFnopsuxX
9D00912C  00000000   NOP
395:                     cmdStringLen = strlen((char*)cmdString);    
9D009130  27C2003C   ADDIU V0, FP, 60
9D009134  00402021   ADDU A0, V0, ZERO
9D009138  0F402789   JAL strlen
9D00913C  00000000   NOP
9D009140  A3C20039   SB V0, 57(FP)
396:                     
397:                     if(ESP8266_ConnectToTCPServer(Wifi.IPDom,Wifi.PortDom) == OK)
9D009144  3C02A000   LUI V0, -24576
9D009148  24440484   ADDIU A0, V0, 1156
9D00914C  3C02A000   LUI V0, -24576
9D009150  24450493   ADDIU A1, V0, 1171
9D009154  0F402616   JAL ESP8266_ConnectToTCPServer
9D009158  00000000   NOP
9D00915C  14400010   BNE V0, ZERO, .LVL125
9D009160  00000000   NOP
398:                     {
399:                         SendWifiMessage(cmdString, cmdStringLen);
9D009164  27C3003C   ADDIU V1, FP, 60
9D009168  93C20039   LBU V0, 57(FP)
9D00916C  00602021   ADDU A0, V1, ZERO
9D009170  00402821   ADDU A1, V0, ZERO
9D009174  0F40301F   JAL SendWifiMessage
9D009178  00000000   NOP
400:                         delay_msCt(10);
9D00917C  2404000A   ADDIU A0, ZERO, 10
9D009180  0F40342A   JAL delay_msCt
9D009184  00000000   NOP
401:                         SendWifiMessage(httpString, httpStringLen);
9D009188  27C30050   ADDIU V1, FP, 80
9D00918C  93C20038   LBU V0, 56(FP)
9D009190  00602021   ADDU A0, V1, ZERO
9D009194  00402821   ADDU A1, V0, ZERO
9D009198  0F40301F   JAL SendWifiMessage
9D00919C  00000000   NOP
402:                     }
403:                     
404:                     Status = GetWifiMessage(StrRes, "CLOSE", 20000);
9D0091A0  27C200C8   ADDIU V0, FP, 200
9D0091A4  00402021   ADDU A0, V0, ZERO
9D0091A8  3C029D01   LUI V0, -25343
9D0091AC  2445A5D8   ADDIU A1, V0, -23080
9D0091B0  24064E20   ADDIU A2, ZERO, 20000
9D0091B4  0F4025B6   JAL GetWifiMessage
9D0091B8  00000000   NOP
9D0091BC  A3C2003A   SB V0, 58(FP)
405:                     return Status;
9D0091C0  93C2003A   LBU V0, 58(FP)
406:                 }
9D0091C4  03C0E821   ADDU SP, FP, ZERO
9D0091C8  8FBF02DC   LW RA, 732(SP)
9D0091CC  8FBE02D8   LW FP, 728(SP)
9D0091D0  8FB502D4   LW S5, 724(SP)
9D0091D4  8FB402D0   LW S4, 720(SP)
9D0091D8  8FB302CC   LW S3, 716(SP)
9D0091DC  8FB202C8   LW S2, 712(SP)
9D0091E0  8FB102C4   LW S1, 708(SP)
9D0091E4  8FB002C0   LW S0, 704(SP)
9D0091E8  27BD02E0   ADDIU SP, SP, 736
9D0091EC  03E00008   JR RA
9D0091F0  00000000   NOP
407:                 // *****************************************************************************
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/bme280.c  ------------------
1:                   //--------------------------------------------------------
2:                   // Mc32gestSensor.C
3:                   //--------------------------------------------------------
4:                   // Gestion des capteurs
5:                   //	Description     :	Fonctions pour l'utilisation des capteurs
6:                   //
7:                   //	Auteur          : 	D. Rickenbach
8:                   //  Date            :   18.08.2020
9:                   //	Version         :	V0.5
10:                  //	Compilateur     :	XC32 V5.15 & Harmony 2_06
11:                  // Modifications    :
12:                  //
13:                  /*--------------------------------------------------------*/
14:                  
15:                  // *****************************************************************************
16:                  // *****************************************************************************
17:                  // Section: Included Files 
18:                  // *****************************************************************************
19:                  // *****************************************************************************
20:                  #include <stdint.h>
21:                  #include <stdbool.h>
22:                  #include "BME280.h"
23:                  #include "app.h"
24:                  #include "Mc32gest_I2C.h"
25:                  #include "Mc32_I2cUtilCCS.h"
26:                  #include "Mc32NVMUtil.h"
27:                  #include "Mc32Delays.h"
28:                  #include <math.h>
29:                  
30:                  // *****************************************************************************
31:                  
32:                  // prototypes des fonctions
33:                  void BME280_ReadCoefficents(void);
34:                  
35:                  
36:                  //S_BME280 BME280;
37:                  
38:                  // variable globale
39:                  int32_t t_fine;
40:                  
41:                  //Structure des coefficients de calibration
42:                  typedef struct
43:                  {
44:                      uint16_t dig_T1;
45:                      int16_t  dig_T2;
46:                      int16_t  dig_T3;
47:                  
48:                      uint16_t dig_P1;
49:                      int16_t  dig_P2;
50:                      int16_t  dig_P3;
51:                      int16_t  dig_P4;
52:                      int16_t  dig_P5;
53:                      int16_t  dig_P6;
54:                      int16_t  dig_P7;
55:                      int16_t  dig_P8;
56:                      int16_t  dig_P9;
57:                  
58:                      uint8_t  dig_H1;
59:                      int16_t  dig_H2;
60:                      uint8_t  dig_H3;
61:                      int16_t  dig_H4;
62:                      int16_t  dig_H5;
63:                      int8_t   dig_H6;
64:                  } bme280_calib_data;
65:                      
66:                  bme280_calib_data BME280_calibration;
67:                  
68:                  /*******************************************************************************
69:                  * Auteur : Diego Rickenbach                                                    *                     
70:                  * Nom de la fonction :     BME280_Init                                         *                                    
71:                  * Entre :      rien                                                           *                                                                      
72:                  * Sortie :      OK :    bool BME280.Status = 1                                 *
73:                  *               ERROR : bool BME280.Status = 0                                 *
74:                  * Desription :  Cette fonction permet d'initialiser le BME280 en fonction des  *
75:                  *               des registres ctrl_hum, config et ctrl_meas.                   *                                                     
76:                  * Remarques:    Voir le prototype dans BME280.h.                               *
77:                  *******************************************************************************/
78:                  bool BME280_Init(void)
79:                  {
9D0099D4  27BDFFE0   ADDIU SP, SP, -32
9D0099D8  AFBF001C   SW RA, 28(SP)
9D0099DC  AFBE0018   SW FP, 24(SP)
9D0099E0  03A0F021   ADDU FP, SP, ZERO
80:                      // variable de configuration du BME280:
81:                      // - ctrl_humid register sets humidity data acquisition options of the device
82:                      // - config register sets the rate filter and interface options of the device
83:                      // - ctrl_meas register sets the pressure and temperature data acquisition 
84:                      //   options of the device
85:                      int8_t ctrl_hum = 0b001, config = 0b1010000, ctrl_meas = 0b00100111;      
9D0099E4  24020001   ADDIU V0, ZERO, 1
9D0099E8  A3C20010   SB V0, 16(FP)
9D0099EC  24020050   ADDIU V0, ZERO, 80
9D0099F0  A3C20011   SB V0, 17(FP)
9D0099F4  24020027   ADDIU V0, ZERO, 39
9D0099F8  A3C20012   SB V0, 18(FP)
86:                      //   OS hum 1  / SB 1s, no filter, spi disable / OS temp. 1, OS press. 1, normal mode 
87:                      
88:                      NVM_ReadBlock((uint32_t *)(&Struct_save),sizeof(S_SAVE));
9D0099FC  3C02A000   LUI V0, -24576
9D009A00  24440290   ADDIU A0, V0, 656
9D009A04  2405012C   ADDIU A1, ZERO, 300
9D009A08  0F4030E2   JAL NVM_ReadBlock
9D009A0C  00000000   NOP
89:                      if(Struct_save.BME280_save.Magic == 0x1234)
9D009A10  3C02A000   LUI V0, -24576
9D009A14  24420290   ADDIU V0, V0, 656
9D009A18  8C430018   LW V1, 24(V0)
9D009A1C  24021234   ADDIU V0, ZERO, 4660
9D009A20  14620007   BNE V1, V0, 0x9D009A40
9D009A24  00000000   NOP
90:                      {
91:                          BME280.Index = Struct_save.BME280_save.Index;
9D009A28  3C02A000   LUI V0, -24576
9D009A2C  90430290   LBU V1, 656(V0)
9D009A30  3C02A000   LUI V0, -24576
9D009A34  A0430270   SB V1, 624(V0)
9D009A38  0B402697   J 0x9D009A5C
9D009A3C  00000000   NOP
92:                      }
93:                      else
94:                      {
95:                          BME280.Index = 1;
9D009A40  3C02A000   LUI V0, -24576
9D009A44  24030001   ADDIU V1, ZERO, 1
9D009A48  A0430270   SB V1, 624(V0)
96:                          BME280.Altitude = 450;
9D009A4C  3C02A000   LUI V0, -24576
9D009A50  24420270   ADDIU V0, V0, 624
9D009A54  240301C2   ADDIU V1, ZERO, 450
9D009A58  A4430016   SH V1, 22(V0)
97:                      }
98:                          
99:                      I2C_Init();
9D009A5C  0F4036D0   JAL I2C_Init
9D009A60  00000000   NOP
100:                     
101:                     // reset the BME280 using soft-reset
102:                     // this makes sure the IIR is off, etc.
103:                     I2CSensor_Write8(BME280_ADDRESS, BME280_REGISTER_SOFTRESET, 0xB6);
9D009A64  24040077   ADDIU A0, ZERO, 119
9D009A68  240500E0   ADDIU A1, ZERO, 224
9D009A6C  240600B6   ADDIU A2, ZERO, 182
9D009A70  0F403367   JAL I2CSensor_Write8
9D009A74  00000000   NOP
104:                     // wait for chip to wake up.
105:                     while(I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_STATUS));
9D009A78  00000000   NOP
9D009A7C  24040077   ADDIU A0, ZERO, 119
9D009A80  240500F3   ADDIU A1, ZERO, 243
9D009A84  0F4031BB   JAL I2CSensor_Read8
9D009A88  00000000   NOP
9D009A8C  1440FFFB   BNE V0, ZERO, 0x9D009A7C
9D009A90  00000000   NOP
106:                     
107:                     // check if sensor, i.e. the chip ID is correct
108:                     
109:                     uint8_t ID_test = I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_CHIPID);
9D009A94  24040077   ADDIU A0, ZERO, 119
9D009A98  240500D0   ADDIU A1, ZERO, 208
9D009A9C  0F4031BB   JAL I2CSensor_Read8
9D009AA0  00000000   NOP
9D009AA4  A3C20013   SB V0, 19(FP)
110:                     
111:                     if(ID_test != 0x60)
9D009AA8  93C30013   LBU V1, 19(FP)
9D009AAC  24020060   ADDIU V0, ZERO, 96
9D009AB0  10620007   BEQ V1, V0, 0x9D009AD0
9D009AB4  00000000   NOP
112:                     {
113:                         BME280.Status = 0;
9D009AB8  3C02A000   LUI V0, -24576
9D009ABC  24420270   ADDIU V0, V0, 624
9D009AC0  A040001C   SB ZERO, 28(V0)
114:                         return false; // BME280 not found
9D009AC4  00001021   ADDU V0, ZERO, ZERO
9D009AC8  0B4026CD   J 0x9D009B34
9D009ACC  00000000   NOP
115:                     }
116:                     
117:                     
118:                     // read trimming parameters, see DS 4.2.2
119:                     BME280_ReadCoefficents();
9D009AD0  0F401E9F   JAL BME280_ReadCoefficents
9D009AD4  00000000   NOP
120:                     
121:                     // you must make sure to also set REGISTER_CONTROL after setting the
122:                     // CTRL_HUMID register, otherwise the values won't be applied
123:                     // (see DS 5.4.3)
124:                     I2CSensor_Write8(BME280_ADDRESS, BME280_REGISTER_CONTROLHUMID, ctrl_hum);
9D009AD8  93C20010   LBU V0, 16(FP)
9D009ADC  24040077   ADDIU A0, ZERO, 119
9D009AE0  240500F2   ADDIU A1, ZERO, 242
9D009AE4  00403021   ADDU A2, V0, ZERO
9D009AE8  0F403367   JAL I2CSensor_Write8
9D009AEC  00000000   NOP
125:                     I2CSensor_Write8(BME280_ADDRESS, BME280_REGISTER_CONFIG, config);
9D009AF0  93C20011   LBU V0, 17(FP)
9D009AF4  24040077   ADDIU A0, ZERO, 119
9D009AF8  240500F5   ADDIU A1, ZERO, 245
9D009AFC  00403021   ADDU A2, V0, ZERO
9D009B00  0F403367   JAL I2CSensor_Write8
9D009B04  00000000   NOP
126:                     I2CSensor_Write8(BME280_ADDRESS, BME280_REGISTER_CONTROL, ctrl_meas);
9D009B08  93C20012   LBU V0, 18(FP)
9D009B0C  24040077   ADDIU A0, ZERO, 119
9D009B10  240500F4   ADDIU A1, ZERO, 244
9D009B14  00403021   ADDU A2, V0, ZERO
9D009B18  0F403367   JAL I2CSensor_Write8
9D009B1C  00000000   NOP
127:                     
128:                     BME280.Status = 1;
9D009B20  3C02A000   LUI V0, -24576
9D009B24  24420270   ADDIU V0, V0, 624
9D009B28  24030001   ADDIU V1, ZERO, 1
9D009B2C  A043001C   SB V1, 28(V0)
129:                     return true;    
9D009B30  24020001   ADDIU V0, ZERO, 1
130:                 } //end Sensor_Init
9D009B34  03C0E821   ADDU SP, FP, ZERO
9D009B38  8FBF001C   LW RA, 28(SP)
9D009B3C  8FBE0018   LW FP, 24(SP)
9D009B40  27BD0020   ADDIU SP, SP, 32
9D009B44  03E00008   JR RA
9D009B48  00000000   NOP
131:                 
132:                 /*******************************************************************************
133:                 * Auteur : Diego Rickenbach                                                    *                     
134:                 * Nom de la fonction :  BME280_ReadCoefficents                                 *                                    
135:                 * Entre :      rien                                                           *                                                                      
136:                 * Sortie :      rien                                                           *
137:                 * Desription :  Cette fonction permet de lire tous les registre contenant les  *
138:                 *               coefficient de calibration pour la temprature, l'humidite et  *
139:                 *               la pression et enregistre les donnes dans la tructure         *
140:                 *               BME280_calibration.                                            *                                                     
141:                 * Remarques:    Voir le prototype dans BME280.h.                               *
142:                 *******************************************************************************/
143:                 void BME280_ReadCoefficents(void)
144:                 {
9D007A7C  27BDFFE0   ADDIU SP, SP, -32
9D007A80  AFBF001C   SW RA, 28(SP)
9D007A84  AFBE0018   SW FP, 24(SP)
9D007A88  AFB00014   SW S0, 20(SP)
9D007A8C  03A0F021   ADDU FP, SP, ZERO
145:                     BME280_calibration.dig_T1 = I2CSensor_Read16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_T1);
9D007A90  24040077   ADDIU A0, ZERO, 119
9D007A94  24050088   ADDIU A1, ZERO, 136
9D007A98  0F403449   JAL I2CSensor_Read16_LE
9D007A9C  00000000   NOP
9D007AA0  00401821   ADDU V1, V0, ZERO
9D007AA4  3C02A000   LUI V0, -24576
9D007AA8  A4430CBC   SH V1, 3260(V0)
146:                     BME280_calibration.dig_T2 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_T2);
9D007AAC  24040077   ADDIU A0, ZERO, 119
9D007AB0  2405008A   ADDIU A1, ZERO, 138
9D007AB4  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007AB8  00000000   NOP
9D007ABC  00401821   ADDU V1, V0, ZERO
9D007AC0  3C02A000   LUI V0, -24576
9D007AC4  24420CBC   ADDIU V0, V0, 3260
9D007AC8  A4430002   SH V1, 2(V0)
147:                     BME280_calibration.dig_T3 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_T3);
9D007ACC  24040077   ADDIU A0, ZERO, 119
9D007AD0  2405008C   ADDIU A1, ZERO, 140
9D007AD4  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007AD8  00000000   NOP
9D007ADC  00401821   ADDU V1, V0, ZERO
9D007AE0  3C02A000   LUI V0, -24576
9D007AE4  24420CBC   ADDIU V0, V0, 3260
9D007AE8  A4430004   SH V1, 4(V0)
148:                 
149:                     BME280_calibration.dig_P1 = I2CSensor_Read16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_P1);
9D007AEC  24040077   ADDIU A0, ZERO, 119
9D007AF0  2405008E   ADDIU A1, ZERO, 142
9D007AF4  0F403449   JAL I2CSensor_Read16_LE
9D007AF8  00000000   NOP
9D007AFC  00401821   ADDU V1, V0, ZERO
9D007B00  3C02A000   LUI V0, -24576
9D007B04  24420CBC   ADDIU V0, V0, 3260
9D007B08  A4430006   SH V1, 6(V0)
150:                     BME280_calibration.dig_P2 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_P2);
9D007B0C  24040077   ADDIU A0, ZERO, 119
9D007B10  24050090   ADDIU A1, ZERO, 144
9D007B14  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007B18  00000000   NOP
9D007B1C  00401821   ADDU V1, V0, ZERO
9D007B20  3C02A000   LUI V0, -24576
9D007B24  24420CBC   ADDIU V0, V0, 3260
9D007B28  A4430008   SH V1, 8(V0)
151:                     BME280_calibration.dig_P3 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_P3);
9D007B2C  24040077   ADDIU A0, ZERO, 119
9D007B30  24050092   ADDIU A1, ZERO, 146
9D007B34  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007B38  00000000   NOP
9D007B3C  00401821   ADDU V1, V0, ZERO
9D007B40  3C02A000   LUI V0, -24576
9D007B44  24420CBC   ADDIU V0, V0, 3260
9D007B48  A443000A   SH V1, 10(V0)
152:                     BME280_calibration.dig_P4 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_P4);
9D007B4C  24040077   ADDIU A0, ZERO, 119
9D007B50  24050094   ADDIU A1, ZERO, 148
9D007B54  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007B58  00000000   NOP
9D007B5C  00401821   ADDU V1, V0, ZERO
9D007B60  3C02A000   LUI V0, -24576
9D007B64  24420CBC   ADDIU V0, V0, 3260
9D007B68  A443000C   SH V1, 12(V0)
153:                     BME280_calibration.dig_P5 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_P5);
9D007B6C  24040077   ADDIU A0, ZERO, 119
9D007B70  24050096   ADDIU A1, ZERO, 150
9D007B74  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007B78  00000000   NOP
9D007B7C  00401821   ADDU V1, V0, ZERO
9D007B80  3C02A000   LUI V0, -24576
9D007B84  24420CBC   ADDIU V0, V0, 3260
9D007B88  A443000E   SH V1, 14(V0)
154:                     BME280_calibration.dig_P6 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_P6);
9D007B8C  24040077   ADDIU A0, ZERO, 119
9D007B90  24050098   ADDIU A1, ZERO, 152
9D007B94  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007B98  00000000   NOP
9D007B9C  00401821   ADDU V1, V0, ZERO
9D007BA0  3C02A000   LUI V0, -24576
9D007BA4  24420CBC   ADDIU V0, V0, 3260
9D007BA8  A4430010   SH V1, 16(V0)
155:                     BME280_calibration.dig_P7 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_P7);
9D007BAC  24040077   ADDIU A0, ZERO, 119
9D007BB0  2405009A   ADDIU A1, ZERO, 154
9D007BB4  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007BB8  00000000   NOP
9D007BBC  00401821   ADDU V1, V0, ZERO
9D007BC0  3C02A000   LUI V0, -24576
9D007BC4  24420CBC   ADDIU V0, V0, 3260
9D007BC8  A4430012   SH V1, 18(V0)
156:                     BME280_calibration.dig_P8 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_P8);
9D007BCC  24040077   ADDIU A0, ZERO, 119
9D007BD0  2405009C   ADDIU A1, ZERO, 156
9D007BD4  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007BD8  00000000   NOP
9D007BDC  00401821   ADDU V1, V0, ZERO
9D007BE0  3C02A000   LUI V0, -24576
9D007BE4  24420CBC   ADDIU V0, V0, 3260
9D007BE8  A4430014   SH V1, 20(V0)
157:                     BME280_calibration.dig_P9 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_P9);
9D007BEC  24040077   ADDIU A0, ZERO, 119
9D007BF0  2405009E   ADDIU A1, ZERO, 158
9D007BF4  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007BF8  00000000   NOP
9D007BFC  00401821   ADDU V1, V0, ZERO
9D007C00  3C02A000   LUI V0, -24576
9D007C04  24420CBC   ADDIU V0, V0, 3260
9D007C08  A4430016   SH V1, 22(V0)
158:                 
159:                     BME280_calibration.dig_H1 = I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_DIG_H1);
9D007C0C  24040077   ADDIU A0, ZERO, 119
9D007C10  240500A1   ADDIU A1, ZERO, 161
9D007C14  0F4031BB   JAL I2CSensor_Read8
9D007C18  00000000   NOP
9D007C1C  00401821   ADDU V1, V0, ZERO
9D007C20  3C02A000   LUI V0, -24576
9D007C24  24420CBC   ADDIU V0, V0, 3260
9D007C28  A0430018   SB V1, 24(V0)
160:                     BME280_calibration.dig_H2 = I2CSensor_ReadS16_LE(BME280_ADDRESS, BME280_REGISTER_DIG_H2);
9D007C2C  24040077   ADDIU A0, ZERO, 119
9D007C30  240500E1   ADDIU A1, ZERO, 225
9D007C34  0F4035D0   JAL I2CSensor_ReadS16_LE
9D007C38  00000000   NOP
9D007C3C  00401821   ADDU V1, V0, ZERO
9D007C40  3C02A000   LUI V0, -24576
9D007C44  24420CBC   ADDIU V0, V0, 3260
9D007C48  A443001A   SH V1, 26(V0)
161:                     BME280_calibration.dig_H3 = I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_DIG_H3);
9D007C4C  24040077   ADDIU A0, ZERO, 119
9D007C50  240500E3   ADDIU A1, ZERO, 227
9D007C54  0F4031BB   JAL I2CSensor_Read8
9D007C58  00000000   NOP
9D007C5C  00401821   ADDU V1, V0, ZERO
9D007C60  3C02A000   LUI V0, -24576
9D007C64  24420CBC   ADDIU V0, V0, 3260
9D007C68  A043001C   SB V1, 28(V0)
162:                     BME280_calibration.dig_H4 = (I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_DIG_H4) << 4) | 
9D007C6C  24040077   ADDIU A0, ZERO, 119
9D007C70  240500E4   ADDIU A1, ZERO, 228
9D007C74  0F4031BB   JAL I2CSensor_Read8
9D007C78  00000000   NOP
9D007C7C  00021100   SLL V0, V0, 4
9D007C80  7C028620   SEH S0, V0
9D007C94  7C021620   SEH V0, V0
9D007C98  3042000F   ANDI V0, V0, 15
9D007C9C  7C021620   SEH V0, V0
9D007CA0  02021025   OR V0, S0, V0
9D007CA4  7C021E20   SEH V1, V0
9D007CA8  3C02A000   LUI V0, -24576
9D007CAC  24420CBC   ADDIU V0, V0, 3260
9D007CB0  A443001E   SH V1, 30(V0)
163:                             (I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_DIG_H4+1) & 0xF);
9D007C84  24040077   ADDIU A0, ZERO, 119
9D007C88  240500E5   ADDIU A1, ZERO, 229
9D007C8C  0F4031BB   JAL I2CSensor_Read8
9D007C90  00000000   NOP
164:                     BME280_calibration.dig_H5 = (I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_DIG_H5+1) << 4) | 
9D007CB4  24040077   ADDIU A0, ZERO, 119
9D007CB8  240500E6   ADDIU A1, ZERO, 230
9D007CBC  0F4031BB   JAL I2CSensor_Read8
9D007CC0  00000000   NOP
9D007CC4  00021100   SLL V0, V0, 4
9D007CC8  7C028620   SEH S0, V0
9D007CDC  00021102   SRL V0, V0, 4
9D007CE0  304200FF   ANDI V0, V0, 255
9D007CE4  7C021620   SEH V0, V0
9D007CE8  02021025   OR V0, S0, V0
9D007CEC  7C021E20   SEH V1, V0
9D007CF0  3C02A000   LUI V0, -24576
9D007CF4  24420CBC   ADDIU V0, V0, 3260
9D007CF8  A4430020   SH V1, 32(V0)
165:                             (I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_DIG_H5) >> 4);
9D007CCC  24040077   ADDIU A0, ZERO, 119
9D007CD0  240500E5   ADDIU A1, ZERO, 229
9D007CD4  0F4031BB   JAL I2CSensor_Read8
9D007CD8  00000000   NOP
166:                     BME280_calibration.dig_H6 = (int8_t)I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_DIG_H6);
9D007CFC  24040077   ADDIU A0, ZERO, 119
9D007D00  240500E7   ADDIU A1, ZERO, 231
9D007D04  0F4031BB   JAL I2CSensor_Read8
9D007D08  00000000   NOP
9D007D0C  7C021C20   SEB V1, V0
9D007D10  3C02A000   LUI V0, -24576
9D007D14  24420CBC   ADDIU V0, V0, 3260
9D007D18  A0430022   SB V1, 34(V0)
167:                 }
9D007D1C  03C0E821   ADDU SP, FP, ZERO
9D007D20  8FBF001C   LW RA, 28(SP)
9D007D24  8FBE0018   LW FP, 24(SP)
9D007D28  8FB00014   LW S0, 20(SP)
9D007D2C  27BD0020   ADDIU SP, SP, 32
9D007D30  03E00008   JR RA
9D007D34  00000000   NOP
168:                 
169:                 /*******************************************************************************
170:                 * Auteur : Diego Rickenbach                                                    *                     
171:                 * Nom de la fonction :  BME280_readTemperature                                 *                                    
172:                 * Entre :      rien                                                           *                                                                      
173:                 * Sortie :      float T                                                        *
174:                 * Desription :  Cette fonction permet de rcuprer les donnes et grce aux    *
175:                 *               calcules de compensations, donns dans le datasheet, d'en      *
176:                 *               sortir la temprature.                                         *                                                     
177:                 * Remarques:    t_fine est une variable golbale utilise dans plusieurs        *
178:                 *               fonctions.                                                     *
179:                 *               Voir le prototype dans BME280.h.                               *
180:                 *******************************************************************************/
181:                 float BME280_readTemperature(void)
182:                 {    
9D00A380  27BDFFD8   ADDIU SP, SP, -40
9D00A384  AFBF0024   SW RA, 36(SP)
9D00A388  AFBE0020   SW FP, 32(SP)
9D00A38C  03A0F021   ADDU FP, SP, ZERO
183:                     int32_t var1, var2, adc_T;
184:                     
185:                     adc_T = I2CSensor_Read24(BME280_ADDRESS, BME280_REGISTER_TEMPDATA);
9D00A390  24040077   ADDIU A0, ZERO, 119
9D00A394  240500FA   ADDIU A1, ZERO, 250
9D00A398  0F402CE7   JAL I2CSensor_Read24
9D00A39C  00000000   NOP
9D00A3A0  AFC20010   SW V0, 16(FP)
186:                 
187:                     if (adc_T == 0x800000) // value in case temp measurement was disabled
9D00A3A4  8FC30010   LW V1, 16(FP)
9D00A3A8  3C020080   LUI V0, 128
9D00A3AC  14620004   BNE V1, V0, 0x9D00A3C0
9D00A3B0  00000000   NOP
188:                         return false;
9D00A3B4  00001021   ADDU V0, ZERO, ZERO
9D00A3B8  0B402927   J .LVL51
9D00A3BC  00000000   NOP
189:                     
190:                     adc_T >>= 4;
9D00A3C0  8FC20010   LW V0, 16(FP)
9D00A3C4  00021103   SRA V0, V0, 4
9D00A3C8  AFC20010   SW V0, 16(FP)
191:                 
192:                     var1 = ((((adc_T>>3) - ((int32_t)BME280_calibration.dig_T1 << 1))) * 
9D00A3CC  8FC20010   LW V0, 16(FP)
9D00A3D0  000218C3   SRA V1, V0, 3
9D00A3D4  3C02A000   LUI V0, -24576
9D00A3D8  94420CBC   LHU V0, 3260(V0)
9D00A3DC  00021040   SLL V0, V0, 1
9D00A3E0  00621823   SUBU V1, V1, V0
9D00A3F0  00620018   MULT 0, V1, V0
9D00A3F4  00001812   MFLO V1
9D00A3F8  000312C3   SRA V0, V1, 11
9D00A3FC  AFC20014   SW V0, 20(FP)
193:                             ((int32_t)BME280_calibration.dig_T2)) >> 11;
9D00A3E4  3C02A000   LUI V0, -24576
9D00A3E8  24420CBC   ADDIU V0, V0, 3260
9D00A3EC  84420002   LH V0, 2(V0)
194:                              
195:                     var2 = (((((adc_T>>4) - ((int32_t)BME280_calibration.dig_T1)) * 
9D00A400  8FC20010   LW V0, 16(FP)
9D00A404  00021903   SRA V1, V0, 4
9D00A408  3C02A000   LUI V0, -24576
9D00A40C  94420CBC   LHU V0, 3260(V0)
9D00A410  00621823   SUBU V1, V1, V0
9D00A428  00620018   MULT 0, V1, V0
9D00A444  00001812   MFLO V1
9D00A448  00031383   SRA V0, V1, 14
9D00A44C  AFC20018   SW V0, 24(FP)
196:                             ((adc_T >> 4) - ((int32_t)BME280_calibration.dig_T1))) >> 12) *
9D00A414  8FC20010   LW V0, 16(FP)
9D00A418  00022103   SRA A0, V0, 4
9D00A41C  3C02A000   LUI V0, -24576
9D00A420  94420CBC   LHU V0, 3260(V0)
9D00A424  00821023   SUBU V0, A0, V0
9D00A42C  00001012   MFLO V0
9D00A430  00021B03   SRA V1, V0, 12
9D00A440  00620018   MULT 0, V1, V0
197:                             ((int32_t)BME280_calibration.dig_T3)) >> 14;
9D00A434  3C02A000   LUI V0, -24576
9D00A438  24420CBC   ADDIU V0, V0, 3260
9D00A43C  84420004   LH V0, 4(V0)
198:                 
199:                     t_fine = var1 + var2;
9D00A450  8FC30014   LW V1, 20(FP)
9D00A454  8FC20018   LW V0, 24(FP)
9D00A458  00621021   ADDU V0, V1, V0
9D00A45C  AF828040   SW V0, -32704(GP)
200:                 
201:                     float T = (t_fine * 5 + 128) >> 8;
9D00A460  8F838040   LW V1, -32704(GP)
9D00A464  00601021   ADDU V0, V1, ZERO
9D00A468  00021080   SLL V0, V0, 2
9D00A46C  00431021   ADDU V0, V0, V1
9D00A470  24420080   ADDIU V0, V0, 128
9D00A474  00021203   SRA V0, V0, 8
9D00A478  00402021   ADDU A0, V0, ZERO
9D00A47C  0F4035B8   JAL __floatsisf
9D00A480  00000000   NOP
9D00A484  AFC2001C   SW V0, 28(FP)
202:                     return T/100;
9D00A488  3C029D01   LUI V0, -25343
9D00A48C  8FC4001C   LW A0, 28(FP)
9D00A490  8C45DA40   LW A1, -9664(V0)
9D00A494  0F40210E   JAL __divsf3
9D00A498  00000000   NOP
203:                 }
9D00A49C  03C0E821   ADDU SP, FP, ZERO
9D00A4A0  8FBF0024   LW RA, 36(SP)
9D00A4A4  8FBE0020   LW FP, 32(SP)
9D00A4A8  27BD0028   ADDIU SP, SP, 40
9D00A4AC  03E00008   JR RA
9D00A4B0  00000000   NOP
204:                 
205:                 /*******************************************************************************
206:                 * Auteur : Diego Rickenbach                                                    *                     
207:                 * Nom de la fonction :  BME280_readPressure                                    *                                    
208:                 * Entre :      rien                                                           *                                                                      
209:                 * Sortie :      float p                                                        *
210:                 * Desription :  Cette fonction permet de rcuprer les donnes et grce aux    *
211:                 *               calcules de compensations, donns dans le datasheet, d'en      *
212:                 *               sortir la pression.                                            *                                                     
213:                 * Remarques:    t_fine est une variable golbale utilise dans plusieurs        *
214:                 *               fonctions.                                                     *
215:                 *               Voir le prototype dans BME280.h.                               *
216:                 *******************************************************************************/
217:                 float BME280_readPressure(void) 
218:                 {
9D0031B0  27BDFF30   ADDIU SP, SP, -208
9D0031B4  AFBF00CC   SW RA, 204(SP)
9D0031B8  AFBE00C8   SW FP, 200(SP)
9D0031BC  AFB700C4   SW S7, 196(SP)
9D0031C0  AFB600C0   SW S6, 192(SP)
9D0031C4  AFB500BC   SW S5, 188(SP)
9D0031C8  AFB400B8   SW S4, 184(SP)
9D0031CC  AFB300B4   SW S3, 180(SP)
9D0031D0  AFB200B0   SW S2, 176(SP)
9D0031D4  AFB100AC   SW S1, 172(SP)
9D0031D8  AFB000A8   SW S0, 168(SP)
9D0031DC  03A0F021   ADDU FP, SP, ZERO
219:                     int64_t var1, var2, p;
220:                     int32_t adc_P;
221:                     
222:                     BME280_readTemperature(); // must be done first to get t_fine
9D0031E0  0F4028E0   JAL BME280_readTemperature
9D0031E4  00000000   NOP
223:                 
224:                     adc_P = I2CSensor_Read24(BME280_ADDRESS, BME280_REGISTER_PRESSUREDATA);
9D0031E8  24040077   ADDIU A0, ZERO, 119
9D0031EC  240500F7   ADDIU A1, ZERO, 247
9D0031F0  0F402CE7   JAL I2CSensor_Read24
9D0031F4  00000000   NOP
9D0031F8  AFC20010   SW V0, 16(FP)
225:                     
226:                     if (adc_P == 0x800000) // value in case pressure measurement was disabled
9D0031FC  8FC30010   LW V1, 16(FP)
9D003200  3C020080   LUI V0, 128
9D003204  14620004   BNE V1, V0, 0x9D003218
9D003208  00000000   NOP
227:                         return false;
9D00320C  00001021   ADDU V0, ZERO, ZERO
9D003210  0B400E31   J .LVL80
9D003214  00000000   NOP
228:                     
229:                     adc_P >>= 4;
9D003218  8FC20010   LW V0, 16(FP)
9D00321C  00021103   SRA V0, V0, 4
9D003220  AFC20010   SW V0, 16(FP)
230:                 
231:                     var1 = ((int64_t)t_fine) - 128000;
9D003224  8F828040   LW V0, -32704(GP)
9D003228  00408021   ADDU S0, V0, ZERO
9D00322C  000217C3   SRA V0, V0, 31
9D003230  00408821   ADDU S1, V0, ZERO
9D003234  3C02FFFE   LUI V0, -2
9D003238  34420C00   ORI V0, V0, 3072
9D00323C  2403FFFF   ADDIU V1, ZERO, -1
9D003240  02022021   ADDU A0, S0, V0
9D003244  0090302B   SLTU A2, A0, S0
9D003248  02232821   ADDU A1, S1, V1
9D00324C  00C51021   ADDU V0, A2, A1
9D003250  00402821   ADDU A1, V0, ZERO
9D003254  AFC40018   SW A0, 24(FP)
9D003258  AFC5001C   SW A1, 28(FP)
232:                     var2 = var1 * var1 * (int64_t)BME280_calibration.dig_P6;
9D00325C  8FC3001C   LW V1, 28(FP)
9D003260  8FC20018   LW V0, 24(FP)
9D003264  70622002   MUL A0, V1, V0
9D003268  8FC3001C   LW V1, 28(FP)
9D00326C  8FC20018   LW V0, 24(FP)
9D003270  00620018   MULT 0, V1, V0
9D003274  00001012   MFLO V0
9D003278  00823021   ADDU A2, A0, V0
9D00327C  8FC30018   LW V1, 24(FP)
9D003280  8FC20018   LW V0, 24(FP)
9D003284  00620019   MULTU 0, V1, V0
9D003288  00002012   MFLO A0
9D00328C  00002810   MFHI A1
9D003290  00C51021   ADDU V0, A2, A1
9D003294  00402821   ADDU A1, V0, ZERO
9D003298  3C02A000   LUI V0, -24576
9D00329C  24420CBC   ADDIU V0, V0, 3260
9D0032A0  84420010   LH V0, 16(V0)
9D0032A4  00409021   ADDU S2, V0, ZERO
9D0032A8  000217C3   SRA V0, V0, 31
9D0032AC  00409821   ADDU S3, V0, ZERO
9D0032B0  70B21002   MUL V0, A1, S2
9D0032B4  02640018   MULT 0, S3, A0
9D0032B8  00001812   MFLO V1
9D0032BC  00433021   ADDU A2, V0, V1
9D0032C0  00920019   MULTU 0, A0, S2
9D0032C4  00001012   MFLO V0
9D0032C8  00001810   MFHI V1
9D0032CC  00C32021   ADDU A0, A2, V1
9D0032D0  00801821   ADDU V1, A0, ZERO
9D0032D4  AFC20020   SW V0, 32(FP)
9D0032D8  AFC30024   SW V1, 36(FP)
9D0032DC  AFC20020   SW V0, 32(FP)
9D0032E0  AFC30024   SW V1, 36(FP)
233:                     var2 = var2 + ((var1*(int64_t)BME280_calibration.dig_P5)<<17);
9D0032E4  3C02A000   LUI V0, -24576
9D0032E8  24420CBC   ADDIU V0, V0, 3260
9D0032EC  8442000E   LH V0, 14(V0)
9D0032F0  0040A021   ADDU S4, V0, ZERO
9D0032F4  000217C3   SRA V0, V0, 31
9D0032F8  0040A821   ADDU S5, V0, ZERO
9D0032FC  8FC20018   LW V0, 24(FP)
9D003300  70551802   MUL V1, V0, S5
9D003304  8FC2001C   LW V0, 28(FP)
9D003308  00540018   MULT 0, V0, S4
9D00330C  00001012   MFLO V0
9D003310  00622021   ADDU A0, V1, V0
9D003314  8FC20018   LW V0, 24(FP)
9D003318  00540019   MULTU 0, V0, S4
9D00331C  00001012   MFLO V0
9D003320  00001810   MFHI V1
9D003324  00832021   ADDU A0, A0, V1
9D003328  00801821   ADDU V1, A0, ZERO
9D00332C  000223C2   SRL A0, V0, 15
9D003330  0003BC40   SLL S7, V1, 17
9D003334  0097B825   OR S7, A0, S7
9D003338  0002B440   SLL S6, V0, 17
9D00333C  8FC20020   LW V0, 32(FP)
9D003340  8FC30024   LW V1, 36(FP)
9D003344  00562021   ADDU A0, V0, S6
9D003348  0082302B   SLTU A2, A0, V0
9D00334C  00772821   ADDU A1, V1, S7
9D003350  00C51021   ADDU V0, A2, A1
9D003354  00402821   ADDU A1, V0, ZERO
9D003358  AFC40020   SW A0, 32(FP)
9D00335C  AFC50024   SW A1, 36(FP)
234:                     var2 = var2 + (((int64_t)BME280_calibration.dig_P4)<<35);
9D003360  3C02A000   LUI V0, -24576
9D003364  24420CBC   ADDIU V0, V0, 3260
9D003368  8442000C   LH V0, 12(V0)
9D00336C  AFC20030   SW V0, 48(FP)
9D003370  000217C3   SRA V0, V0, 31
9D003374  AFC20034   SW V0, 52(FP)
9D003378  8FC20030   LW V0, 48(FP)
9D00337C  000210C0   SLL V0, V0, 3
9D003380  AFC2003C   SW V0, 60(FP)
9D003384  AFC00038   SW ZERO, 56(FP)
9D003388  8FC20020   LW V0, 32(FP)
9D00338C  8FC30024   LW V1, 36(FP)
9D003390  8FC60038   LW A2, 56(FP)
9D003394  00462021   ADDU A0, V0, A2
9D003398  0082302B   SLTU A2, A0, V0
9D00339C  8FC7003C   LW A3, 60(FP)
9D0033A0  00672821   ADDU A1, V1, A3
9D0033A4  00C51021   ADDU V0, A2, A1
9D0033A8  00402821   ADDU A1, V0, ZERO
9D0033AC  AFC40020   SW A0, 32(FP)
9D0033B0  AFC50024   SW A1, 36(FP)
235:                     var1 = ((var1 * var1 * (int64_t)BME280_calibration.dig_P3)>>8) +
9D0033B4  8FC3001C   LW V1, 28(FP)
9D0033B8  8FC20018   LW V0, 24(FP)
9D0033BC  70622002   MUL A0, V1, V0
9D0033C0  8FC3001C   LW V1, 28(FP)
9D0033C4  8FC20018   LW V0, 24(FP)
9D0033C8  00620018   MULT 0, V1, V0
9D0033CC  00001012   MFLO V0
9D0033D0  00823021   ADDU A2, A0, V0
9D0033D4  8FC30018   LW V1, 24(FP)
9D0033D8  8FC20018   LW V0, 24(FP)
9D0033DC  00620019   MULTU 0, V1, V0
9D0033E0  00002012   MFLO A0
9D0033E4  00002810   MFHI A1
9D0033E8  00C51021   ADDU V0, A2, A1
9D0033EC  00402821   ADDU A1, V0, ZERO
9D0033F0  3C02A000   LUI V0, -24576
9D0033F4  24420CBC   ADDIU V0, V0, 3260
9D0033F8  8442000A   LH V0, 10(V0)
9D0033FC  AFC20040   SW V0, 64(FP)
9D003400  000217C3   SRA V0, V0, 31
9D003404  AFC20044   SW V0, 68(FP)
9D003408  8FC30040   LW V1, 64(FP)
9D00340C  70A31002   MUL V0, A1, V1
9D003410  8FC60044   LW A2, 68(FP)
9D003414  00C40018   MULT 0, A2, A0
9D003418  00003812   MFLO A3
9D00341C  00473021   ADDU A2, V0, A3
9D003420  8FC70040   LW A3, 64(FP)
9D003424  00870019   MULTU 0, A0, A3
9D003428  00001012   MFLO V0
9D00342C  00001810   MFHI V1
9D003430  00C32021   ADDU A0, A2, V1
9D003434  00801821   ADDU V1, A0, ZERO
9D003438  00032600   SLL A0, V1, 24
9D00343C  00022A02   SRL A1, V0, 8
9D003440  AFC50048   SW A1, 72(FP)
9D003444  8FC60048   LW A2, 72(FP)
9D003448  00862025   OR A0, A0, A2
9D00344C  AFC40048   SW A0, 72(FP)
9D003450  00033A03   SRA A3, V1, 8
9D003454  AFC7004C   SW A3, 76(FP)
9D0034CC  8FC50048   LW A1, 72(FP)
9D0034D0  8FC60058   LW A2, 88(FP)
9D0034D4  00A61021   ADDU V0, A1, A2
9D0034D8  8FC70048   LW A3, 72(FP)
9D0034DC  0047202B   SLTU A0, V0, A3
9D0034E0  8FC5004C   LW A1, 76(FP)
9D0034E4  8FC6005C   LW A2, 92(FP)
9D0034E8  00A61821   ADDU V1, A1, A2
9D0034EC  00832021   ADDU A0, A0, V1
9D0034F0  00801821   ADDU V1, A0, ZERO
9D0034F4  AFC20018   SW V0, 24(FP)
9D0034F8  AFC3001C   SW V1, 28(FP)
236:                            ((var1 * (int64_t)BME280_calibration.dig_P2)<<12);
9D003458  3C02A000   LUI V0, -24576
9D00345C  24420CBC   ADDIU V0, V0, 3260
9D003460  84420008   LH V0, 8(V0)
9D003464  AFC20050   SW V0, 80(FP)
9D003468  000217C3   SRA V0, V0, 31
9D00346C  AFC20054   SW V0, 84(FP)
9D003470  8FC20018   LW V0, 24(FP)
9D003474  8FC30054   LW V1, 84(FP)
9D003478  70431002   MUL V0, V0, V1
9D00347C  8FC3001C   LW V1, 28(FP)
9D003480  8FC40050   LW A0, 80(FP)
9D003484  00640018   MULT 0, V1, A0
9D003488  00002812   MFLO A1
9D00348C  00452021   ADDU A0, V0, A1
9D003490  8FC20018   LW V0, 24(FP)
9D003494  8FC50050   LW A1, 80(FP)
9D003498  00450019   MULTU 0, V0, A1
9D00349C  00001012   MFLO V0
9D0034A0  00001810   MFHI V1
9D0034A4  00832021   ADDU A0, A0, V1
9D0034A8  00801821   ADDU V1, A0, ZERO
9D0034AC  00022502   SRL A0, V0, 20
9D0034B0  00033300   SLL A2, V1, 12
9D0034B4  AFC6005C   SW A2, 92(FP)
9D0034B8  8FC7005C   LW A3, 92(FP)
9D0034BC  00872025   OR A0, A0, A3
9D0034C0  AFC4005C   SW A0, 92(FP)
9D0034C4  00022300   SLL A0, V0, 12
9D0034C8  AFC40058   SW A0, 88(FP)
237:                     var1 = (((((int64_t)1)<<47)+var1))*((int64_t)BME280_calibration.dig_P1)>>33;
9D0034FC  8FC40018   LW A0, 24(FP)
9D003500  8FC5001C   LW A1, 28(FP)
9D003504  00003021   ADDU A2, ZERO, ZERO
9D003508  34078000   ORI A3, ZERO, -32768
9D00350C  00861021   ADDU V0, A0, A2
9D003510  0044402B   SLTU T0, V0, A0
9D003514  00A71821   ADDU V1, A1, A3
9D003518  01032021   ADDU A0, T0, V1
9D00351C  00801821   ADDU V1, A0, ZERO
9D003520  3C04A000   LUI A0, -24576
9D003524  24840CBC   ADDIU A0, A0, 3260
9D003528  94840006   LHU A0, 6(A0)
9D00352C  AFC40060   SW A0, 96(FP)
9D003530  AFC00064   SW ZERO, 100(FP)
9D003534  8FC50060   LW A1, 96(FP)
9D003538  70652002   MUL A0, V1, A1
9D00353C  8FC60064   LW A2, 100(FP)
9D003540  00C20018   MULT 0, A2, V0
9D003544  00003812   MFLO A3
9D003548  00872021   ADDU A0, A0, A3
9D00354C  8FC50060   LW A1, 96(FP)
9D003550  00450019   MULTU 0, V0, A1
9D003554  00001012   MFLO V0
9D003558  00001810   MFHI V1
9D00355C  00832021   ADDU A0, A0, V1
9D003560  00801821   ADDU V1, A0, ZERO
9D003564  00032043   SRA A0, V1, 1
9D003568  AFC40018   SW A0, 24(FP)
9D00356C  000317C3   SRA V0, V1, 31
9D003570  AFC2001C   SW V0, 28(FP)
238:                 
239:                     if (var1 == 0) {
9D003574  8FC20018   LW V0, 24(FP)
9D003578  8FC3001C   LW V1, 28(FP)
9D00357C  00431025   OR V0, V0, V1
9D003580  14400004   BNE V0, ZERO, 0x9D003594
9D003584  00000000   NOP
240:                         return 0; // avoid exception caused by division by zero
9D003588  00001021   ADDU V0, ZERO, ZERO
9D00358C  0B400E31   J .LVL80
9D003590  00000000   NOP
241:                     }
242:                     
243:                     p = 1048576 - adc_P;
9D003594  3C030010   LUI V1, 16
9D003598  8FC20010   LW V0, 16(FP)
9D00359C  00621023   SUBU V0, V1, V0
9D0035A0  AFC20028   SW V0, 40(FP)
9D0035A4  000217C3   SRA V0, V0, 31
9D0035A8  AFC2002C   SW V0, 44(FP)
244:                     p = (((p<<31) - var2)*3125) / var1;
9D0035AC  8FC20028   LW V0, 40(FP)
9D0035B0  00021042   SRL V0, V0, 1
9D0035B4  8FC3002C   LW V1, 44(FP)
9D0035B8  00031FC0   SLL V1, V1, 31
9D0035BC  AFC3006C   SW V1, 108(FP)
9D0035C0  8FC6006C   LW A2, 108(FP)
9D0035C4  00461025   OR V0, V0, A2
9D0035C8  AFC2006C   SW V0, 108(FP)
9D0035CC  8FC20028   LW V0, 40(FP)
9D0035D0  000217C0   SLL V0, V0, 31
9D0035D4  AFC20068   SW V0, 104(FP)
9D0035D8  8FC40020   LW A0, 32(FP)
9D0035DC  8FC50024   LW A1, 36(FP)
9D0035E0  8FC70068   LW A3, 104(FP)
9D0035E4  00E41023   SUBU V0, A3, A0
9D0035E8  8FC70068   LW A3, 104(FP)
9D0035EC  00E2302B   SLTU A2, A3, V0
9D0035F0  8FC7006C   LW A3, 108(FP)
9D0035F4  00E51823   SUBU V1, A3, A1
9D0035F8  00662023   SUBU A0, V1, A2
9D0035FC  00801821   ADDU V1, A0, ZERO
9D003600  24040C35   ADDIU A0, ZERO, 3125
9D003604  70642002   MUL A0, V1, A0
9D003608  00002821   ADDU A1, ZERO, ZERO
9D00360C  00450018   MULT 0, V0, A1
9D003610  00002812   MFLO A1
9D003614  00852021   ADDU A0, A0, A1
9D003618  24050C35   ADDIU A1, ZERO, 3125
9D00361C  00450019   MULTU 0, V0, A1
9D003620  00001012   MFLO V0
9D003624  00001810   MFHI V1
9D003628  00832021   ADDU A0, A0, V1
9D00362C  00801821   ADDU V1, A0, ZERO
9D003630  00402021   ADDU A0, V0, ZERO
9D003634  00602821   ADDU A1, V1, ZERO
9D003638  8FC60018   LW A2, 24(FP)
9D00363C  8FC7001C   LW A3, 28(FP)
9D003640  0F40152E   JAL __divdi3
9D003644  00000000   NOP
9D003648  00400013   MTLO V0
9D00364C  00600011   MTHI V1
9D003650  00001012   MFLO V0
9D003654  00001810   MFHI V1
9D003658  AFC20028   SW V0, 40(FP)
9D00365C  AFC3002C   SW V1, 44(FP)
245:                     var1 = (((int64_t)BME280_calibration.dig_P9) * (p>>13) * (p>>13)) >> 25;
9D003660  3C02A000   LUI V0, -24576
9D003664  24420CBC   ADDIU V0, V0, 3260
9D003668  84420016   LH V0, 22(V0)
9D00366C  AFC20070   SW V0, 112(FP)
9D003670  000217C3   SRA V0, V0, 31
9D003674  AFC20074   SW V0, 116(FP)
9D003678  8FC2002C   LW V0, 44(FP)
9D00367C  000214C0   SLL V0, V0, 19
9D003680  8FC30028   LW V1, 40(FP)
9D003684  00031B42   SRL V1, V1, 13
9D003688  AFC30078   SW V1, 120(FP)
9D00368C  8FC30078   LW V1, 120(FP)
9D003690  00431025   OR V0, V0, V1
9D003694  AFC20078   SW V0, 120(FP)
9D003698  8FC2002C   LW V0, 44(FP)
9D00369C  00021343   SRA V0, V0, 13
9D0036A0  AFC2007C   SW V0, 124(FP)
9D0036A4  8FC30074   LW V1, 116(FP)
9D0036A8  8FC40078   LW A0, 120(FP)
9D0036AC  70641002   MUL V0, V1, A0
9D0036B0  8FC5007C   LW A1, 124(FP)
9D0036B4  8FC60070   LW A2, 112(FP)
9D0036B8  00A60018   MULT 0, A1, A2
9D0036BC  00003812   MFLO A3
9D0036C0  00472021   ADDU A0, V0, A3
9D0036C4  8FC50070   LW A1, 112(FP)
9D0036C8  8FC60078   LW A2, 120(FP)
9D0036CC  00A60019   MULTU 0, A1, A2
9D0036D0  00001012   MFLO V0
9D0036D4  00001810   MFHI V1
9D0036D8  00832021   ADDU A0, A0, V1
9D0036DC  00801821   ADDU V1, A0, ZERO
9D0036E0  8FC4002C   LW A0, 44(FP)
9D0036E4  000424C0   SLL A0, A0, 19
9D0036E8  8FC50028   LW A1, 40(FP)
9D0036EC  00052B42   SRL A1, A1, 13
9D0036F0  AFC50080   SW A1, 128(FP)
9D0036F4  8FC70080   LW A3, 128(FP)
9D0036F8  00872025   OR A0, A0, A3
9D0036FC  AFC40080   SW A0, 128(FP)
9D003700  8FC4002C   LW A0, 44(FP)
9D003704  00042343   SRA A0, A0, 13
9D003708  AFC40084   SW A0, 132(FP)
9D00370C  8FC50080   LW A1, 128(FP)
9D003710  70652002   MUL A0, V1, A1
9D003714  8FC60084   LW A2, 132(FP)
9D003718  00C20018   MULT 0, A2, V0
9D00371C  00003812   MFLO A3
9D003720  00872021   ADDU A0, A0, A3
9D003724  8FC50080   LW A1, 128(FP)
9D003728  00450019   MULTU 0, V0, A1
9D00372C  00001012   MFLO V0
9D003730  00001810   MFHI V1
9D003734  00832021   ADDU A0, A0, V1
9D003738  00801821   ADDU V1, A0, ZERO
9D00373C  000321C0   SLL A0, V1, 7
9D003740  00022E42   SRL A1, V0, 25
9D003744  00A42025   OR A0, A1, A0
9D003748  AFC40018   SW A0, 24(FP)
9D00374C  00031643   SRA V0, V1, 25
9D003750  AFC2001C   SW V0, 28(FP)
246:                     var2 = (((int64_t)BME280_calibration.dig_P8) * p) >> 19;
9D003754  3C02A000   LUI V0, -24576
9D003758  24420CBC   ADDIU V0, V0, 3260
9D00375C  84420014   LH V0, 20(V0)
9D003760  AFC20088   SW V0, 136(FP)
9D003764  000217C3   SRA V0, V0, 31
9D003768  AFC2008C   SW V0, 140(FP)
9D00376C  8FC20028   LW V0, 40(FP)
9D003770  8FC3008C   LW V1, 140(FP)
9D003774  70431002   MUL V0, V0, V1
9D003778  8FC3002C   LW V1, 44(FP)
9D00377C  8FC40088   LW A0, 136(FP)
9D003780  00640018   MULT 0, V1, A0
9D003784  00002812   MFLO A1
9D003788  00452021   ADDU A0, V0, A1
9D00378C  8FC20028   LW V0, 40(FP)
9D003790  8FC50088   LW A1, 136(FP)
9D003794  00450019   MULTU 0, V0, A1
9D003798  00001012   MFLO V0
9D00379C  00001810   MFHI V1
9D0037A0  00832021   ADDU A0, A0, V1
9D0037A4  00801821   ADDU V1, A0, ZERO
9D0037A8  00032340   SLL A0, V1, 13
9D0037AC  00022CC2   SRL A1, V0, 19
9D0037B0  00A42025   OR A0, A1, A0
9D0037B4  AFC40020   SW A0, 32(FP)
9D0037B8  000314C3   SRA V0, V1, 19
9D0037BC  AFC20024   SW V0, 36(FP)
247:                 
248:                     p = ((p + var1 + var2) >> 8) + (((int64_t)BME280_calibration.dig_P7)<<4);
9D0037C0  8FC40028   LW A0, 40(FP)
9D0037C4  8FC5002C   LW A1, 44(FP)
9D0037C8  8FC60018   LW A2, 24(FP)
9D0037CC  8FC7001C   LW A3, 28(FP)
9D0037D0  00861021   ADDU V0, A0, A2
9D0037D4  0044402B   SLTU T0, V0, A0
9D0037D8  00A71821   ADDU V1, A1, A3
9D0037DC  01032021   ADDU A0, T0, V1
9D0037E0  00801821   ADDU V1, A0, ZERO
9D0037E4  00402021   ADDU A0, V0, ZERO
9D0037E8  00602821   ADDU A1, V1, ZERO
9D0037EC  8FC60020   LW A2, 32(FP)
9D0037F0  8FC70024   LW A3, 36(FP)
9D0037F4  00861021   ADDU V0, A0, A2
9D0037F8  0044402B   SLTU T0, V0, A0
9D0037FC  00A71821   ADDU V1, A1, A3
9D003800  01032021   ADDU A0, T0, V1
9D003804  00801821   ADDU V1, A0, ZERO
9D003808  00032600   SLL A0, V1, 24
9D00380C  00023202   SRL A2, V0, 8
9D003810  AFC60090   SW A2, 144(FP)
9D003814  8FC70090   LW A3, 144(FP)
9D003818  00872025   OR A0, A0, A3
9D00381C  AFC40090   SW A0, 144(FP)
9D003820  00032203   SRA A0, V1, 8
9D003824  AFC40094   SW A0, 148(FP)
9D003828  3C02A000   LUI V0, -24576
9D00382C  24420CBC   ADDIU V0, V0, 3260
9D003830  84420012   LH V0, 18(V0)
9D003834  AFC20098   SW V0, 152(FP)
9D003838  000217C3   SRA V0, V0, 31
9D00383C  AFC2009C   SW V0, 156(FP)
9D003840  8FC50098   LW A1, 152(FP)
9D003844  00051702   SRL V0, A1, 28
9D003848  8FC6009C   LW A2, 156(FP)
9D00384C  00063100   SLL A2, A2, 4
9D003850  AFC600A4   SW A2, 164(FP)
9D003854  8FC700A4   LW A3, 164(FP)
9D003858  00471025   OR V0, V0, A3
9D00385C  AFC200A4   SW V0, 164(FP)
9D003860  8FC20098   LW V0, 152(FP)
9D003864  00021100   SLL V0, V0, 4
9D003868  AFC200A0   SW V0, 160(FP)
9D00386C  8FC40090   LW A0, 144(FP)
9D003870  8FC500A0   LW A1, 160(FP)
9D003874  00851021   ADDU V0, A0, A1
9D003878  8FC60090   LW A2, 144(FP)
9D00387C  0046202B   SLTU A0, V0, A2
9D003880  8FC70094   LW A3, 148(FP)
9D003884  8FC500A4   LW A1, 164(FP)
9D003888  00E51821   ADDU V1, A3, A1
9D00388C  00832021   ADDU A0, A0, V1
9D003890  00801821   ADDU V1, A0, ZERO
9D003894  AFC20028   SW V0, 40(FP)
9D003898  AFC3002C   SW V1, 44(FP)
249:                     return (float)p/25600;
9D00389C  8FC40028   LW A0, 40(FP)
9D0038A0  8FC5002C   LW A1, 44(FP)
9D0038A4  0F402F88   JAL __floatdisf
9D0038A8  00000000   NOP
9D0038AC  00401821   ADDU V1, V0, ZERO
9D0038B0  3C029D01   LUI V0, -25343
9D0038B4  00602021   ADDU A0, V1, ZERO
9D0038B8  8C45DA44   LW A1, -9660(V0)
9D0038BC  0F40210E   JAL __divsf3
9D0038C0  00000000   NOP
250:                 }
9D0038C4  03C0E821   ADDU SP, FP, ZERO
9D0038C8  8FBF00CC   LW RA, 204(SP)
9D0038CC  8FBE00C8   LW FP, 200(SP)
9D0038D0  8FB700C4   LW S7, 196(SP)
9D0038D4  8FB600C0   LW S6, 192(SP)
9D0038D8  8FB500BC   LW S5, 188(SP)
9D0038DC  8FB400B8   LW S4, 184(SP)
9D0038E0  8FB300B4   LW S3, 180(SP)
9D0038E4  8FB200B0   LW S2, 176(SP)
9D0038E8  8FB100AC   LW S1, 172(SP)
9D0038EC  8FB000A8   LW S0, 168(SP)
9D0038F0  27BD00D0   ADDIU SP, SP, 208
9D0038F4  03E00008   JR RA
9D0038F8  00000000   NOP
251:                 
252:                 /*******************************************************************************
253:                 * Auteur : Diego Rickenbach                                                    *                     
254:                 * Nom de la fonction :  BME280_readHumidity                                    *                                    
255:                 * Entre :      rien                                                           *                                                                      
256:                 * Sortie :      float h                                                        *
257:                 * Desription :  Cette fonction permet de rcuprer les donnes et grce aux    *
258:                 *               calcules de compensations, donns dans le datasheet, d'en      *
259:                 *               sortir l'humidit.                                             *                                                     
260:                 * Remarques:    t_fine est une variable golbale utilise dans plusieurs        *
261:                 *               fonctions.                                                     *
262:                 *               Voir le prototype dans BME280.h.                               *
263:                 *******************************************************************************/
264:                 float BME280_readHumidity(void) 
265:                 {
9D008E4C  27BDFFD8   ADDIU SP, SP, -40
9D008E50  AFBF0024   SW RA, 36(SP)
9D008E54  AFBE0020   SW FP, 32(SP)
9D008E58  03A0F021   ADDU FP, SP, ZERO
266:                     int32_t adc_H;
267:                     
268:                     BME280_readTemperature(); // must be done first to get t_fine
9D008E5C  0F4028E0   JAL BME280_readTemperature
9D008E60  00000000   NOP
269:                 	
270:                     adc_H = I2CSensor_Read16(BME280_ADDRESS, BME280_REGISTER_HUMIDDATA);
9D008E64  24040077   ADDIU A0, ZERO, 119
9D008E68  240500FD   ADDIU A1, ZERO, 253
9D008E6C  0F402EED   JAL I2CSensor_Read16
9D008E70  00000000   NOP
9D008E74  AFC20010   SW V0, 16(FP)
271:                     if (adc_H == 0x8000) // value in case humidity measurement was disabled
9D008E78  8FC30010   LW V1, 16(FP)
9D008E7C  34028000   ORI V0, ZERO, -32768
9D008E80  14620004   BNE V1, V0, 0x9D008E94
9D008E84  00000000   NOP
272:                         return false;
9D008E88  00001021   ADDU V0, ZERO, ZERO
9D008E8C  0B402404   J .LVL102
9D008E90  00000000   NOP
273:                         
274:                     int32_t v_x1_u32r;
275:                 
276:                     v_x1_u32r = (t_fine - ((int32_t)76800));
9D008E94  8F838040   LW V1, -32704(GP)
9D008E98  3C02FFFE   LUI V0, -2
9D008E9C  3442D400   ORI V0, V0, -11264
9D008EA0  00621021   ADDU V0, V1, V0
9D008EA4  AFC20014   SW V0, 20(FP)
277:                 
278:                     v_x1_u32r = (((((adc_H << 14) - (((int32_t)BME280_calibration.dig_H4) << 20) -
9D008EA8  8FC20010   LW V0, 16(FP)
9D008EAC  00021B80   SLL V1, V0, 14
9D008EB0  3C02A000   LUI V0, -24576
9D008EB4  24420CBC   ADDIU V0, V0, 3260
9D008EB8  8442001E   LH V0, 30(V0)
9D008EBC  00021500   SLL V0, V0, 20
9D008EC0  00621023   SUBU V0, V1, V0
9D008EDC  00001812   MFLO V1
9D008EE0  00431023   SUBU V0, V0, V1
9D008F64  00620018   MULT 0, V1, V0
9D008F68  00001012   MFLO V0
9D008F6C  AFC20014   SW V0, 20(FP)
279:                                 (((int32_t)BME280_calibration.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
9D008EC4  3C03A000   LUI V1, -24576
9D008EC8  24630CBC   ADDIU V1, V1, 3260
9D008ECC  84630020   LH V1, 32(V1)
9D008ED0  00602021   ADDU A0, V1, ZERO
9D008ED4  8FC30014   LW V1, 20(FP)
9D008ED8  00830018   MULT 0, A0, V1
9D008EE4  24424000   ADDIU V0, V0, 16384
9D008EE8  00021BC3   SRA V1, V0, 15
280:                                 (((((((v_x1_u32r * ((int32_t)BME280_calibration.dig_H6)) >> 10) *
9D008EEC  3C02A000   LUI V0, -24576
9D008EF0  24420CBC   ADDIU V0, V0, 3260
9D008EF4  80420022   LB V0, 34(V0)
9D008EF8  00402021   ADDU A0, V0, ZERO
9D008EFC  8FC20014   LW V0, 20(FP)
9D008F00  00820018   MULT 0, A0, V0
9D008F04  00001012   MFLO V0
9D008F08  00022283   SRA A0, V0, 10
9D008F34  00820018   MULT 0, A0, V0
281:                                 (((v_x1_u32r * ((int32_t)BME280_calibration.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
9D008F0C  3C02A000   LUI V0, -24576
9D008F10  24420CBC   ADDIU V0, V0, 3260
9D008F14  9042001C   LBU V0, 28(V0)
9D008F18  00402821   ADDU A1, V0, ZERO
9D008F1C  8FC20014   LW V0, 20(FP)
9D008F20  00A20018   MULT 0, A1, V0
9D008F24  00001012   MFLO V0
9D008F28  00022AC3   SRA A1, V0, 11
9D008F2C  34028000   ORI V0, ZERO, -32768
9D008F30  00A21021   ADDU V0, A1, V0
9D008F38  00001012   MFLO V0
9D008F3C  00022283   SRA A0, V0, 10
9D008F40  3C020020   LUI V0, 32
9D008F44  00822021   ADDU A0, A0, V0
282:                                 ((int32_t)2097152)) * ((int32_t)BME280_calibration.dig_H2) + 8192) >> 14));
9D008F48  3C02A000   LUI V0, -24576
9D008F4C  24420CBC   ADDIU V0, V0, 3260
9D008F50  8442001A   LH V0, 26(V0)
9D008F54  00820018   MULT 0, A0, V0
9D008F58  00002012   MFLO A0
9D008F5C  24822000   ADDIU V0, A0, 8192
9D008F60  00021383   SRA V0, V0, 14
283:                 
284:                     v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) *
9D008F70  8FC20014   LW V0, 20(FP)
9D008F74  00021BC3   SRA V1, V0, 15
9D008F78  8FC20014   LW V0, 20(FP)
9D008F7C  000213C3   SRA V0, V0, 15
9D008F80  00620018   MULT 0, V1, V0
9D008F84  00002012   MFLO A0
9D008F88  000419C3   SRA V1, A0, 7
9D008F98  00620018   MULT 0, V1, V0
9D008FA4  8FC30014   LW V1, 20(FP)
9D008FA8  00621023   SUBU V0, V1, V0
9D008FAC  AFC20014   SW V0, 20(FP)
285:                                                ((int32_t)BME280_calibration.dig_H1)) >> 4));
9D008F8C  3C02A000   LUI V0, -24576
9D008F90  24420CBC   ADDIU V0, V0, 3260
9D008F94  90420018   LBU V0, 24(V0)
9D008F9C  00001812   MFLO V1
9D008FA0  00031103   SRA V0, V1, 4
286:                 
287:                     v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r;
9D008FB0  8FC30014   LW V1, 20(FP)
9D008FB4  8FC20014   LW V0, 20(FP)
9D008FB8  28630000   SLTI V1, V1, 0
9D008FBC  0003100B   MOVN V0, ZERO, V1
9D008FC0  AFC20014   SW V0, 20(FP)
288:                     v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r;
9D008FC4  8FC50014   LW A1, 20(FP)
9D008FC8  8FC30014   LW V1, 20(FP)
9D008FCC  3C021900   LUI V0, 6400
9D008FD0  3C041900   LUI A0, 6400
9D008FD4  34840001   ORI A0, A0, 1
9D008FD8  00A4202A   SLT A0, A1, A0
9D008FDC  0064100B   MOVN V0, V1, A0
9D008FE0  AFC20014   SW V0, 20(FP)
289:                     
290:                     float h = (v_x1_u32r>>12);
9D008FE4  8FC20014   LW V0, 20(FP)
9D008FE8  00021303   SRA V0, V0, 12
9D008FEC  00402021   ADDU A0, V0, ZERO
9D008FF0  0F4035B8   JAL __floatsisf
9D008FF4  00000000   NOP
9D008FF8  AFC20018   SW V0, 24(FP)
291:                     return  h / 1024.0;
9D008FFC  3C029D01   LUI V0, -25343
9D009000  8FC40018   LW A0, 24(FP)
9D009004  8C45DA48   LW A1, -9656(V0)
9D009008  0F40210E   JAL __divsf3
9D00900C  00000000   NOP
292:                 }
9D009010  03C0E821   ADDU SP, FP, ZERO
9D009014  8FBF0024   LW RA, 36(SP)
9D009018  8FBE0020   LW FP, 32(SP)
9D00901C  27BD0028   ADDIU SP, SP, 40
9D009020  03E00008   JR RA
9D009024  00000000   NOP
293:                 
294:                 /*******************************************************************************
295:                 * Auteur : Diego Rickenbach                                                    *                     
296:                 * Nom de la fonction :  BME280_HumidityStatus                                  *                                    
297:                 * Entre :      float Hum                                                      *                                                                      
298:                 * Sortie :      rien                                                           *
299:                 * Desription :  Cette fonction permet de dterminer le status de l'humidit    *
300:                 *               (sec, normal, confortable et humide) en fonction du taux       *
301:                 *               d'humidit en paramtre.                                       *                                                     
302:                 * Remarques:    Voir le prototype dans BME280.h.                               *
303:                 *******************************************************************************/
304:                 void BME280_HumidityStatus(float Hum)
305:                 {
9D003ED8  27BDFFE8   ADDIU SP, SP, -24
9D003EDC  AFBF0014   SW RA, 20(SP)
9D003EE0  AFBE0010   SW FP, 16(SP)
9D003EE4  03A0F021   ADDU FP, SP, ZERO
9D003EE8  AFC40018   SW A0, 24(FP)
306:                     if(Hum <= 30)
9D003EEC  3C029D01   LUI V0, -25343
9D003EF0  8FC40018   LW A0, 24(FP)
9D003EF4  8C45DA4C   LW A1, -9652(V0)
9D003EF8  0F40328A   JAL __ltsf2
9D003EFC  00000000   NOP
9D003F00  1C400007   BGTZ V0, 0x9D003F20
9D003F04  00000000   NOP
307:                         BME280.Hum_Status = 2; //Dry
9D003F08  3C02A000   LUI V0, -24576
9D003F0C  24420270   ADDIU V0, V0, 624
9D003F10  24030002   ADDIU V1, ZERO, 2
9D003F14  A043000C   SB V1, 12(V0)
9D003F18  0B400FFA   J 0x9D003FE8
9D003F1C  00000000   NOP
308:                     else if(Hum > 30 && Hum <= 50)
9D003F20  3C029D01   LUI V0, -25343
9D003F24  8C44DA4C   LW A0, -9652(V0)
9D003F28  8FC50018   LW A1, 24(FP)
9D003F2C  0F40328A   JAL __ltsf2
9D003F30  00000000   NOP
9D003F34  0441000D   BGEZ V0, 0x9D003F6C
9D003F38  00000000   NOP
9D003F3C  3C029D01   LUI V0, -25343
9D003F40  8FC40018   LW A0, 24(FP)
9D003F44  8C45DA50   LW A1, -9648(V0)
9D003F48  0F40328A   JAL __ltsf2
9D003F4C  00000000   NOP
9D003F50  1C400006   BGTZ V0, 0x9D003F6C
9D003F54  00000000   NOP
309:                         BME280.Hum_Status = 0; //Normal
9D003F58  3C02A000   LUI V0, -24576
9D003F5C  24420270   ADDIU V0, V0, 624
9D003F60  A040000C   SB ZERO, 12(V0)
9D003F64  0B400FFA   J 0x9D003FE8
9D003F68  00000000   NOP
310:                     else if(Hum > 50 && Hum < 70)
9D003F6C  3C029D01   LUI V0, -25343
9D003F70  8C44DA50   LW A0, -9648(V0)
9D003F74  8FC50018   LW A1, 24(FP)
9D003F78  0F40328A   JAL __ltsf2
9D003F7C  00000000   NOP
9D003F80  0441000E   BGEZ V0, 0x9D003FBC
9D003F84  00000000   NOP
9D003F88  3C029D01   LUI V0, -25343
9D003F8C  8FC40018   LW A0, 24(FP)
9D003F90  8C45DA54   LW A1, -9644(V0)
9D003F94  0F40328A   JAL __ltsf2
9D003F98  00000000   NOP
9D003F9C  04410007   BGEZ V0, 0x9D003FBC
9D003FA0  00000000   NOP
311:                         BME280.Hum_Status = 1; //Confortable
9D003FA4  3C02A000   LUI V0, -24576
9D003FA8  24420270   ADDIU V0, V0, 624
9D003FAC  24030001   ADDIU V1, ZERO, 1
9D003FB0  A043000C   SB V1, 12(V0)
9D003FB4  0B400FFA   J 0x9D003FE8
9D003FB8  00000000   NOP
312:                     else if(Hum >= 70)
9D003FBC  3C029D01   LUI V0, -25343
9D003FC0  8C44DA54   LW A0, -9644(V0)
9D003FC4  8FC50018   LW A1, 24(FP)
9D003FC8  0F40328A   JAL __ltsf2
9D003FCC  00000000   NOP
9D003FD0  1C400005   BGTZ V0, 0x9D003FE8
9D003FD4  00000000   NOP
313:                         BME280.Hum_Status = 3; //Wet
9D003FD8  3C02A000   LUI V0, -24576
9D003FDC  24420270   ADDIU V0, V0, 624
9D003FE0  24030003   ADDIU V1, ZERO, 3
9D003FE4  A043000C   SB V1, 12(V0)
314:                 }
9D003FE8  03C0E821   ADDU SP, FP, ZERO
9D003FEC  8FBF0014   LW RA, 20(SP)
9D003FF0  8FBE0010   LW FP, 16(SP)
9D003FF4  27BD0018   ADDIU SP, SP, 24
9D003FF8  03E00008   JR RA
9D003FFC  00000000   NOP
315:                 
316:                 /*******************************************************************************
317:                 * Auteur : Diego Rickenbach                                                    *                     
318:                 * Nom de la fonction :  BME280_Forecast                                        *                                    
319:                 * Entre :      float Press                                                    *                                                                      
320:                 * Sortie :      rien                                                           *
321:                 * Desription :  Cette fonction permet de dterminer une prvision mtrologique*
322:                 *               (Sunny, Cloudy, Partly Cloudy, Rain, no info)en fonction de la *
323:                 *               pression en paramtre, cette prvision se fait toutes les 20min*
324:                 *               pendant 3h.                                                    *                        
325:                 * Remarques:    Voir le prototype dans BME280.h.                               *
326:                 *******************************************************************************/
327:                 void BME280_Forecast(float Press)
328:                 {
9D006658  27BDFFD8   ADDIU SP, SP, -40
9D00665C  AFBF0024   SW RA, 36(SP)
9D006660  AFBE0020   SW FP, 32(SP)
9D006664  AFB1001C   SW S1, 28(SP)
9D006668  AFB00018   SW S0, 24(SP)
9D00666C  03A0F021   ADDU FP, SP, ZERO
9D006670  AFC40028   SW A0, 40(FP)
329:                     static float Pression[10] = {0};
330:                     float PressionMoy = 0;
9D006674  00001021   ADDU V0, ZERO, ZERO
9D006678  AFC20010   SW V0, 16(FP)
331:                     uint8_t cPression;
332:                     int8_t cMoyenne;
333:                     static uint8_t OldForecast = 0;
334:                     
335:                     //dcalage des mesures prcdentes
336:                     for(cPression = 9; cPression >= 1; cPression--)
9D00667C  24020009   ADDIU V0, ZERO, 9
9D006680  A3C20014   SB V0, 20(FP)
9D006684  0B4019B3   J 0x9D0066CC
9D006688  00000000   NOP
9D0066C0  93C20014   LBU V0, 20(FP)
9D0066C4  2442FFFF   ADDIU V0, V0, -1
9D0066C8  A3C20014   SB V0, 20(FP)
9D0066CC  93C20014   LBU V0, 20(FP)
9D0066D0  1440FFEE   BNE V0, ZERO, .LVL118
9D0066D4  00000000   NOP
337:                     {
338:                         Pression[cPression] = Pression[cPression-1];
9D00668C  93C40014   LBU A0, 20(FP)
9D006690  93C20014   LBU V0, 20(FP)
9D006694  2443FFFF   ADDIU V1, V0, -1
9D006698  3C02A000   LUI V0, -24576
9D00669C  00031880   SLL V1, V1, 2
9D0066A0  24421214   ADDIU V0, V0, 4628
9D0066A4  00621021   ADDU V0, V1, V0
9D0066A8  8C430000   LW V1, 0(V0)
9D0066AC  3C02A000   LUI V0, -24576
9D0066B0  00042080   SLL A0, A0, 2
9D0066B4  24421214   ADDIU V0, V0, 4628
9D0066B8  00821021   ADDU V0, A0, V0
9D0066BC  AC430000   SW V1, 0(V0)
339:                     }
340:                     //ajout de la dernire mesure
341:                     Pression[0] = Press;
9D0066D8  3C02A000   LUI V0, -24576
9D0066DC  8FC30028   LW V1, 40(FP)
9D0066E0  AC431214   SW V1, 4628(V0)
342:                     
343:                 
344:                     //moyenne de toutes les drives entre les mesures
345:                     for(cMoyenne = 0; cMoyenne <= 8; cMoyenne++)
9D0066E4  A3C00015   SB ZERO, 21(FP)
9D0066E8  0B4019DB   J 0x9D00676C
9D0066EC  00000000   NOP
9D006760  83C20015   LB V0, 21(FP)
9D006764  24420001   ADDIU V0, V0, 1
9D006768  A3C20015   SB V0, 21(FP)
9D00676C  83C20015   LB V0, 21(FP)
9D006770  28420009   SLTI V0, V0, 9
9D006774  1440FFDE   BNE V0, ZERO, 0x9D0066F0
9D006778  00000000   NOP
346:                     {
347:                         PressionMoy += (Pression[cMoyenne]- Pression[cMoyenne+1])*3;
9D0066F0  83C30015   LB V1, 21(FP)
9D0066F4  3C02A000   LUI V0, -24576
9D0066F8  00031880   SLL V1, V1, 2
9D0066FC  24421214   ADDIU V0, V0, 4628
9D006700  00621021   ADDU V0, V1, V0
9D006704  8C430000   LW V1, 0(V0)
9D006708  83C20015   LB V0, 21(FP)
9D00670C  24440001   ADDIU A0, V0, 1
9D006710  3C02A000   LUI V0, -24576
9D006714  00042080   SLL A0, A0, 2
9D006718  24421214   ADDIU V0, V0, 4628
9D00671C  00821021   ADDU V0, A0, V0
9D006720  8C420000   LW V0, 0(V0)
9D006724  00602021   ADDU A0, V1, ZERO
9D006728  00402821   ADDU A1, V0, ZERO
9D00672C  0F401F4E   JAL fpsub
9D006730  00000000   NOP
9D006734  00401821   ADDU V1, V0, ZERO
9D006738  3C029D01   LUI V0, -25343
9D00673C  00602021   ADDU A0, V1, ZERO
9D006740  8C45DA58   LW A1, -9640(V0)
9D006744  0F40247D   JAL fpmul
9D006748  00000000   NOP
9D00674C  8FC40010   LW A0, 16(FP)
9D006750  00402821   ADDU A1, V0, ZERO
9D006754  0F401F50   JAL fpadd
9D006758  00000000   NOP
9D00675C  AFC20010   SW V0, 16(FP)
348:                     }
349:                     
350:                     PressionMoy /= 9;
9D00677C  3C029D01   LUI V0, -25343
9D006780  8FC40010   LW A0, 16(FP)
9D006784  8C45DA5C   LW A1, -9636(V0)
9D006788  0F40210E   JAL __divsf3
9D00678C  00000000   NOP
9D006790  AFC20010   SW V0, 16(FP)
351:                     
352:                     //test si la dernire case du tableau des mesures de pression est remplie
353:                     //si oui, cela veut dire que a fait au moins 3h que l'on prend des mesures
354:                     if(Pression[9] != 0)
9D006794  3C02A000   LUI V0, -24576
9D006798  24421214   ADDIU V0, V0, 4628
9D00679C  8C420024   LW V0, 36(V0)
9D0067A0  00402021   ADDU A0, V0, ZERO
9D0067A4  00002821   ADDU A1, ZERO, ZERO
9D0067A8  0F40328A   JAL __ltsf2
9D0067AC  00000000   NOP
9D0067B0  10400091   BEQ V0, ZERO, 0x9D0069F8
9D0067B4  00000000   NOP
355:                     {
356:                         //test si la moyenne calcules est plus grande ou gale que 2.5hPa
357:                         if(PressionMoy >= 2.5)
9D0067B8  3C029D01   LUI V0, -25343
9D0067BC  8C44DA60   LW A0, -9632(V0)
9D0067C0  8FC50010   LW A1, 16(FP)
9D0067C4  0F40328A   JAL __ltsf2
9D0067C8  00000000   NOP
9D0067CC  1C400007   BGTZ V0, 0x9D0067EC
9D0067D0  00000000   NOP
358:                         {
359:                             BME280.Pression_Forecast = 1;   //Prvision : beau temps (Sunny)
9D0067D4  3C02A000   LUI V0, -24576
9D0067D8  24420270   ADDIU V0, V0, 624
9D0067DC  24030001   ADDIU V1, ZERO, 1
9D0067E0  A0430014   SB V1, 20(V0)
9D0067E4  0B401A78   J 0x9D0069E0
9D0067E8  00000000   NOP
360:                         }
361:                         //test si la moyenne calcules est plus grande ou gale que 0.5hPa
362:                         else if (PressionMoy >= 0.5)
9D0067EC  3C029D01   LUI V0, -25343
9D0067F0  8C44DA64   LW A0, -9628(V0)
9D0067F4  8FC50010   LW A1, 16(FP)
9D0067F8  0F40328A   JAL __ltsf2
9D0067FC  00000000   NOP
9D006800  1C400007   BGTZ V0, 0x9D006820
9D006804  00000000   NOP
363:                         {
364:                             BME280.Pression_Forecast = 1;   //Prvision : beau temps (Sunny)
9D006808  3C02A000   LUI V0, -24576
9D00680C  24420270   ADDIU V0, V0, 624
9D006810  24030001   ADDIU V1, ZERO, 1
9D006814  A0430014   SB V1, 20(V0)
9D006818  0B401A78   J 0x9D0069E0
9D00681C  00000000   NOP
365:                         }
366:                         //test si la moyenne calcules est plus petite ou gale que 0.5hPa et
367:                         //plus grande ou gale  -0.5hPa (Stable)
368:                         else if ( PressionMoy >= -0.5 && PressionMoy <= 0.5)
9D006820  3C029D01   LUI V0, -25343
9D006824  8C44DA68   LW A0, -9624(V0)
9D006828  8FC50010   LW A1, 16(FP)
9D00682C  0F40328A   JAL __ltsf2
9D006830  00000000   NOP
9D006834  1C400045   BGTZ V0, 0x9D00694C
9D006838  00000000   NOP
9D00683C  3C029D01   LUI V0, -25343
9D006840  8FC40010   LW A0, 16(FP)
9D006844  8C45DA64   LW A1, -9628(V0)
9D006848  0F40328A   JAL __ltsf2
9D00684C  00000000   NOP
9D006850  1C40003E   BGTZ V0, 0x9D00694C
9D006854  00000000   NOP
369:                         {
370:                             //test si la dernire prvision est gale  0, ce qui signifie no 
371:                             //info et on dtermine en fonction de la dernire mesure de la 
372:                             //pression
373:                             if(OldForecast == 0)
9D006858  93828016   LBU V0, -32746(GP)
9D00685C  14400035   BNE V0, ZERO, 0x9D006934
9D006860  00000000   NOP
9D006914  0B401A78   J 0x9D0069E0
9D006918  00000000   NOP
9D00692C  0B401A78   J 0x9D0069E0
9D006930  00000000   NOP
9D006944  0B401A78   J 0x9D0069E0
9D006948  00000000   NOP
374:                             {
375:                                 //test si la dernire mesure de la pression est plus grande que 
376:                                 //La pression normalise en fonction de l'altitude
377:                                 if(BME280.Pression >= (1013.25*exp(-(BME280.Altitude/8400))))
9D006864  3C02A000   LUI V0, -24576
9D006868  24420270   ADDIU V0, V0, 624
9D00686C  8C420010   LW V0, 16(V0)
9D006870  00402021   ADDU A0, V0, ZERO
9D006874  0F403166   JAL __extendsfdf2
9D006878  00000000   NOP
9D00687C  00408021   ADDU S0, V0, ZERO
9D006880  00608821   ADDU S1, V1, ZERO
9D006884  3C02A000   LUI V0, -24576
9D006888  24420270   ADDIU V0, V0, 624
9D00688C  94430016   LHU V1, 22(V0)
9D006890  3C02F9A9   LUI V0, -1623
9D006894  3442342D   ORI V0, V0, 13357
9D006898  00620019   MULTU 0, V1, V0
9D00689C  00001010   MFHI V0
9D0068A0  00021342   SRL V0, V0, 13
9D0068A4  3042FFFF   ANDI V0, V0, -1
9D0068A8  00021023   SUBU V0, ZERO, V0
9D0068AC  00402021   ADDU A0, V0, ZERO
9D0068B0  0F403468   JAL litodp
9D0068B4  00000000   NOP
9D0068B8  00402021   ADDU A0, V0, ZERO
9D0068BC  00602821   ADDU A1, V1, ZERO
9D0068C0  0F40353E   JAL expl
9D0068C4  00000000   NOP
9D0068C8  3C069D01   LUI A2, -25343
9D0068CC  00402021   ADDU A0, V0, ZERO
9D0068D0  00602821   ADDU A1, V1, ZERO
9D0068D4  8CC7DA74   LW A3, -9612(A2)
9D0068D8  8CC6DA70   LW A2, -9616(A2)
9D0068DC  0F401DD4   JAL dpmul
9D0068E0  00000000   NOP
9D0068E4  00402021   ADDU A0, V0, ZERO
9D0068E8  00602821   ADDU A1, V1, ZERO
9D0068EC  02003021   ADDU A2, S0, ZERO
9D0068F0  02203821   ADDU A3, S1, ZERO
9D0068F4  0F4029C3   JAL __gtdf2
9D0068F8  00000000   NOP
9D0068FC  1C400007   BGTZ V0, 0x9D00691C
9D006900  00000000   NOP
378:                                 {
379:                                     BME280.Pression_Forecast = 1;   //Prvision : beau temps (Sunny)
9D006904  3C02A000   LUI V0, -24576
9D006908  24420270   ADDIU V0, V0, 624
9D00690C  24030001   ADDIU V1, ZERO, 1
9D006910  A0430014   SB V1, 20(V0)
380:                                 }
381:                                 else
382:                                 {
383:                                     BME280.Pression_Forecast = 2;   //Prvision : nuageux (Cloudy)
9D00691C  3C02A000   LUI V0, -24576
9D006920  24420270   ADDIU V0, V0, 624
9D006924  24030002   ADDIU V1, ZERO, 2
9D006928  A0430014   SB V1, 20(V0)
384:                                 }
385:                             }
386:                             //Sinon on continue sur la dernire prvision
387:                             else
388:                             {
389:                                 BME280.Pression_Forecast = OldForecast;
9D006934  93838016   LBU V1, -32746(GP)
9D006938  3C02A000   LUI V0, -24576
9D00693C  24420270   ADDIU V0, V0, 624
9D006940  A0430014   SB V1, 20(V0)
390:                             }
391:                         }
392:                         //test si la moyenne calcules est plus petite que -0.5hPa
393:                         else if (PressionMoy < -0.5)
9D00694C  3C029D01   LUI V0, -25343
9D006950  8FC40010   LW A0, 16(FP)
9D006954  8C45DA68   LW A1, -9624(V0)
9D006958  0F40328A   JAL __ltsf2
9D00695C  00000000   NOP
9D006960  04410007   BGEZ V0, 0x9D006980
9D006964  00000000   NOP
394:                         {
395:                             BME280.Pression_Forecast = 2;   //Prvision : nuageux (Cloudy)
9D006968  3C02A000   LUI V0, -24576
9D00696C  24420270   ADDIU V0, V0, 624
9D006970  24030002   ADDIU V1, ZERO, 2
9D006974  A0430014   SB V1, 20(V0)
9D006978  0B401A78   J 0x9D0069E0
9D00697C  00000000   NOP
396:                         }
397:                         //test si la moyenne calcules est plus petite ou gale que -1.5hPa
398:                         else if(PressionMoy <= -1.5)
9D006980  3C029D01   LUI V0, -25343
9D006984  8FC40010   LW A0, 16(FP)
9D006988  8C45DA78   LW A1, -9608(V0)
9D00698C  0F40328A   JAL __ltsf2
9D006990  00000000   NOP
9D006994  1C400007   BGTZ V0, 0x9D0069B4
9D006998  00000000   NOP
399:                         {
400:                             BME280.Pression_Forecast = 3;   //Prvision : plutot nuageux (Pratly Cloudy)
9D00699C  3C02A000   LUI V0, -24576
9D0069A0  24420270   ADDIU V0, V0, 624
9D0069A4  24030003   ADDIU V1, ZERO, 3
9D0069A8  A0430014   SB V1, 20(V0)
9D0069AC  0B401A78   J 0x9D0069E0
9D0069B0  00000000   NOP
401:                         }
402:                         //test si la moyenne calcules est plus grande ou gale que -2.5hPa
403:                         else if(PressionMoy <= -2.5)
9D0069B4  3C029D01   LUI V0, -25343
9D0069B8  8FC40010   LW A0, 16(FP)
9D0069BC  8C45DA7C   LW A1, -9604(V0)
9D0069C0  0F40328A   JAL __ltsf2
9D0069C4  00000000   NOP
9D0069C8  1C400005   BGTZ V0, 0x9D0069E0
9D0069CC  00000000   NOP
404:                         {
405:                             BME280.Pression_Forecast = 4;   //Prvision : pluie (rain)
9D0069D0  3C02A000   LUI V0, -24576
9D0069D4  24420270   ADDIU V0, V0, 624
9D0069D8  24030004   ADDIU V1, ZERO, 4
9D0069DC  A0430014   SB V1, 20(V0)
406:                         }
407:                         
408:                         OldForecast = BME280.Pression_Forecast;
9D0069E0  3C02A000   LUI V0, -24576
9D0069E4  24420270   ADDIU V0, V0, 624
9D0069E8  90420014   LBU V0, 20(V0)
9D0069EC  A3828016   SB V0, -32746(GP)
9D0069F0  0B401A81   J 0x9D006A04
9D0069F4  00000000   NOP
409:                     }
410:                     //sinon pas assez d'info pour donner une prvision mto
411:                     else
412:                     {
413:                         BME280.Pression_Forecast = 0; //No Info
9D0069F8  3C02A000   LUI V0, -24576
9D0069FC  24420270   ADDIU V0, V0, 624
9D006A00  A0400014   SB ZERO, 20(V0)
414:                     }
415:                 }
9D006A04  03C0E821   ADDU SP, FP, ZERO
9D006A08  8FBF0024   LW RA, 36(SP)
9D006A0C  8FBE0020   LW FP, 32(SP)
9D006A10  8FB1001C   LW S1, 28(SP)
9D006A14  8FB00018   LW S0, 24(SP)
9D006A18  27BD0028   ADDIU SP, SP, 40
9D006A1C  03E00008   JR RA
9D006A20  00000000   NOP
416:                 
417:                 
418:                 
419:                 
420:                 
421:                 
422:                  
423:                 
424:                 
425:                 
---  c:/microchip/harmony/v2_06/apps/proj/2002_capteurmeteowifi/firmware/src/app.c  ---------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app.h"
57:                  #include "BME280.h"
58:                  #include "ESP8266.h"
59:                  #include "Mc32gestI2cSensor.h"
60:                  #include "Mc32gest_RS232.h"
61:                  #include "MenuGen.h"
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: Global Data Definitions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  /* Application Data
71:                  
72:                    Summary:
73:                      Holds application data
74:                  
75:                    Description:
76:                      This structure holds the application's data.
77:                  
78:                    Remarks:
79:                      This structure should be initialized by the APP_Initialize function.
80:                      
81:                      Application strings and buffers are be defined outside this structure.
82:                  */
83:                  
84:                  APP_DATA appData;
85:                  
86:                  // *****************************************************************************
87:                  // *****************************************************************************
88:                  // Section: Application Callback Functions
89:                  // *****************************************************************************
90:                  // *****************************************************************************
91:                  
92:                  /* TODO:  Add any necessary callback functions.
93:                  */
94:                  
95:                  // *****************************************************************************
96:                  // *****************************************************************************
97:                  // Section: Application Local Functions
98:                  // *****************************************************************************
99:                  // *****************************************************************************
100:                 
101:                 
102:                 /* TODO:  Add any necessary local functions.
103:                 */
104:                 
105:                 
106:                 // *****************************************************************************
107:                 // *****************************************************************************
108:                 // Section: Application Initialization and State Machine Functions
109:                 // *****************************************************************************
110:                 // *****************************************************************************
111:                 
112:                 /*******************************************************************************
113:                   Function:
114:                     void APP_Initialize ( void )
115:                 
116:                   Remarks:
117:                     See prototype in app.h.
118:                  */
119:                 
120:                 void APP_Initialize ( void )
121:                 {
9D00DF58  27BDFFF8   ADDIU SP, SP, -8
9D00DF5C  AFBE0004   SW FP, 4(SP)
9D00DF60  03A0F021   ADDU FP, SP, ZERO
122:                     /* Place the App state machine in its initial state. */
123:                     appData.state = APP_STATE_INIT;
9D00DF64  AF808030   SW ZERO, -32720(GP)
124:                 
125:                     
126:                     /* TODO: Initialize your application's state machine and other
127:                      * parameters.
128:                      */
129:                 }
9D00DF68  03C0E821   ADDU SP, FP, ZERO
9D00DF6C  8FBE0004   LW FP, 4(SP)
9D00DF70  27BD0008   ADDIU SP, SP, 8
9D00DF74  03E00008   JR RA
9D00DF78  00000000   NOP
130:                 
131:                 
132:                 /******************************************************************************
133:                   Function:
134:                     void APP_Tasks ( void )
135:                 
136:                   Remarks:
137:                     See prototype in app.h.
138:                  */
139:                 
140:                 void APP_Tasks ( void )
141:                 {
9D007FB0  27BDFFE0   ADDIU SP, SP, -32
9D007FB4  AFBF001C   SW RA, 28(SP)
9D007FB8  AFBE0018   SW FP, 24(SP)
9D007FBC  03A0F021   ADDU FP, SP, ZERO
142:                     /* Check the application's current state. */
143:                     switch ( appData.state )
9D007FC0  8F828030   LW V0, -32720(GP)
9D007FC4  2C430005   SLTIU V1, V0, 5
9D007FC8  10600085   BEQ V1, ZERO, 0x9D0081E0
9D007FCC  00000000   NOP
9D007FD0  00021880   SLL V1, V0, 2
9D007FD4  3C029D00   LUI V0, -25344
9D007FD8  24427FEC   ADDIU V0, V0, 32748
9D007FDC  00621021   ADDU V0, V1, V0
9D007FE0  8C420000   LW V0, 0(V0)
9D007FE4  00400008   JR V0
9D007FE8  00000000   NOP
144:                     {
145:                         /* Application's initial state. */
146:                         case APP_STATE_INIT:
147:                         {
148:                             LED_G_On();
9D008000  00002021   ADDU A0, ZERO, ZERO
9D008004  24050001   ADDIU A1, ZERO, 1
9D008008  2406000D   ADDIU A2, ZERO, 13
9D00800C  0F4037AE   JAL PLIB_PORTS_PinSet
9D008010  00000000   NOP
149:                             
150:                             //Init de l'tat du menu au dmarrage
151:                             MenuStatus = Enter_Menu_Set;
9D008014  AF808034   SW ZERO, -32716(GP)
152:                             
153:                             //Initialisation des fifo SW
154:                             FifoComm_Init();
9D008018  0F403191   JAL FifoComm_Init
9D00801C  00000000   NOP
155:                             
156:                             //Initialisation des Modules
157:                             BME280_Init();
9D008020  0F402675   JAL BME280_Init
9D008024  00000000   NOP
158:                             ESP8266_Init();
9D008028  0F401A89   JAL ESP8266_Init
9D00802C  00000000   NOP
159:                             
160:                             //Initialisation des Timers
161:                             DRV_TMR1_Start();
9D008030  0F4036A0   JAL DRV_TMR1_Start
9D008034  00000000   NOP
162:                             
163:                             LED_G_Off();
9D008038  00002021   ADDU A0, ZERO, ZERO
9D00803C  24050001   ADDIU A1, ZERO, 1
9D008040  2406000D   ADDIU A2, ZERO, 13
9D008044  0F4037B8   JAL PLIB_PORTS_PinClear
9D008048  00000000   NOP
164:                             APP_UpdateState(APP_STATE_WAIT);
9D00804C  24040001   ADDIU A0, ZERO, 1
9D008050  0F403724   JAL APP_UpdateState
9D008054  00000000   NOP
165:                             break;
9D008058  0B40207C   J 0x9D0081F0
9D00805C  00000000   NOP
166:                         }
167:                         
168:                         case APP_STATE_WAIT:
169:                         {
170:                             //do nothing            
171:                             break;
9D0081EC  00000000   NOP
172:                         }
173:                         
174:                         case APP_STATE_DO_MEASURE:
175:                         {
176:                             static uint16_t countForecast = 0;
177:                             
178:                             //Lecture des donnes du BME280
179:                             BME280.Temperature = BME280_readTemperature();
9D008060  0F4028E0   JAL BME280_readTemperature
9D008064  00000000   NOP
9D008068  00401821   ADDU V1, V0, ZERO
9D00806C  3C02A000   LUI V0, -24576
9D008070  24420270   ADDIU V0, V0, 624
9D008074  AC430004   SW V1, 4(V0)
180:                             BME280.Humidite = BME280_readHumidity();
9D008078  0F402393   JAL BME280_readHumidity
9D00807C  00000000   NOP
9D008080  00401821   ADDU V1, V0, ZERO
9D008084  3C02A000   LUI V0, -24576
9D008088  24420270   ADDIU V0, V0, 624
9D00808C  AC430008   SW V1, 8(V0)
181:                             BME280.Pression = BME280_readPressure();
9D008090  0F400C6C   JAL BME280_readPressure
9D008094  00000000   NOP
9D008098  00401821   ADDU V1, V0, ZERO
9D00809C  3C02A000   LUI V0, -24576
9D0080A0  24420270   ADDIU V0, V0, 624
9D0080A4  AC430010   SW V1, 16(V0)
182:                             
183:                             BME280_HumidityStatus(BME280.Humidite); 
9D0080A8  3C02A000   LUI V0, -24576
9D0080AC  24420270   ADDIU V0, V0, 624
9D0080B0  8C420008   LW V0, 8(V0)
9D0080B4  00402021   ADDU A0, V0, ZERO
9D0080B8  0F400FB6   JAL BME280_HumidityStatus
9D0080BC  00000000   NOP
184:                             
185:                             //test si a fait 20 minutes
186:                             if(countForecast >= (20/((ESP8266.Interval/20)/60))-1)
9D0080C0  97828014   LHU V0, -32748(GP)
9D0080C4  00401821   ADDU V1, V0, ZERO
9D0080C8  3C02A000   LUI V0, -24576
9D0080CC  24420244   ADDIU V0, V0, 580
9D0080D0  8C440020   LW A0, 32(V0)
9D0080D4  3C021B4E   LUI V0, 6990
9D0080D8  344281B5   ORI V0, V0, -32331
9D0080DC  00820019   MULTU 0, A0, V0
9D0080E0  00001010   MFHI V0
9D0080E4  000211C2   SRL V0, V0, 7
9D0080E8  24040014   ADDIU A0, ZERO, 20
9D0080EC  0082001B   DIVU A0, V0
9D0080F0  004001F4   TEQ V0, ZERO
9D0080F4  00001010   MFHI V0
9D0080F8  00001012   MFLO V0
9D0080FC  2442FFFF   ADDIU V0, V0, -1
9D008100  0062102B   SLTU V0, V1, V0
9D008104  1440000A   BNE V0, ZERO, 0x9D008130
9D008108  00000000   NOP
187:                             {       
188:                                 countForecast = 0;
9D00810C  A7808014   SH ZERO, -32748(GP)
189:                                 BME280_Forecast(BME280.Pression);
9D008110  3C02A000   LUI V0, -24576
9D008114  24420270   ADDIU V0, V0, 624
9D008118  8C420010   LW V0, 16(V0)
9D00811C  00402021   ADDU A0, V0, ZERO
9D008120  0F401996   JAL BME280_Forecast
9D008124  00000000   NOP
9D008128  0B402050   J 0x9D008140
9D00812C  00000000   NOP
190:                             }
191:                             else
192:                             {
193:                                 countForecast++;
9D008130  97828014   LHU V0, -32748(GP)
9D008134  24420001   ADDIU V0, V0, 1
9D008138  3042FFFF   ANDI V0, V0, -1
9D00813C  A7828014   SH V0, -32748(GP)
194:                             }
195:                             
196:                             APP_UpdateState(APP_STATE_TRANSMIT_DATA);           
9D008140  24040003   ADDIU A0, ZERO, 3
9D008144  0F403724   JAL APP_UpdateState
9D008148  00000000   NOP
197:                             break;
9D00814C  0B40207C   J 0x9D0081F0
9D008150  00000000   NOP
198:                         }
199:                         
200:                         case APP_STATE_TRANSMIT_DATA:
201:                         {
202:                             //Envoie des donnes  Domoticz
203:                             SendDomoticz(BME280.Index, BME280.Temperature, BME280.Humidite, BME280.Hum_Status, BME280.Pression, BME280.Pression_Forecast);
9D008154  3C02A000   LUI V0, -24576
9D008158  90440270   LBU A0, 624(V0)
9D00815C  3C02A000   LUI V0, -24576
9D008160  24420270   ADDIU V0, V0, 624
9D008164  8C450004   LW A1, 4(V0)
9D008168  3C02A000   LUI V0, -24576
9D00816C  24420270   ADDIU V0, V0, 624
9D008170  8C430008   LW V1, 8(V0)
9D008174  3C02A000   LUI V0, -24576
9D008178  24420270   ADDIU V0, V0, 624
9D00817C  9042000C   LBU V0, 12(V0)
9D008180  3C06A000   LUI A2, -24576
9D008184  24C60270   ADDIU A2, A2, 624
9D008188  8CC70010   LW A3, 16(A2)
9D00818C  3C06A000   LUI A2, -24576
9D008190  24C60270   ADDIU A2, A2, 624
9D008194  90C60014   LBU A2, 20(A2)
9D008198  AFA70010   SW A3, 16(SP)
9D00819C  AFA60014   SW A2, 20(SP)
9D0081A0  00603021   ADDU A2, V1, ZERO
9D0081A4  00403821   ADDU A3, V0, ZERO
9D0081A8  0F40240A   JAL SendDomoticz
9D0081AC  00000000   NOP
204:                             
205:                             APP_UpdateState(APP_STATE_WAIT);
9D0081B0  24040001   ADDIU A0, ZERO, 1
9D0081B4  0F403724   JAL APP_UpdateState
9D0081B8  00000000   NOP
206:                             break;
9D0081BC  0B40207C   J 0x9D0081F0
9D0081C0  00000000   NOP
207:                         }
208:                         
209:                         case APP_STATE_MENU:
210:                         {
211:                             //gestion du menu
212:                             GestMenu();
9D0081C4  0F400000   JAL GestMenu
9D0081C8  00000000   NOP
213:                             APP_UpdateState(APP_STATE_WAIT);
9D0081CC  24040001   ADDIU A0, ZERO, 1
9D0081D0  0F403724   JAL APP_UpdateState
9D0081D4  00000000   NOP
214:                             break;
9D0081D8  0B40207C   J 0x9D0081F0
9D0081DC  00000000   NOP
215:                         }
216:                 
217:                         default:
218:                         {
219:                             /* TODO: Handle error in application's state machine. */
220:                             break;
9D0081E0  00000000   NOP
9D0081E4  0B40207C   J 0x9D0081F0
9D0081E8  00000000   NOP
221:                         }
222:                     }
223:                 }
9D0081F0  03C0E821   ADDU SP, FP, ZERO
9D0081F4  8FBF001C   LW RA, 28(SP)
9D0081F8  8FBE0018   LW FP, 24(SP)
9D0081FC  27BD0020   ADDIU SP, SP, 32
9D008200  03E00008   JR RA
9D008204  00000000   NOP
224:                 // fonction pour changer d'tat 
225:                 void APP_UpdateState(APP_STATES NewState)
226:                 {
9D00DC90  27BDFFF8   ADDIU SP, SP, -8
9D00DC94  AFBE0004   SW FP, 4(SP)
9D00DC98  03A0F021   ADDU FP, SP, ZERO
9D00DC9C  AFC40008   SW A0, 8(FP)
227:                     appData.state = NewState;
9D00DCA0  8FC20008   LW V0, 8(FP)
9D00DCA4  AF828030   SW V0, -32720(GP)
228:                 }
9D00DCA8  03C0E821   ADDU SP, FP, ZERO
9D00DCAC  8FBE0004   LW FP, 4(SP)
9D00DCB0  27BD0008   ADDIU SP, SP, 8
9D00DCB4  03E00008   JR RA
9D00DCB8  00000000   NOP
229:                 
230:                 // Fonction permettant de venir tester la prsence des modules et d'allumer les
231:                 //   LED en concquence
232:                 void LED_Signal(void)
233:                 {
9D009550  27BDFFE8   ADDIU SP, SP, -24
9D009554  AFBF0014   SW RA, 20(SP)
9D009558  AFBE0010   SW FP, 16(SP)
9D00955C  03A0F021   ADDU FP, SP, ZERO
234:                     // test la prsence du BME280
235:                     if(I2CSensor_Read8(BME280_ADDRESS, BME280_REGISTER_CHIPID) != 0x60)
9D009560  24040077   ADDIU A0, ZERO, 119
9D009564  240500D0   ADDIU A1, ZERO, 208
9D009568  0F4031BB   JAL I2CSensor_Read8
9D00956C  00000000   NOP
9D009570  00401821   ADDU V1, V0, ZERO
9D009574  24020060   ADDIU V0, ZERO, 96
9D009578  10620004   BEQ V1, V0, 0x9D00958C
9D00957C  00000000   NOP
236:                         BME280.Status = 0;
9D009580  3C02A000   LUI V0, -24576
9D009584  24420270   ADDIU V0, V0, 624
9D009588  A040001C   SB ZERO, 28(V0)
237:                     
238:                     // test la prsence du module Wifi
239:                     if(ESP8266_isStarted() != OK)
9D00958C  0F4032D8   JAL ESP8266_isStarted
9D009590  00000000   NOP
9D009594  10400004   BEQ V0, ZERO, 0x9D0095A8
9D009598  00000000   NOP
240:                         ESP8266.Status = 0;
9D00959C  3C02A000   LUI V0, -24576
9D0095A0  24420244   ADDIU V0, V0, 580
9D0095A4  A0400024   SB ZERO, 36(V0)
241:                 
242:                     // si les deux modules sont prsents
243:                     if(BME280.Status && ESP8266.Status)
9D0095A8  3C02A000   LUI V0, -24576
9D0095AC  24420270   ADDIU V0, V0, 624
9D0095B0  9042001C   LBU V0, 28(V0)
9D0095B4  1040000D   BEQ V0, ZERO, 0x9D0095EC
9D0095B8  00000000   NOP
9D0095BC  3C02A000   LUI V0, -24576
9D0095C0  24420244   ADDIU V0, V0, 580
9D0095C4  90420024   LBU V0, 36(V0)
9D0095C8  10400008   BEQ V0, ZERO, 0x9D0095EC
9D0095CC  00000000   NOP
244:                     {
245:                         LED_G_Toggle();
9D0095D0  00002021   ADDU A0, ZERO, ZERO
9D0095D4  24050001   ADDIU A1, ZERO, 1
9D0095D8  2406000D   ADDIU A2, ZERO, 13
9D0095DC  0F4037C2   JAL PLIB_PORTS_PinToggle
9D0095E0  00000000   NOP
9D0095E4  0B4025B0   J .LVL25
9D0095E8  00000000   NOP
246:                     }
247:                     // si le BME280 est prsent mais pas le module Wifi
248:                     else if(BME280.Status == 1 && ESP8266.Status == 0)
9D0095EC  3C02A000   LUI V0, -24576
9D0095F0  24420270   ADDIU V0, V0, 624
9D0095F4  9042001C   LBU V0, 28(V0)
9D0095F8  10400014   BEQ V0, ZERO, 0x9D00964C
9D0095FC  00000000   NOP
9D009600  3C02A000   LUI V0, -24576
9D009604  24420244   ADDIU V0, V0, 580
9D009608  90420024   LBU V0, 36(V0)
9D00960C  38420001   XORI V0, V0, 1
9D009610  304200FF   ANDI V0, V0, 255
9D009614  1040000D   BEQ V0, ZERO, 0x9D00964C
9D009618  00000000   NOP
249:                     {
250:                         LED_B_Toggle();
9D00961C  00002021   ADDU A0, ZERO, ZERO
9D009620  24050001   ADDIU A1, ZERO, 1
9D009624  2406000E   ADDIU A2, ZERO, 14
9D009628  0F4037C2   JAL PLIB_PORTS_PinToggle
9D00962C  00000000   NOP
251:                         LED_R_Toggle();
9D009630  00002021   ADDU A0, ZERO, ZERO
9D009634  24050001   ADDIU A1, ZERO, 1
9D009638  2406000C   ADDIU A2, ZERO, 12
9D00963C  0F4037C2   JAL PLIB_PORTS_PinToggle
9D009640  00000000   NOP
9D009644  0B4025B0   J .LVL25
9D009648  00000000   NOP
252:                     }
253:                     // si le module Wifi est prsent mais pas le BME280
254:                     else if(BME280.Status == 0 && ESP8266.Status == 1)
9D00964C  3C02A000   LUI V0, -24576
9D009650  24420270   ADDIU V0, V0, 624
9D009654  9042001C   LBU V0, 28(V0)
9D009658  38420001   XORI V0, V0, 1
9D00965C  304200FF   ANDI V0, V0, 255
9D009660  10400012   BEQ V0, ZERO, 0x9D0096AC
9D009664  00000000   NOP
9D009668  3C02A000   LUI V0, -24576
9D00966C  24420244   ADDIU V0, V0, 580
9D009670  90420024   LBU V0, 36(V0)
9D009674  1040000D   BEQ V0, ZERO, 0x9D0096AC
9D009678  00000000   NOP
255:                     {
256:                         LED_G_Toggle();
9D00967C  00002021   ADDU A0, ZERO, ZERO
9D009680  24050001   ADDIU A1, ZERO, 1
9D009684  2406000D   ADDIU A2, ZERO, 13
9D009688  0F4037C2   JAL PLIB_PORTS_PinToggle
9D00968C  00000000   NOP
257:                         LED_R_Toggle();
9D009690  00002021   ADDU A0, ZERO, ZERO
9D009694  24050001   ADDIU A1, ZERO, 1
9D009698  2406000C   ADDIU A2, ZERO, 12
9D00969C  0F4037C2   JAL PLIB_PORTS_PinToggle
9D0096A0  00000000   NOP
9D0096A4  0B4025B0   J .LVL25
9D0096A8  00000000   NOP
258:                     }
259:                     //si aucun des modules n'est prsent
260:                     else
261:                     {
262:                         LED_R_On();
9D0096AC  00002021   ADDU A0, ZERO, ZERO
9D0096B0  24050001   ADDIU A1, ZERO, 1
9D0096B4  2406000C   ADDIU A2, ZERO, 12
9D0096B8  0F4037AE   JAL PLIB_PORTS_PinSet
9D0096BC  00000000   NOP
263:                     } 
264:                 }
9D0096C0  03C0E821   ADDU SP, FP, ZERO
9D0096C4  8FBF0014   LW RA, 20(SP)
9D0096C8  8FBE0010   LW FP, 16(SP)
9D0096CC  27BD0018   ADDIU SP, SP, 24
9D0096D0  03E00008   JR RA
9D0096D4  00000000   NOP
265:                 /*******************************************************************************
266:                  End of File
267:                  */
---  C:/Program Files/Microchip/MPLABX/v5.45/packs/Microchip/PIC32MX_DFP/1.3.231/xc32/startup/crt0.S  ---
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crt0.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * Copyright (c) 2014, Microchip Technology Inc. and its subsidiaries ("Microchip")
                                                  17:     * All rights reserved.
                                                  18:     *
                                                  19:     * This software is developed by Microchip Technology Inc. and its
                                                  20:     * subsidiaries ("Microchip").
                                                  21:     *
                                                  22:     * Redistribution and use in source and binary forms, with or without
                                                  23:     * modification, are permitted provided that the following conditions are met:
                                                  24:     *
                                                  25:     * 1.      Redistributions of source code must retain the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer.
                                                  27:     *
                                                  28:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  29:     * notice, this list of conditions and the following disclaimer in the
                                                  30:     * documentation and/or other materials provided with the distribution.
                                                  31:     *
                                                  32:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  33:     * derived from this software without specific prior written permission.
                                                  34:     *
                                                  35:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  36:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  37:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  38:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  39:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  40:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  41:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  42:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  43:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  44:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  45:     *
                                                  46:     ********************************************************************/
                                                  47:    
                                                  48:    #include "xc.h"
                                                  49:    #include <cp0defs.h>
                                                  50:    
                                                  51:    #ifdef __LIBBUILD__
                                                  52:       # Replace the standard debugging information with a simple filename. This
                                                  53:       # prevents the library build directory from showing up in MPLAB IDE. It
                                                  54:       # also effectively disables source-line debugging.
                                                  55:       .file 1 "libpic32/startup/crt0.S"
                                                  56:       .loc 1 0
                                                  57:    #endif
                                                  58:    
                                                  59:    #if (__XC32_VERSION > 1000) && !defined(CPP_INIT)
                                                  60:    #define CPP_INIT
                                                  61:    #endif
                                                  62:    
                                                  63:    #if !defined(PIC32_SRS_SET_COUNT)
                                                  64:    #  if defined(__PIC32_SRS_SET_COUNT)
                                                  65:    #    define PIC32_SRS_SET_COUNT __PIC32_SRS_SET_COUNT
                                                  66:    #  else
                                                  67:    #    warning PIC32_SRS_SET_COUNT not defined on build line
                                                  68:    #    define PIC32_SRS_SET_COUNT 2
                                                  69:    #  endif
                                                  70:    #endif
                                                  71:    
                                                  72:    #if defined(__PIC32MX) || defined(__PIC32MM) || defined(__PIC32MZ)
                                                  73:    #define INIT_DATA 1
                                                  74:    #endif
                                                  75:    
                                                  76:    /* This file contains 32-bit assembly code */
                                                  77:           .set nomips16
                                                  78:    
                                                  79:            ##################################################################
                                                  80:            # Entry point of the entire application
                                                  81:            ##################################################################
                                                  82:            .section .reset,code,keep
                                                  83:            .align 2
                                                  84:            .set noreorder
                                                  85:            .ent _reset
                                                  86:    
                                                  87:    ############################
                                                  88:    # Begin ISA switching code #
                                                  89:    ############################
                                                  90:    
                                                  91:    #if defined (__mips_micromips)
                                                  92:            .set micromips
                                                  93:    #endif
                                                  94:    
                                                  95:    #if (defined(__PIC32_HAS_MICROMIPS)) && (defined(__PIC32_HAS_MIPS32R2))
                                                  96:    _reset:
                                                  97:            .word 0x10000003     /* MIPS32:    branch forward 0x10 bytes from here  */
                                                  98:                                 /* MicroMIPS: ADDI32 $0, $0, 0x0007 (nop)          */
                                                  99:                                 /* DO NOT change the relative branch               */
                                                  100:   
                                                  101:           .word 0x00000000     /* NOP */
                                                  102:   __reset_micromips_isa:
                                                  103:           .set    micromips
                                                  104:           jal     _startup
                                                  105:           nop
                                                  106:   
                                                  107:           .align 2
                                                  108:           /* Device not in proper ISA mode */
                                                  109:           .set nomicromips
                                                  110:   __reset_switch_isa:
                                                  111:           jal _startup
                                                  112:           nop
                                                  113:   
                                                  114:   #else
                                                  115:   
                                                  116:   _reset:
BFC00000  0FF00002   JAL 0xBFC00008               117:           jal _startup
BFC00004  00000000   NOP                          118:           nop
                                                  119:   
                                                  120:   #endif  /* __PIC32_HAS_MICROMIPS */
                                                  121:   
                                                  122:           .align 2
                                                  123:           .end _reset
                                                  124:           .globl _reset
                                                  125:           .size _reset, .-_reset
                                                  126:   
                                                  127:           .section .reset.startup,code,keep
                                                  128:           .align 2
                                                  129:           .set noreorder
                                                  130:   
                                                  131:   #if defined (__mips_micromips)
                                                  132:           .set micromips
                                                  133:   #else
                                                  134:           .set nomicromips
                                                  135:   #endif
                                                  136:   
                                                  137:   ############################
                                                  138:   # End ISA switching code   #
                                                  139:   ############################
                                                  140:   
                                                  141:           ##################################################################
                                                  142:           # Startup code
                                                  143:           ##################################################################
                                                  144:           .align 2
                                                  145:           .globl _startup
                                                  146:           .set noreorder
                                                  147:           .ent _startup
                                                  148:   _startup:
                                                  149:           ##################################################################
                                                  150:           # If entered because of an NMI, jump to the NMI handler.
                                                  151:           ##################################################################
BFC00008  401A6000   MFC0 K0, Status              152:           mfc0    k0,_CP0_STATUS
BFC0000C  7F5A04C0   EXT K0, K0, 19, 1            153:           ext     k0,k0,19,1              # Extract NMI bit
BFC00010  13400005   BEQ K0, ZERO, 0xBFC00028     154:           beqz    k0,_no_nmi
BFC00014  00000000   NOP                          155:           nop
BFC00018  3C1A9D01   LUI K0, -25343               156:           la      k0,_nmi_handler
BFC00020  03400008   JR K0                        157:           jr      k0
BFC00024  00000000   NOP                          158:           nop
                                                  159:   _no_nmi:
                                                  160:   
                                                  161:           ##################################################################
                                                  162:           # Initialize Stack Pointer
                                                  163:           #   _stack is initialized by the linker script to point to the
                                                  164:           #    starting location of the stack in DRM
                                                  165:           ##################################################################
BFC00028  3C1DA000   LUI SP, -24576               166:           la      sp,_stack
                                                  167:   
                                                  168:           ##################################################################
                                                  169:           # Initialize Global Pointer
                                                  170:           #   _gp is initialized by the linker script to point to "middle"
                                                  171:           #   of the small variables region
                                                  172:           ##################################################################
BFC00030  3C1CA001   LUI GP, -24575               173:           la      gp,_gp
                                                  174:   
                                                  175:   #if (PIC32_SRS_SET_COUNT == 2)
                                                  176:           ##################################################################
                                                  177:           # Initialize Global Pointer in Shadow Set
                                                  178:           #   The SRSCtl's PSS field must be set to the shadow set in which
                                                  179:           #   to initialize the global pointer.  Since we have only a
                                                  180:           #   single shadow set (besides the normal), we will initialize
                                                  181:           #   SRSCtl<PSS> to SRSCtl<HSS>.  We then write the global pointer
                                                  182:           #   to the previous shadow set to ensure that on interrupt, the
                                                  183:           #   global pointer has been initialized.
                                                  184:           ##################################################################
                                                  185:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  186:           add     t3,t1,zero              # Save off current SRSCtl
                                                  187:           ext     t2,t1,26,4              # to obtain HSS field
                                                  188:           ins     t1,t2,6,4               # Put HSS field
                                                  189:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  190:           ehb                             # Clear hazard before using new SRSCTL
                                                  191:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  192:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  193:           ehb
                                                  194:   
                                                  195:   #elif (PIC32_SRS_SET_COUNT > 2)
                                                  196:           ##################################################################
                                                  197:           # Initialize Global Pointer in Shadow Set(s)
                                                  198:           #   The SRSCtl PSS field must be set to the shadow set in which
                                                  199:           #   to initialize the global pointer.  We will initialize
                                                  200:           #   SRSCtl<PSS> to the number of reg sets and work down to set zero.
                                                  201:           #   We write the global pointer to the previous shadow set to
                                                  202:           #   ensure that on interrupt, the global pointer has been
                                                  203:           #   initialized.
                                                  204:           ##################################################################
                                                  205:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  206:           add     t3,t1,zero              # Save off current SRSCtl
                                                  207:   
                                                  208:           li      t2,(PIC32_SRS_SET_COUNT-1)
                                                  209:   
                                                  210:   1:      ins     t1,t2,6,4               # Put next shadow set field
                                                  211:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  212:           ehb                             # Clear hazard before using new SRSCTL
                                                  213:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  214:   
                                                  215:           addiu   t2,t2,-1                # Next lower shadow set
                                                  216:                                           # Loop for all sets
                                                  217:           bne     t2,$0,1b                # Down to zero (normal GPR set)
                                                  218:           nop
                                                  219:   
                                                  220:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  221:           ehb
                                                  222:   
                                                  223:   #endif /* (PIC32_SRS_SET_COUNT > 2) */
                                                  224:   
                                                  225:           ##################################################################
                                                  226:           # Call the "on reset" procedure
                                                  227:           ##################################################################
BFC00038  3C089D01   LUI T0, -25343               228:           la      t0,_on_reset
BFC00040  0100F809   JALR T0                      229:           jalr    t0
BFC00044  00000000   NOP                          230:           nop
                                                  231:   
                                                  232:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  233:           ##################################################################
                                                  234:           # Initialize TLB for fixed mapping to EBI and SQI
                                                  235:           ##################################################################
                                                  236:           .extern __pic32_tlb_init_ebi_sqi
                                                  237:           la      t0,__pic32_tlb_init_ebi_sqi
                                                  238:           jalr    t0
                                                  239:           nop
                                                  240:   #endif
                                                  241:   
                                                  242:           ##################################################################
                                                  243:           # Clear uninitialized data sections
                                                  244:           ##################################################################
                                                  245:   _start_bss_init:
BFC00048  3C08A000   LUI T0, -24576               246:           la      t0,_bss_begin
BFC00050  3C09A000   LUI T1, -24576               247:           la      t1,_bss_end
BFC00058  10000003   BEQ ZERO, ZERO, 0xBFC00068   248:           b       _bss_check
BFC0005C  00000000   NOP                          249:           nop
                                                  250:   
                                                  251:   _bss_init:
BFC00060  AD000000   SW ZERO, 0(T0)               252:           sw      zero,0x0(t0)
BFC00064  25080004   ADDIU T0, T0, 4              253:           addu    t0,4
                                                  254:   _bss_check:
BFC00068  0109082B   SLTU AT, T0, T1              255:           bltu    t0,t1,_bss_init
BFC00070  00000000   NOP                          256:           nop
                                                  257:   
                                                  258:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  259:           ##################################################################
                                                  260:           # Initialize L1 cache. This must be done after bss clearing
                                                  261:           # since the _bss_end symbol may not be cache-line aligned.
                                                  262:           ##################################################################
                                                  263:           .extern   __pic32_init_cache
                                                  264:           la      t0,__pic32_init_cache
                                                  265:           jalr    t0
                                                  266:           nop
                                                  267:   #endif
                                                  268:   
                                                  269:   #if defined(INIT_DATA) || defined(__PIC32_HAS_INIT_DATA)
                                                  270:   
                                                  271:   #if defined(__LIBBUILD__) /* Prebuilt crt0.o file */
                                                  272:   
                                                  273:           ##################################################################
                                                  274:           # Initialize data using the linker-generated .dinit table
                                                  275:           # For use with XC32 versions prior to XC32 v2.10 only.
                                                  276:           ##################################################################
                                                  277:           .equiv FMT_CLEAR,0
                                                  278:           .equiv FMT_COPY,1
                                                  279:   _dinit_init:
                                                  280:           la      t0,_dinit_addr
                                                  281:   
                                                  282:   #define SRC t0
                                                  283:   #define DST t1
                                                  284:   #define LEN t2
                                                  285:   #define FMT t3
                                                  286:   
                                                  287:   0:      lw      DST,0(SRC)
                                                  288:           beqz    DST,9f
                                                  289:           addu    SRC,4
                                                  290:           lw      LEN,0(SRC)
                                                  291:           addu    SRC,4
                                                  292:           lw      FMT,0(SRC)
                                                  293:           beq     FMT,$0,_dinit_clear
                                                  294:           addu    SRC,4
                                                  295:   
                                                  296:   _dinit_copy:
                                                  297:           lbu     t4,0(SRC)
                                                  298:           subu    LEN,1
                                                  299:           addu    SRC,1
                                                  300:           sb      t4,0(DST)
                                                  301:           bne     LEN,$0,_dinit_copy
                                                  302:           addu    DST,1
                                                  303:   
                                                  304:           b       _dinit_end
                                                  305:           nop
                                                  306:   
                                                  307:   _dinit_clear:
                                                  308:           sb      $0,(DST)
                                                  309:           subu    LEN,1
                                                  310:           bne     LEN,$0,_dinit_clear
                                                  311:           addu    DST,1
                                                  312:   
                                                  313:   _dinit_end:
                                                  314:           addu    SRC,3
                                                  315:           addiu   LEN,$0,-4
                                                  316:           and     SRC,LEN,SRC
                                                  317:           lw      DST,0(SRC)
                                                  318:           bne     DST,$0,0b
                                                  319:           nop
                                                  320:   9:
                                                  321:   
                                                  322:   #else
                                                  323:           #####################################################################
                                                  324:           # Initialize data using the linker-generated .dinit table
                                                  325:           # XC32 v2.10 and later provide the data-init code in a separate file
                                                  326:           # packaged with the compiler rather than the DFP. Use that init
                                                  327:           # code instead.
                                                  328:           #####################################################################
                                                  329:           .extern   __pic32_data_init
BFC00074  3C089D01   LUI T0, -25343               330:           la      t0, __pic32_data_init
BFC0007C  0100F809   JALR T0                      331:           jalr    t0
BFC00080  00000000   NOP                          332:           nop
                                                  333:   
                                                  334:   #if defined(_OFF168_VOFF_POSITION)
                                                  335:           lui	t1,%hi(OFF168)
                                                  336:           lui	t2,%hi(__vector_offset_168)
                                                  337:           addiu	t2,t2,%lo(__vector_offset_168)
                                                  338:           sw	t2,%lo(OFF168)(t1)
                                                  339:   #endif
                                                  340:   
                                                  341:   #endif /* __LIBBUILD__ */
                                                  342:   
                                                  343:   #endif /* INIT_DATA */
                                                  344:   
                                                  345:           ##################################################################
                                                  346:           # If there are no RAM functions, skip the next section --
                                                  347:           # initializing bus matrix registers.
                                                  348:           ##################################################################
BFC00084  3C090000   LUI T1, 0                    349:           la      t1,_ramfunc_begin
BFC0008C  11200010   BEQ T1, ZERO, 0xBFC000D0     350:           beqz    t1,_ramfunc_done
BFC00090  00000000   NOP                          351:           nop
                                                  352:   
                                                  353:   #if defined(INIT_SSX) || defined(__PIC32_HAS_SSX)
                                                  354:     /* No initialization required */
                                                  355:   #else /* Use BMX */
                                                  356:           ##################################################################
                                                  357:           # Initialize bus matrix registers if RAM functions exist in the
                                                  358:           # application
                                                  359:           ##################################################################
BFC00094  3C090000   LUI T1, 0                    360:           la      t1,_bmxdkpba_address
BFC0009C  3C0ABF88   LUI T2, -16504               361:           la      t2,BMXDKPBA
BFC000A4  AD490000   SW T1, 0(T2)                 362:           sw      t1,0(t2)
BFC000A8  3C090000   LUI T1, 0                    363:           la      t1,_bmxdudba_address
BFC000B0  3C0ABF88   LUI T2, -16504               364:           la      t2,BMXDUDBA
BFC000B8  AD490000   SW T1, 0(T2)                 365:           sw      t1,0(t2)
BFC000BC  3C090000   LUI T1, 0                    366:           la      t1,_bmxdupba_address
BFC000C4  3C0ABF88   LUI T2, -16504               367:           la      t2,BMXDUPBA
BFC000CC  AD490000   SW T1, 0(T2)                 368:           sw      t1,0(t2)
                                                  369:   #endif /* INIT_SSX */
                                                  370:   
                                                  371:   _ramfunc_done:
                                                  372:   
                                                  373:           ##################################################################
                                                  374:           # Initialize CP0 registers
                                                  375:           ##################################################################
                                                  376:           # Initialize Count register
                                                  377:           ##################################################################
BFC000D0  40804800   MTC0 ZERO, Count             378:           mtc0    zero,_CP0_COUNT
                                                  379:   
                                                  380:           ##################################################################
                                                  381:           # Initialize Compare register
                                                  382:           ##################################################################
BFC000D4  240AFFFF   ADDIU T2, ZERO, -1           383:           li      t2,-1
BFC000D8  408A5800   MTC0 T2, Compare             384:           mtc0    t2,_CP0_COMPARE
                                                  385:   
                                                  386:           ##################################################################
                                                  387:           # Ensure BEV set and Initialize EBase register
                                                  388:           ##################################################################
BFC000DC  3C080040   LUI T0, 64                   389:           li      t0, (1<<22)
BFC000E0  400A6000   MFC0 T2, Status              390:           mfc0    t2,_CP0_STATUS
BFC000E4  010A5025   OR T2, T0, T2                391:           or      t2,t0,t2               # Set BEV bit 22
BFC000E8  408A6000   MTC0 T2, Status              392:           mtc0    t2,_CP0_STATUS
                                                  393:   
BFC000EC  3C099D04   LUI T1, -25340               394:           la      t1,_ebase_address
BFC000F4  000000C0   EHB                          395:           ehb
BFC000F8  40897801   MTC0 T1, EBase               396:           mtc0    t1,_CP0_EBASE
                                                  397:           
                                                  398:           ##################################################################
                                                  399:           # Initialize PRISS register to a safer default for devices that 
                                                  400:           # have it. The application should re-initialize it to an
                                                  401:           # application-specific value.
                                                  402:           #
                                                  403:           # We do NOT do this by default.
                                                  404:           ##################################################################
                                                  405:   #if defined(USE_DEFAULT_PRISS_VALUE) 
                                                  406:   #if defined(_PRISS_PRI7SS_POSITION)
                                                  407:   #if (PIC32_SRS_SET_COUNT >= 7)
                                                  408:           li	    t2, 0x76540000
                                                  409:           addiu	t2, t2, 0x3210
                                                  410:           lui	    t1, %hi(PRISS)
                                                  411:           sw	    t2, %lo(PRISS)(t1)
                                                  412:   #elif (PIC32_SRS_SET_COUNT <= 2)
                                                  413:           li	    t2, 0x10000000
                                                  414:           lui	    t1, %hi(PRISS)
                                                  415:           sw	    t2, %lo(PRISS)(t1)
                                                  416:   #endif /* PIC32_SRS_SET_COUNT */
                                                  417:   #endif /* _PRISS_PRI7SS_POSITION */
                                                  418:   #endif /* USE_DEFAULT_PRISS_VALUE */
                                                  419:           
                                                  420:           ##################################################################
                                                  421:           # Initialize IntCtl/INTCON.VS register with _vector_spacing
                                                  422:           ##################################################################
BFC000FC  3C090000   LUI T1, 0                    423:           la      t1,_vector_spacing
                                                  424:   #if defined(INIT_INTCONVS) || defined(__PIC32_HAS_INTCONVS)
                                                  425:           la      t0, INTCON
                                                  426:           lw      t2, 0(t0)
                                                  427:           li      t2, 0
                                                  428:           ins     t2, t1, 16, 7
                                                  429:   #if defined(__PIC32MM) && defined(_INTCON_MVEC_MASK)
                                                  430:           ori     t2, t2, _INTCON_MVEC_MASK
                                                  431:   #endif
                                                  432:           sw      t2, 0(t0)
                                                  433:   #endif
BFC00104  240A0000   ADDIU T2, ZERO, 0            434:           li      t2,0                    # Clear t2 and
BFC00108  7D2A4944   INS T2, T1, 5, 5             435:           ins     t2,t1,5,5               # shift value to VS field
BFC0010C  408A6001   MTC0 T2, IntCtl              436:           mtc0    t2,_CP0_INTCTL
                                                  437:   
                                                  438:           ##################################################################
                                                  439:           # Initialize CAUSE registers
                                                  440:           # - Enable counting of Count register <DC = 0>
                                                  441:           # - Use special exception vector <IV = 1>
                                                  442:           # - Clear pending software interrupts <IP1:IP0 = 0>
                                                  443:           ##################################################################
BFC00110  3C090080   LUI T1, 128                  444:           li      t1,0x00800000
BFC00114  40896800   MTC0 T1, Cause               445:           mtc0    t1,_CP0_CAUSE
                                                  446:   
                                                  447:           ##################################################################
                                                  448:           # Initialize STATUS register
                                                  449:           # - Access to Coprocessor 0 not allowed in user mode <CU0 = 0>
                                                  450:           # - User mode uses configured endianness <RE = 0>
                                                  451:           # - Preserve Bootstrap Exception vectors <BEV>
                                                  452:           # - Preserve soft reset <SR> and non-maskable interrupt <NMI>
                                                  453:           # - CorExtend enabled based on whether CorExtend User Defined
                                                  454:           #   Instructions have been implemented <CEE = Config<UDI>>
                                                  455:           # - Disable any pending interrupts <IM7..IM2 = 0, IM1..IM0 = 0>
                                                  456:           # - Disable hardware interrupts <IPL7:IPL2 = 0>
                                                  457:           # - Base mode is Kernel mode <UM = 0>
                                                  458:           # - Error level is normal <ERL = 0>
                                                  459:           # - Exception level is normal <EXL = 0>
                                                  460:           # - Interrupts are disabled <IE = 0>
                                                  461:           # - DSPr2 ASE is enabled for devices that support it <MX = 1>
                                                  462:           # - FPU64 is enabled for devices that support it <CU1=1> & <FR=1>
                                                  463:           ##################################################################
BFC00118  40088000   MFC0 T0, Config              464:           mfc0    t0,_CP0_CONFIG
BFC0011C  7D090580   EXT T1, T0, 22, 1            465:           ext     t1,t0,22,1              # Extract UDI from Config register
BFC00120  00094C40   SLL T1, T1, 17               466:           sll     t1,t1,17                # Move UDI to Status.CEE location
BFC00124  40086000   MFC0 T0, Status              467:           mfc0    t0,_CP0_STATUS
BFC00128  3C010058   LUI AT, 88                   468:           and     t0,t0,0x00580000        # Preserve SR, NMI, and BEV
                                                  469:   #if defined(INIT_DSPR2) || defined(__PIC32_HAS_DSPR2)
                                                  470:           li      t2, 0x01000000          # Set the Status.MX bit to enable DSP
                                                  471:           or      t0,t2,t0
                                                  472:   #endif
                                                  473:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  474:           li      t2, 0x24000000          # Set the Status.CU1 and Status.FR bits to
                                                  475:           or      t0,t2,t0                # enable the FPU in FR64 mode
                                                  476:   #endif
                                                  477:   
BFC00130  01284025   OR T0, T1, T0                478:           or      t0,t1,t0                # Include Status.CEE (from UDI)
BFC00134  40886000   MTC0 T0, Status              479:           mtc0    t0,_CP0_STATUS
                                                  480:           
                                                  481:   #if defined(PIC32WK) && defined(_CP0_CONFIG3) && defined (__mips_micromips)
                                                  482:           # Ensure that the ISAONEXEC bit is set for the microMIPS ISA for the PIC32WK family
                                                  483:           # _bsc0 (_CP0_CONFIG3, _CP0_CONFIG3_SELECT, ISAONEXEC_MASK)
                                                  484:           li      t1,0x10000              # ISAONEXEC bit
                                                  485:           mfc0    t0,_CP0_CONFIG3
                                                  486:           or      t1,t0,t1
                                                  487:           mtc0    t1,_CP0_CONFIG3
                                                  488:   
                                                  489:   #endif /* PIC32WK && __mips_micromips */
                                                  490:   
                                                  491:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  492:                                           # FPU Control and Status
                                                  493:           li      t2,0x1000000            # FCSR: RM=0, FS=1, FO=0, FN=0
                                                  494:                                           # Enables: 0b00000 E=1, V=0, Z=0, O=0, U=0, I=0
                                                  495:           ctc1    t2, $31                 # High perf on denormal operands & tiny results
                                                  496:   #endif
BFC00138  000000C0   EHB                          497:           ehb
                                                  498:   
                                                  499:           ##################################################################
                                                  500:           # Call the "on bootstrap" procedure
                                                  501:           ##################################################################
BFC0013C  3C089D01   LUI T0, -25343               502:           la      t0,_on_bootstrap
BFC00144  0100F809   JALR T0                      503:           jalr    t0
BFC00148  00000000   NOP                          504:           nop
                                                  505:   
                                                  506:           ##################################################################
                                                  507:           # Initialize Status<BEV> for normal exception vectors
                                                  508:           ##################################################################
BFC0014C  40086000   MFC0 T0, Status              509:           mfc0    t0,_CP0_STATUS
BFC00150  3C01FFBF   LUI AT, -65                  510:           and     t0,t0,0xffbfffff        # Clear BEV
BFC0015C  40886000   MTC0 T0, Status              511:           mtc0    t0,_CP0_STATUS
                                                  512:   
                                                  513:           ##################################################################
                                                  514:           # Call main. We do this via a thunk in the text section so that
                                                  515:           # a normal jump and link can be used, enabling the startup code
                                                  516:           # to work properly whether main is written in MIPS16 or MIPS32
                                                  517:           # code. I.e., the linker will correctly adjust the JAL to JALX if
                                                  518:           # necessary
                                                  519:           ##################################################################
BFC00160  30840000   ANDI A0, A0, 0               520:           and     a0,a0,0
BFC00164  30A50000   ANDI A1, A1, 0               521:           and     a1,a1,0
BFC00168  3C089D01   LUI T0, -25343               522:           la      t0,_main_entry
BFC00170  01000008   JR T0                        523:           jr      t0
BFC00174  00000000   NOP                          524:           nop
                                                  525:   
                                                  526:           .end _startup
                                                  527:   
                                                  528:           ##################################################################
                                                  529:           # Boot Exception Vector Handler
                                                  530:           # Jumps to _bootstrap_exception_handler
                                                  531:           ##################################################################
                                                  532:           .section .bev_handler,code,keep
                                                  533:           .align 2
                                                  534:           .set noreorder
                                                  535:           .ent _bev_exception
                                                  536:   _bev_exception:
BFC00380  3C1A9D01   LUI K0, -25343               537:           la        k0,_bootstrap_exception_handler
BFC00388  03400008   JR K0                        538:           jr        k0
BFC0038C  00000000   NOP                          539:           nop
                                                  540:   
                                                  541:           .end _bev_exception
                                                  542:   
                                                  543:           ##################################################################
                                                  544:           # General Exception Vector Handler
                                                  545:           # Jumps to _general_exception_context
                                                  546:           ##################################################################
                                                  547:           .section .gen_handler,code
                                                  548:           .align 2
                                                  549:           .set noreorder
                                                  550:           .ent _gen_exception
                                                  551:   _gen_exception:
9D03F180  3C1A9D01   LUI K0, -25343               552:   0:      la      k0,_general_exception_context
9D03F188  03400008   JR K0                        553:           jr      k0
9D03F18C  00000000   NOP                          554:           nop
                                                  555:   
                                                  556:           .end _gen_exception
                                                  557:   
                                                  558:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  559:           ##################################################################
                                                  560:           # Simple TLB-Refill Exception Vector
                                                  561:           # Jumps to _simple_tlb_refill_exception_context
                                                  562:           ##################################################################
                                                  563:           .section .simple_tlb_refill_vector,code,keep
                                                  564:           .align 2
                                                  565:           .set noreorder
                                                  566:           .ent simple_tlb_refill_vector
                                                  567:   simple_tlb_refill_vector:
                                                  568:           la      k0,_simple_tlb_refill_exception_context
                                                  569:           jr      k0
                                                  570:           nop
                                                  571:   
                                                  572:           .end simple_tlb_refill_vector
                                                  573:   #endif
                                                  574:   
                                                  575:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  576:           ##################################################################
                                                  577:           # Cache-Error Exception Vector Handler
                                                  578:           # Jumps to _cache_err_exception_context
                                                  579:           ##################################################################
                                                  580:           .section .cache_err_vector,code,keep
                                                  581:           .align 2
                                                  582:           .set noreorder
                                                  583:           .ent _cache_err_vector
                                                  584:   _cache_err_vector:
                                                  585:           la      k0,_cache_err_exception_context
                                                  586:           jr      k0
                                                  587:           nop
                                                  588:   
                                                  589:           .end _cache_err_vector
                                                  590:   #endif
                                                  591:   
                                                  592:           .section .text.main_entry,code,keep
                                                  593:           .align 2
                                                  594:           .ent _main_entry
                                                  595:   _main_entry:
                                                  596:   
                                                  597:   #if defined(CPP_INIT)
                                                  598:           .weak _init
                                                  599:           # call .init section to run constructors etc
9D00D7E8  3C040000   LUI A0, 0                    600:           lui	a0,%hi(_init)
9D00D7EC  27BDFFE8   ADDIU SP, SP, -24            601:           addiu	sp,sp,-24
9D00D7F0  24840000   ADDIU A0, A0, 0              602:           addiu	a0,a0,%lo(_init)
9D00D7F4  10800003   BEQ A0, ZERO, 0x9D00D804     603:           beq	a0,$0,2f
9D00D7F8  AFBF0014   SW RA, 20(SP)                604:           sw	$31,20(sp)	 #,
9D00D7FC  0080F809   JALR A0                      605:           jalr	a0
9D00D800  00000000   NOP                          606:           nop
                                                  607:   2:
                                                  608:   #endif
9D00D804  30840000   ANDI A0, A0, 0               609:           and     a0,a0,0
9D00D808  30A50000   ANDI A1, A1, 0               610:           and     a1,a1,0
                                                  611:   
                                                  612:           ##################################################################
                                                  613:   
                                                  614:           # Call main
                                                  615:           ##################################################################
9D00D80C  3C089D01   LUI T0, -25343               616:           la    	t0,main
9D00D814  0100F809   JALR T0                      617:           jalr 	t0
9D00D818  00000000   NOP                          618:           nop
                                                  619:   
                                                  620:   #if defined(CALL_EXIT)
                                                  621:           ##################################################################
                                                  622:           # Call exit()
                                                  623:           ##################################################################
                                                  624:           jal exit
                                                  625:           nop
                                                  626:   #endif
                                                  627:   
                                                  628:           ##################################################################
                                                  629:           # Just in case, go into infinite loop
                                                  630:           # Call a software breakpoint only with -mdebugger compiler option
                                                  631:           ##################################################################
                                                  632:           .weak __exception_handler_break
                                                  633:   __crt0_exit:
                                                  634:   1:
9D00D81C  3C029D01   LUI V0, -25343               635:           la      v0,__exception_handler_break
9D00D824  10400003   BEQ V0, ZERO, 0x9D00D834     636:           beq     v0,0,0f
9D00D828  00000000   NOP                          637:           nop
9D00D82C  0040F809   JALR V0                      638:           jalr    v0
9D00D830  00000000   NOP                          639:           nop
                                                  640:   
9D00D834  1000FFF9   BEQ ZERO, ZERO, 0x9D00D81C   641:   0:      b       1b
9D00D838  00000000   NOP                          642:           nop
                                                  643:   
                                                  644:           .globl __crt0_exit
                                                  645:           .end _main_entry
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PT37-JOB1/src/pic32m-gcc/gcc/libgcc/libgcc2.c  ------
9D0054C8  00C04021   ADDU T0, A2, ZERO
9D00596C  00C04021   ADDU T0, A2, ZERO
9D005DD0  00C04021   ADDU T0, A2, ZERO
9D0054CC  00805021   ADDU T2, A0, ZERO
9D005970  00804821   ADDU T1, A0, ZERO
9D005DD4  00801021   ADDU V0, A0, ZERO
9D0054D0  14E00046   BNE A3, ZERO, 0x9D0055EC
9D0054D4  00A01821   ADDU V1, A1, ZERO
9D005974  14E0003B   BNE A3, ZERO, 0x9D005A64
9D005978  00A01821   ADDU V1, A1, ZERO
9D005DD8  14E0003F   BNE A3, ZERO, 0x9D005ED8
9D005DDC  00A04821   ADDU T1, A1, ZERO
9D0054D8  00A6102B   SLTU V0, A1, A2
9D0054DC  1040005D   BEQ V0, ZERO, 0x9D005654
9D0054E0  70C21020   CLZ V0, A2
9D00597C  00A6102B   SLTU V0, A1, A2
9D005980  10400048   BEQ V0, ZERO, 0x9D005AA4
9D005984  70C21020   CLZ V0, A2
9D005DE0  00A6182B   SLTU V1, A1, A2
9D005DE4  10600047   BEQ V1, ZERO, 0x9D005F04
9D005DE8  70C31820   CLZ V1, A2
9D0054E4  50400008   BEQL V0, ZERO, 0x9D005508
9D0054E8  00082C02   SRL A1, T0, 16
9D005988  50400008   BEQL V0, ZERO, 0x9D0059AC
9D00598C  00083402   SRL A2, T0, 16
9D005DEC  50600008   BEQL V1, ZERO, 0x9D005E10
9D005DF0  00081C02   SRL V1, T0, 16
9D0054F8  00464004   SLLV T0, A2, V0
9D00599C  00464004   SLLV T0, A2, V0
9D005E00  00664004   SLLV T0, A2, V1
9D0054EC  00022023   SUBU A0, ZERO, V0
9D0054F0  008A2006   SRLV A0, T2, A0
9D0054F4  00451804   SLLV V1, A1, V0
9D0054FC  00831825   OR V1, A0, V1
9D005990  00021823   SUBU V1, ZERO, V0
9D005994  00452804   SLLV A1, A1, V0
9D005998  00641806   SRLV V1, A0, V1
9D0059A0  00651825   OR V1, V1, A1
9D005DF4  00034823   SUBU T1, ZERO, V1
9D005DF8  00652804   SLLV A1, A1, V1
9D005DFC  01244806   SRLV T1, A0, T1
9D005E04  01254825   OR T1, T1, A1
9D005500  004A5004   SLLV T2, T2, V0
9D0059A4  00444804   SLLV T1, A0, V0
9D005E08  00641004   SLLV V0, A0, V1
9D005504  00082C02   SRL A1, T0, 16
9D005508  0065001B   DIVU V1, A1
9D00550C  00A001F4   TEQ A1, ZERO
9D005510  00006010   MFHI T4
9D005514  00005812   MFLO T3
9D005518  3107FFFF   ANDI A3, T0, -1
9D00551C  000A2402   SRL A0, T2, 16
9D005520  00001012   MFLO V0
9D005524  71673002   MUL A2, T3, A3
9D005528  000C6400   SLL T4, T4, 16
9D00552C  01842025   OR A0, T4, A0
9D005530  0086602B   SLTU T4, A0, A2
9D005534  0065001B   DIVU V1, A1
9D005538  00A001F4   TEQ A1, ZERO
9D00553C  1180000B   BEQ T4, ZERO, 0x9D00556C
9D005540  00861823   SUBU V1, A0, A2
9D005544  00882021   ADDU A0, A0, T0
9D005548  0088182B   SLTU V1, A0, T0
9D00554C  14600006   BNE V1, ZERO, 0x9D005568
9D005550  2562FFFF   ADDIU V0, T3, -1
9D005554  0086182B   SLTU V1, A0, A2
9D005558  10600004   BEQ V1, ZERO, 0x9D00556C
9D00555C  00861823   SUBU V1, A0, A2
9D005560  2562FFFE   ADDIU V0, T3, -2
9D005564  00882021   ADDU A0, A0, T0
9D005568  00861823   SUBU V1, A0, A2
9D00556C  314AFFFF   ANDI T2, T2, -1
9D005570  0065001B   DIVU V1, A1
9D005574  00A001F4   TEQ A1, ZERO
9D005578  00005810   MFHI T3
9D00557C  00003012   MFLO A2
9D005580  00002012   MFLO A0
9D005584  70C73802   MUL A3, A2, A3
9D005588  000B5C00   SLL T3, T3, 16
9D00558C  016A5025   OR T2, T3, T2
9D005590  0147582B   SLTU T3, T2, A3
9D005594  0065001B   DIVU V1, A1
9D005598  00A001F4   TEQ A1, ZERO
9D00559C  51600009   BEQL T3, ZERO, 0x9D0055C4
9D0055A0  00021400   SLL V0, V0, 16
9D0055A4  01485021   ADDU T2, T2, T0
9D0055A8  0148402B   SLTU T0, T2, T0
9D0055AC  15000004   BNE T0, ZERO, 0x9D0055C0
9D0055B0  24C4FFFF   ADDIU A0, A2, -1
9D0055B4  0147382B   SLTU A3, T2, A3
9D0055B8  24C6FFFE   ADDIU A2, A2, -2
9D0055BC  00C7200B   MOVN A0, A2, A3
9D0055C0  00021400   SLL V0, V0, 16
9D0055C4  00821025   OR V0, A0, V0
9D0055C8  00001821   ADDU V1, ZERO, ZERO
9D0059A8  00083402   SRL A2, T0, 16
9D0059AC  0066001B   DIVU V1, A2
9D0059B0  00C001F4   TEQ A2, ZERO
9D0059B4  00002010   MFHI A0
9D0059B8  00005812   MFLO T3
9D0059BC  310CFFFF   ANDI T4, T0, -1
9D0059C0  00095402   SRL T2, T1, 16
9D0059C4  716C5802   MUL T3, T3, T4
9D0059C8  00042400   SLL A0, A0, 16
9D0059CC  008A5025   OR T2, A0, T2
9D0059D0  014B682B   SLTU T5, T2, T3
9D0059D4  0066001B   DIVU V1, A2
9D0059D8  00C001F4   TEQ A2, ZERO
9D0059DC  51A00009   BEQL T5, ZERO, 0x9D005A04
9D0059E0  014B5023   SUBU T2, T2, T3
9D0059E4  01485021   ADDU T2, T2, T0
9D0059E8  0148182B   SLTU V1, T2, T0
9D0059EC  54600005   BNEL V1, ZERO, 0x9D005A04
9D0059F0  014B5023   SUBU T2, T2, T3
9D0059F4  014B202B   SLTU A0, T2, T3
9D0059F8  01481821   ADDU V1, T2, T0
9D0059FC  0064500B   MOVN T2, V1, A0
9D005A00  014B5023   SUBU T2, T2, T3
9D005A04  3123FFFF   ANDI V1, T1, -1
9D005A08  0146001B   DIVU T2, A2
9D005A0C  00C001F4   TEQ A2, ZERO
9D005A10  00004810   MFHI T1
9D005A14  00002012   MFLO A0
9D005A18  708C2002   MUL A0, A0, T4
9D005A1C  00094C00   SLL T1, T1, 16
9D005A20  01234825   OR T1, T1, V1
9D005A24  0124182B   SLTU V1, T1, A0
9D005A28  0146001B   DIVU T2, A2
9D005A2C  00C001F4   TEQ A2, ZERO
9D005A30  50600009   BEQL V1, ZERO, .LBE15
9D005A34  01244823   SUBU T1, T1, A0
9D005A38  01284821   ADDU T1, T1, T0
9D005A3C  0128182B   SLTU V1, T1, T0
9D005A40  54600005   BNEL V1, ZERO, .LBE15
9D005A44  01244823   SUBU T1, T1, A0
9D005A48  0124182B   SLTU V1, T1, A0
9D005A4C  01284021   ADDU T0, T1, T0
9D005A50  0103480B   MOVN T1, T0, V1
9D005A54  01244823   SUBU T1, T1, A0
9D005E0C  00081C02   SRL V1, T0, 16
9D005E10  0123001B   DIVU T1, V1
9D005E14  006001F4   TEQ V1, ZERO
9D005E18  00006010   MFHI T4
9D005E1C  00005812   MFLO T3
9D005E20  310AFFFF   ANDI T2, T0, -1
9D005E24  00022402   SRL A0, V0, 16
9D005E28  00003012   MFLO A2
9D005E2C  716A3802   MUL A3, T3, T2
9D005E30  000C6400   SLL T4, T4, 16
9D005E34  01842025   OR A0, T4, A0
9D005E38  0087602B   SLTU T4, A0, A3
9D005E3C  0123001B   DIVU T1, V1
9D005E40  006001F4   TEQ V1, ZERO
9D005E44  1180000B   BEQ T4, ZERO, 0x9D005E74
9D005E48  00872823   SUBU A1, A0, A3
9D005E4C  00882021   ADDU A0, A0, T0
9D005E50  0088282B   SLTU A1, A0, T0
9D005E54  14A00006   BNE A1, ZERO, 0x9D005E70
9D005E58  2566FFFF   ADDIU A2, T3, -1
9D005E5C  0087282B   SLTU A1, A0, A3
9D005E60  10A00004   BEQ A1, ZERO, 0x9D005E74
9D005E64  00872823   SUBU A1, A0, A3
9D005E68  2566FFFE   ADDIU A2, T3, -2
9D005E6C  00882021   ADDU A0, A0, T0
9D005E70  00872823   SUBU A1, A0, A3
9D005E74  3042FFFF   ANDI V0, V0, -1
9D005E78  00A3001B   DIVU A1, V1
9D005E7C  006001F4   TEQ V1, ZERO
9D005E80  00004810   MFHI T1
9D005E84  00003812   MFLO A3
9D005E88  00002012   MFLO A0
9D005E8C  70EA5002   MUL T2, A3, T2
9D005E90  00094C00   SLL T1, T1, 16
9D005E94  01221025   OR V0, T1, V0
9D005E98  004A482B   SLTU T1, V0, T2
9D005E9C  00A3001B   DIVU A1, V1
9D005EA0  006001F4   TEQ V1, ZERO
9D005EA4  51200009   BEQL T1, ZERO, 0x9D005ECC
9D005EA8  00061400   SLL V0, A2, 16
9D005EAC  00481021   ADDU V0, V0, T0
9D005EB0  0048402B   SLTU T0, V0, T0
9D005EB4  15000004   BNE T0, ZERO, 0x9D005EC8
9D005EB8  24E4FFFF   ADDIU A0, A3, -1
9D005EBC  004A502B   SLTU T2, V0, T2
9D005EC0  24E7FFFE   ADDIU A3, A3, -2
9D005EC4  00EA200B   MOVN A0, A3, T2
9D005EC8  00061400   SLL V0, A2, 16
9D005ECC  00821025   OR V0, A0, V0
9D005ED0  03E00008   JR RA
9D005ED4  00001821   ADDU V1, ZERO, ZERO
9D005654  14C00006   BNE A2, ZERO, 0x9D005670
9D005658  71021020   CLZ V0, T0
9D005AA4  14C00006   BNE A2, ZERO, 0x9D005AC0
9D005AA8  71021020   CLZ V0, T0
9D005F04  14C00006   BNE A2, ZERO, 0x9D005F20
9D005F08  71031820   CLZ V1, T0
9D00565C  24080001   ADDIU T0, ZERO, 1
9D005660  0107001B   DIVU T0, A3
9D005664  00E001F4   TEQ A3, ZERO
9D005668  00004012   MFLO T0
9D005AAC  24020001   ADDIU V0, ZERO, 1
9D005AB0  0046001B   DIVU V0, A2
9D005AB4  00C001F4   TEQ A2, ZERO
9D005AB8  00004012   MFLO T0
9D005F0C  24030001   ADDIU V1, ZERO, 1
9D005F10  0066001B   DIVU V1, A2
9D005F14  00C001F4   TEQ A2, ZERO
9D005F18  00004012   MFLO T0
9D00566C  71021020   CLZ V0, T0
9D005ABC  71021020   CLZ V0, T0
9D005F1C  71031820   CLZ V1, T0
9D005670  54400033   BNEL V0, ZERO, 0x9D005740
9D005674  00484004   SLLV T0, T0, V0
9D005AC0  5440007D   BNEL V0, ZERO, 0x9D005CB8
9D005AC4  00484004   SLLV T0, T0, V0
9D005F20  5460007B   BNEL V1, ZERO, 0x9D006110
9D005F24  00684004   SLLV T0, T0, V1
9D005678  00A82023   SUBU A0, A1, T0
9D00567C  00083C02   SRL A3, T0, 16
9D005680  310CFFFF   ANDI T4, T0, -1
9D005684  24030001   ADDIU V1, ZERO, 1
9D005AC8  00A82823   SUBU A1, A1, T0
9D005ACC  00081C02   SRL V1, T0, 16
9D005AD0  3107FFFF   ANDI A3, T0, -1
9D005F28  00A82023   SUBU A0, A1, T0
9D005F2C  00083C02   SRL A3, T0, 16
9D005F30  310BFFFF   ANDI T3, T0, -1
9D005F34  24030001   ADDIU V1, ZERO, 1
9D005740  24030020   ADDIU V1, ZERO, 32
9D005744  00621823   SUBU V1, V1, V0
9D005CB8  24090020   ADDIU T1, ZERO, 32
9D005CBC  01224823   SUBU T1, T1, V0
9D006110  24020020   ADDIU V0, ZERO, 32
9D006114  00431023   SUBU V0, V0, V1
9D005748  00653006   SRLV A2, A1, V1
9D005CC0  01255006   SRLV T2, A1, T1
9D006118  00454806   SRLV T1, A1, V0
9D005764  00452804   SLLV A1, A1, V0
9D005768  00641806   SRLV V1, A0, V1
9D00576C  00652825   OR A1, V1, A1
9D005CDC  00452804   SLLV A1, A1, V0
9D005CE0  01244806   SRLV T1, A0, T1
9D005CE4  01252825   OR A1, T1, A1
9D006134  00652804   SLLV A1, A1, V1
9D006138  00441006   SRLV V0, A0, V0
9D00613C  00452825   OR A1, V0, A1
9D005774  00445004   SLLV T2, A0, V0
9D005CEC  00444804   SLLV T1, A0, V0
9D006144  00641004   SLLV V0, A0, V1
9D00574C  00083C02   SRL A3, T0, 16
9D005750  00C7001B   DIVU A2, A3
9D005754  00E001F4   TEQ A3, ZERO
9D005758  00007810   MFHI T7
9D00575C  00006812   MFLO T5
9D005760  310CFFFF   ANDI T4, T0, -1
9D005770  00057402   SRL T6, A1, 16
9D005778  00001812   MFLO V1
9D00577C  71AC5802   MUL T3, T5, T4
9D005780  000F1400   SLL V0, T7, 16
9D005784  01C21025   OR V0, T6, V0
9D005788  004B202B   SLTU A0, V0, T3
9D00578C  00C7001B   DIVU A2, A3
9D005790  00E001F4   TEQ A3, ZERO
9D005794  5080000B   BEQL A0, ZERO, 0x9D0057C4
9D005798  004B1023   SUBU V0, V0, T3
9D00579C  00481021   ADDU V0, V0, T0
9D0057A0  0048202B   SLTU A0, V0, T0
9D0057A4  14800006   BNE A0, ZERO, 0x9D0057C0
9D0057A8  25A3FFFF   ADDIU V1, T5, -1
9D0057AC  004B202B   SLTU A0, V0, T3
9D0057B0  50800004   BEQL A0, ZERO, 0x9D0057C4
9D0057B4  004B1023   SUBU V0, V0, T3
9D0057B8  25A3FFFE   ADDIU V1, T5, -2
9D0057BC  00481021   ADDU V0, V0, T0
9D0057C0  004B1023   SUBU V0, V0, T3
9D0057C4  30ADFFFF   ANDI T5, A1, -1
9D0057C8  0047001B   DIVU V0, A3
9D0057CC  00E001F4   TEQ A3, ZERO
9D0057D0  00002010   MFHI A0
9D0057D4  00005812   MFLO T3
9D0057D8  00003012   MFLO A2
9D0057DC  716C2802   MUL A1, T3, T4
9D0057E0  00042400   SLL A0, A0, 16
9D0057E4  008D2025   OR A0, A0, T5
9D0057E8  0085682B   SLTU T5, A0, A1
9D0057EC  0047001B   DIVU V0, A3
9D0057F0  00E001F4   TEQ A3, ZERO
9D0057F4  51A0000B   BEQL T5, ZERO, 0x9D005824
9D0057F8  00031C00   SLL V1, V1, 16
9D0057FC  00882021   ADDU A0, A0, T0
9D005800  0088102B   SLTU V0, A0, T0
9D005804  14400006   BNE V0, ZERO, 0x9D005820
9D005808  2566FFFF   ADDIU A2, T3, -1
9D00580C  0085102B   SLTU V0, A0, A1
9D005810  50400004   BEQL V0, ZERO, 0x9D005824
9D005814  00031C00   SLL V1, V1, 16
9D005818  2566FFFE   ADDIU A2, T3, -2
9D00581C  00882021   ADDU A0, A0, T0
9D005820  00031C00   SLL V1, V1, 16
9D005824  00852023   SUBU A0, A0, A1
9D005828  0B4015A2   J .LBB16
9D00582C  00C31825   OR V1, A2, V1
9D005CC4  00081C02   SRL V1, T0, 16
9D005CC8  0143001B   DIVU T2, V1
9D005CCC  006001F4   TEQ V1, ZERO
9D005CD0  00003010   MFHI A2
9D005CD4  00005812   MFLO T3
9D005CD8  3107FFFF   ANDI A3, T0, -1
9D005CE8  00056402   SRL T4, A1, 16
9D005CF0  71675802   MUL T3, T3, A3
9D005CF4  00063400   SLL A2, A2, 16
9D005CF8  01863025   OR A2, T4, A2
9D005CFC  00CB202B   SLTU A0, A2, T3
9D005D00  0143001B   DIVU T2, V1
9D005D04  006001F4   TEQ V1, ZERO
9D005D08  50800006   BEQL A0, ZERO, 0x9D005D24
9D005D0C  00CB3023   SUBU A2, A2, T3
9D005D10  00C83021   ADDU A2, A2, T0
9D005D14  00C8202B   SLTU A0, A2, T0
9D005D18  10800024   BEQ A0, ZERO, 0x9D005DAC
9D005D1C  00CB502B   SLTU T2, A2, T3
9D005D20  00CB3023   SUBU A2, A2, T3
9D005D24  30AAFFFF   ANDI T2, A1, -1
9D005D28  00C3001B   DIVU A2, V1
9D005D2C  006001F4   TEQ V1, ZERO
9D005D30  00002010   MFHI A0
9D005D34  00002812   MFLO A1
9D005D38  70A72802   MUL A1, A1, A3
9D005D3C  00042400   SLL A0, A0, 16
9D005D40  008A2025   OR A0, A0, T2
9D005D44  0085502B   SLTU T2, A0, A1
9D005D48  00C3001B   DIVU A2, V1
9D005D4C  006001F4   TEQ V1, ZERO
9D005D50  5140FF60   BEQL T2, ZERO, .LBB17
9D005D54  00852823   SUBU A1, A0, A1
9D005D58  00882021   ADDU A0, A0, T0
9D005D5C  0088302B   SLTU A2, A0, T0
9D005D60  54C0FF5C   BNEL A2, ZERO, .LBB17
9D005D64  00852823   SUBU A1, A0, A1
9D005D68  0085502B   SLTU T2, A0, A1
9D005D6C  00883021   ADDU A2, A0, T0
9D005D70  00CA200B   MOVN A0, A2, T2
9D005D74  0B4016B5   J .LBB17
9D005D78  00852823   SUBU A1, A0, A1
9D005DAC  00C82021   ADDU A0, A2, T0
9D005DB0  0B401748   J 0x9D005D20
9D005DB4  008A300B   MOVN A2, A0, T2
9D00611C  00083C02   SRL A3, T0, 16
9D006120  0127001B   DIVU T1, A3
9D006124  00E001F4   TEQ A3, ZERO
9D006128  00003010   MFHI A2
9D00612C  00006012   MFLO T4
9D006130  310BFFFF   ANDI T3, T0, -1
9D006140  00056C02   SRL T5, A1, 16
9D006148  00001812   MFLO V1
9D00614C  718B5002   MUL T2, T4, T3
9D006150  00063400   SLL A2, A2, 16
9D006154  01A63025   OR A2, T5, A2
9D006158  00CA202B   SLTU A0, A2, T2
9D00615C  0127001B   DIVU T1, A3
9D006160  00E001F4   TEQ A3, ZERO
9D006164  5080000B   BEQL A0, ZERO, 0x9D006194
9D006168  00CA3023   SUBU A2, A2, T2
9D00616C  00C83021   ADDU A2, A2, T0
9D006170  00C8202B   SLTU A0, A2, T0
9D006174  14800006   BNE A0, ZERO, 0x9D006190
9D006178  2583FFFF   ADDIU V1, T4, -1
9D00617C  00CA202B   SLTU A0, A2, T2
9D006180  50800004   BEQL A0, ZERO, 0x9D006194
9D006184  00CA3023   SUBU A2, A2, T2
9D006188  2583FFFE   ADDIU V1, T4, -2
9D00618C  00C83021   ADDU A2, A2, T0
9D006190  00CA3023   SUBU A2, A2, T2
9D006194  30ACFFFF   ANDI T4, A1, -1
9D006198  00C7001B   DIVU A2, A3
9D00619C  00E001F4   TEQ A3, ZERO
9D0061A0  00002010   MFHI A0
9D0061A4  00005012   MFLO T2
9D0061A8  00004812   MFLO T1
9D0061AC  714B2802   MUL A1, T2, T3
9D0061B0  00042400   SLL A0, A0, 16
9D0061B4  008C2025   OR A0, A0, T4
9D0061B8  0085602B   SLTU T4, A0, A1
9D0061BC  00C7001B   DIVU A2, A3
9D0061C0  00E001F4   TEQ A3, ZERO
9D0061C4  5180000B   BEQL T4, ZERO, 0x9D0061F4
9D0061C8  00031C00   SLL V1, V1, 16
9D0061CC  00882021   ADDU A0, A0, T0
9D0061D0  0088302B   SLTU A2, A0, T0
9D0061D4  14C00006   BNE A2, ZERO, 0x9D0061F0
9D0061D8  2549FFFF   ADDIU T1, T2, -1
9D0061DC  0085302B   SLTU A2, A0, A1
9D0061E0  50C00004   BEQL A2, ZERO, 0x9D0061F4
9D0061E4  00031C00   SLL V1, V1, 16
9D0061E8  2549FFFE   ADDIU T1, T2, -2
9D0061EC  00882021   ADDU A0, A0, T0
9D0061F0  00031C00   SLL V1, V1, 16
9D0061F4  00852023   SUBU A0, A0, A1
9D0061F8  0B4017CE   J .LBB16
9D0061FC  01231825   OR V1, T1, V1
9D005688  000A3402   SRL A2, T2, 16
9D00568C  0087001B   DIVU A0, A3
9D005690  00E001F4   TEQ A3, ZERO
9D005694  00007010   MFHI T6
9D005698  00006812   MFLO T5
9D00569C  00001012   MFLO V0
9D0056A0  71AC5802   MUL T3, T5, T4
9D0056A4  000E7400   SLL T6, T6, 16
9D0056A8  01C63025   OR A2, T6, A2
9D0056AC  00CB702B   SLTU T6, A2, T3
9D0056B0  0087001B   DIVU A0, A3
9D0056B4  00E001F4   TEQ A3, ZERO
9D0056B8  11C00009   BEQ T6, ZERO, 0x9D0056E0
9D0056BC  00CB2823   SUBU A1, A2, T3
9D0056C0  00C83021   ADDU A2, A2, T0
9D0056C4  00C8202B   SLTU A0, A2, T0
9D0056C8  14800004   BNE A0, ZERO, 0x9D0056DC
9D0056CC  25A2FFFF   ADDIU V0, T5, -1
9D0056D0  00CB202B   SLTU A0, A2, T3
9D0056D4  548000A3   BNEL A0, ZERO, 0x9D005964
9D0056D8  25A2FFFE   ADDIU V0, T5, -2
9D0056DC  00CB2823   SUBU A1, A2, T3
9D0056E0  314AFFFF   ANDI T2, T2, -1
9D0056E4  00A7001B   DIVU A1, A3
9D0056E8  00E001F4   TEQ A3, ZERO
9D0056EC  00005810   MFHI T3
9D0056F0  00003012   MFLO A2
9D0056F4  00002012   MFLO A0
9D0056F8  70CC6002   MUL T4, A2, T4
9D0056FC  000B5C00   SLL T3, T3, 16
9D005700  016A5025   OR T2, T3, T2
9D005704  014C582B   SLTU T3, T2, T4
9D005708  00A7001B   DIVU A1, A3
9D00570C  00E001F4   TEQ A3, ZERO
9D005710  51600009   BEQL T3, ZERO, .LBE16
9D005714  00021400   SLL V0, V0, 16
9D005718  01485021   ADDU T2, T2, T0
9D00571C  0148402B   SLTU T0, T2, T0
9D005720  15000004   BNE T0, ZERO, 0x9D005734
9D005724  24C4FFFF   ADDIU A0, A2, -1
9D005728  014C502B   SLTU T2, T2, T4
9D00572C  24C6FFFE   ADDIU A2, A2, -2
9D005730  00CA200B   MOVN A0, A2, T2
9D005734  00021400   SLL V0, V0, 16
9D005738  0B401573   J .LBE15
9D00573C  00821025   OR V0, A0, V0
9D005964  0B4015B7   J 0x9D0056DC
9D005968  00C83021   ADDU A2, A2, T0
9D005AD4  00092402   SRL A0, T1, 16
9D005AD8  00A3001B   DIVU A1, V1
9D005ADC  006001F4   TEQ V1, ZERO
9D005AE0  00005010   MFHI T2
9D005AE4  00003012   MFLO A2
9D005AE8  70C73002   MUL A2, A2, A3
9D005AEC  000A5400   SLL T2, T2, 16
9D005AF0  01442025   OR A0, T2, A0
9D005AF4  0086502B   SLTU T2, A0, A2
9D005AF8  00A3001B   DIVU A1, V1
9D005AFC  006001F4   TEQ V1, ZERO
9D005B00  51400009   BEQL T2, ZERO, 0x9D005B28
9D005B04  00862023   SUBU A0, A0, A2
9D005B08  00882021   ADDU A0, A0, T0
9D005B0C  0088282B   SLTU A1, A0, T0
9D005B10  54A00005   BNEL A1, ZERO, 0x9D005B28
9D005B14  00862023   SUBU A0, A0, A2
9D005B18  0086502B   SLTU T2, A0, A2
9D005B1C  00882821   ADDU A1, A0, T0
9D005B20  00AA200B   MOVN A0, A1, T2
9D005B24  00862023   SUBU A0, A0, A2
9D005B28  3126FFFF   ANDI A2, T1, -1
9D005B2C  0083001B   DIVU A0, V1
9D005B30  006001F4   TEQ V1, ZERO
9D005B34  00004810   MFHI T1
9D005B38  00002812   MFLO A1
9D005B3C  70A72802   MUL A1, A1, A3
9D005B40  00094C00   SLL T1, T1, 16
9D005B44  01264825   OR T1, T1, A2
9D005B48  0125302B   SLTU A2, T1, A1
9D005B4C  0083001B   DIVU A0, V1
9D005B50  006001F4   TEQ V1, ZERO
9D005B54  50C00009   BEQL A2, ZERO, .LBE17
9D005B58  01254823   SUBU T1, T1, A1
9D005B5C  01284821   ADDU T1, T1, T0
9D005B60  0128182B   SLTU V1, T1, T0
9D005B64  54600005   BNEL V1, ZERO, .LBE17
9D005B68  01254823   SUBU T1, T1, A1
9D005B6C  0125182B   SLTU V1, T1, A1
9D005B70  01284021   ADDU T0, T1, T0
9D005B74  0103480B   MOVN T1, T0, V1
9D005B78  01254823   SUBU T1, T1, A1
9D005F38  00023402   SRL A2, V0, 16
9D005F3C  0087001B   DIVU A0, A3
9D005F40  00E001F4   TEQ A3, ZERO
9D005F44  00006810   MFHI T5
9D005F48  00006012   MFLO T4
9D005F4C  00004812   MFLO T1
9D005F50  718B5002   MUL T2, T4, T3
9D005F54  000D6C00   SLL T5, T5, 16
9D005F58  01A63025   OR A2, T5, A2
9D005F5C  00CA682B   SLTU T5, A2, T2
9D005F60  0087001B   DIVU A0, A3
9D005F64  00E001F4   TEQ A3, ZERO
9D005F68  11A00009   BEQ T5, ZERO, 0x9D005F90
9D005F6C  00CA2823   SUBU A1, A2, T2
9D005F70  00C83021   ADDU A2, A2, T0
9D005F74  00C8202B   SLTU A0, A2, T0
9D005F78  14800004   BNE A0, ZERO, 0x9D005F8C
9D005F7C  2589FFFF   ADDIU T1, T4, -1
9D005F80  00CA202B   SLTU A0, A2, T2
9D005F84  548000A6   BNEL A0, ZERO, 0x9D006220
9D005F88  2589FFFE   ADDIU T1, T4, -2
9D005F8C  00CA2823   SUBU A1, A2, T2
9D005F90  3042FFFF   ANDI V0, V0, -1
9D005F94  00A7001B   DIVU A1, A3
9D005F98  00E001F4   TEQ A3, ZERO
9D005F9C  00005010   MFHI T2
9D005FA0  00003012   MFLO A2
9D005FA4  00002012   MFLO A0
9D005FA8  70CB5802   MUL T3, A2, T3
9D005FAC  000A5400   SLL T2, T2, 16
9D005FB0  01421025   OR V0, T2, V0
9D005FB4  004B502B   SLTU T2, V0, T3
9D005FB8  00A7001B   DIVU A1, A3
9D005FBC  00E001F4   TEQ A3, ZERO
9D005FC0  51400009   BEQL T2, ZERO, .LBE16
9D005FC4  00091400   SLL V0, T1, 16
9D005FC8  00481021   ADDU V0, V0, T0
9D005FCC  0048402B   SLTU T0, V0, T0
9D005FD0  15000004   BNE T0, ZERO, 0x9D005FE4
9D005FD4  24C4FFFF   ADDIU A0, A2, -1
9D005FD8  004B582B   SLTU T3, V0, T3
9D005FDC  24C6FFFE   ADDIU A2, A2, -2
9D005FE0  00CB200B   MOVN A0, A2, T3
9D005FE4  00091400   SLL V0, T1, 16
9D005FE8  03E00008   JR RA
9D005FEC  00821025   OR V0, A0, V0
9D006220  0B4017E3   J 0x9D005F8C
9D006224  00C83021   ADDU A2, A2, T0
9D005A58  00491006   SRLV V0, T1, V0
9D005B7C  00491006   SRLV V0, T1, V0
9D005A5C  03E00008   JR RA
9D005A60  00001821   ADDU V1, ZERO, ZERO
9D005B80  03E00008   JR RA
9D005B84  00001821   ADDU V1, ZERO, ZERO
9D0055EC  00A7102B   SLTU V0, A1, A3
9D0055F0  10400010   BEQ V0, ZERO, 0x9D005634
9D0055F4  70E84020   CLZ T0, A3
9D0055F8  00001821   ADDU V1, ZERO, ZERO
9D0055FC  0B401573   J .LBE15
9D005600  00001021   ADDU V0, ZERO, ZERO
9D005A64  00A7102B   SLTU V0, A1, A3
9D005A68  14400047   BNE V0, ZERO, 0x9D005B88
9D005A6C  70EA5020   CLZ T2, A3
9D005ED8  00A7102B   SLTU V0, A1, A3
9D005EDC  14400044   BNE V0, ZERO, 0x9D005FF0
9D005EE0  70E84020   CLZ T0, A3
9D005FF0  00001821   ADDU V1, ZERO, ZERO
9D005FF4  03E00008   JR RA
9D005FF8  00001021   ADDU V0, ZERO, ZERO
9D005B88  00801021   ADDU V0, A0, ZERO
9D005B8C  03E00008   JR RA
9D005B90  00A01821   ADDU V1, A1, ZERO
9D005634  1500007E   BNE T0, ZERO, 0x9D005830
9D005638  24020020   ADDIU V0, ZERO, 32
9D005A70  15400048   BNE T2, ZERO, 0x9D005B94
9D005A74  240B0020   ADDIU T3, ZERO, 32
9D005EE4  55000045   BNEL T0, ZERO, 0x9D005FFC
9D005EE8  24020020   ADDIU V0, ZERO, 32
9D00563C  00E5282B   SLTU A1, A3, A1
9D005640  14A000C6   BNE A1, ZERO, 0x9D00595C
9D005644  00001821   ADDU V1, ZERO, ZERO
9D005648  0086102B   SLTU V0, A0, A2
9D00564C  0B401573   J .LBE15
9D005650  38420001   XORI V0, V0, 1
9D00595C  0B401573   J .LBE15
9D005960  24020001   ADDIU V0, ZERO, 1
9D005A78  00E5102B   SLTU V0, A3, A1
9D005A7C  14400005   BNE V0, ZERO, 0x9D005A94
9D005A80  00861023   SUBU V0, A0, A2
9D005A84  0086402B   SLTU T0, A0, A2
9D005A88  15000089   BNE T0, ZERO, 0x9D005CB0
9D005A8C  00801021   ADDU V0, A0, ZERO
9D005EEC  00E5282B   SLTU A1, A3, A1
9D005EF0  14A000C8   BNE A1, ZERO, 0x9D006214
9D005EF4  0086302B   SLTU A2, A0, A2
9D005EF8  38C20001   XORI V0, A2, 1
9D005EFC  03E00008   JR RA
9D005F00  00001821   ADDU V1, ZERO, ZERO
9D006214  00001821   ADDU V1, ZERO, ZERO
9D005A90  00861023   SUBU V0, A0, A2
9D005A94  00A72823   SUBU A1, A1, A3
9D005A98  0082202B   SLTU A0, A0, V0
9D005A9C  03E00008   JR RA
9D005AA0  00A41823   SUBU V1, A1, A0
9D005830  00481023   SUBU V0, V0, T0
9D005B94  016A5823   SUBU T3, T3, T2
9D005FFC  00481023   SUBU V0, V0, T0
9D005834  01073804   SLLV A3, A3, T0
9D005838  00461806   SRLV V1, A2, V0
9D00583C  00673825   OR A3, V1, A3
9D005B98  01473804   SLLV A3, A3, T2
9D005B9C  01661006   SRLV V0, A2, T3
9D005BA0  00473825   OR A3, V0, A3
9D006000  01073804   SLLV A3, A3, T0
9D006004  00461806   SRLV V1, A2, V0
9D006008  00673825   OR A3, V1, A3
9D005BD0  01463004   SLLV A2, A2, T2
9D005840  00455806   SRLV T3, A1, V0
9D005BA4  01656806   SRLV T5, A1, T3
9D00600C  00455006   SRLV T2, A1, V0
9D00585C  01052804   SLLV A1, A1, T0
9D005860  00441006   SRLV V0, A0, V0
9D005864  00452825   OR A1, V0, A1
9D005BC0  01452804   SLLV A1, A1, T2
9D005BC4  01641006   SRLV V0, A0, T3
9D005BC8  00451025   OR V0, V0, A1
9D006028  01052804   SLLV A1, A1, T0
9D00602C  00441006   SRLV V0, A0, V0
9D006030  00452825   OR A1, V0, A1
9D005844  00071C02   SRL V1, A3, 16
9D005848  0163001B   DIVU T3, V1
9D00584C  006001F4   TEQ V1, ZERO
9D005850  00005010   MFHI T2
9D005854  00007012   MFLO T6
9D005858  30ECFFFF   ANDI T4, A3, -1
9D005868  00057C02   SRL T7, A1, 16
9D00586C  00001012   MFLO V0
9D005870  71CC6802   MUL T5, T6, T4
9D005874  000A5400   SLL T2, T2, 16
9D005878  014F5025   OR T2, T2, T7
9D00587C  014D782B   SLTU T7, T2, T5
9D005880  0163001B   DIVU T3, V1
9D005884  006001F4   TEQ V1, ZERO
9D005888  11E0000A   BEQ T7, ZERO, 0x9D0058B4
9D00588C  01063004   SLLV A2, A2, T0
9D005890  01475021   ADDU T2, T2, A3
9D005894  0147582B   SLTU T3, T2, A3
9D005898  15600006   BNE T3, ZERO, 0x9D0058B4
9D00589C  25C2FFFF   ADDIU V0, T6, -1
9D0058A0  014D582B   SLTU T3, T2, T5
9D0058A4  51600004   BEQL T3, ZERO, 0x9D0058B8
9D0058A8  014D5023   SUBU T2, T2, T5
9D0058AC  25C2FFFE   ADDIU V0, T6, -2
9D0058B0  01475021   ADDU T2, T2, A3
9D0058B4  014D5023   SUBU T2, T2, T5
9D0058B8  30A5FFFF   ANDI A1, A1, -1
9D0058BC  0143001B   DIVU T2, V1
9D0058C0  006001F4   TEQ V1, ZERO
9D0058C4  00007010   MFHI T6
9D0058C8  00006812   MFLO T5
9D0058CC  00005812   MFLO T3
9D0058D0  71AC6002   MUL T4, T5, T4
9D0058D4  000E7400   SLL T6, T6, 16
9D0058D8  01C52825   OR A1, T6, A1
9D0058DC  00AC702B   SLTU T6, A1, T4
9D0058E0  0143001B   DIVU T2, V1
9D0058E4  006001F4   TEQ V1, ZERO
9D0058E8  51C0000B   BEQL T6, ZERO, 0x9D005918
9D0058EC  00021400   SLL V0, V0, 16
9D0058F0  00A72821   ADDU A1, A1, A3
9D0058F4  00A7182B   SLTU V1, A1, A3
9D0058F8  14600006   BNE V1, ZERO, 0x9D005914
9D0058FC  25ABFFFF   ADDIU T3, T5, -1
9D005900  00AC182B   SLTU V1, A1, T4
9D005904  50600004   BEQL V1, ZERO, 0x9D005918
9D005908  00021400   SLL V0, V0, 16
9D00590C  25ABFFFE   ADDIU T3, T5, -2
9D005910  00A72821   ADDU A1, A1, A3
9D005914  00021400   SLL V0, V0, 16
9D005918  01621025   OR V0, T3, V0
9D00591C  00AC2823   SUBU A1, A1, T4
9D005BA8  00074C02   SRL T1, A3, 16
9D005BAC  01A9001B   DIVU T5, T1
9D005BB0  012001F4   TEQ T1, ZERO
9D005BB4  00006010   MFHI T4
9D005BB8  00001812   MFLO V1
9D005BBC  30EEFFFF   ANDI T6, A3, -1
9D005BCC  00022C02   SRL A1, V0, 16
9D005BD4  00004012   MFLO T0
9D005BD8  706E7802   MUL T7, V1, T6
9D005BDC  000C6400   SLL T4, T4, 16
9D005BE0  01856025   OR T4, T4, A1
9D005BE4  018F282B   SLTU A1, T4, T7
9D005BE8  01A9001B   DIVU T5, T1
9D005BEC  012001F4   TEQ T1, ZERO
9D005BF0  10A0000A   BEQ A1, ZERO, 0x9D005C1C
9D005BF4  01442004   SLLV A0, A0, T2
9D005BF8  01876021   ADDU T4, T4, A3
9D005BFC  0187282B   SLTU A1, T4, A3
9D005C00  14A00006   BNE A1, ZERO, 0x9D005C1C
9D005C04  2468FFFF   ADDIU T0, V1, -1
9D005C08  018F282B   SLTU A1, T4, T7
9D005C0C  50A00004   BEQL A1, ZERO, 0x9D005C20
9D005C10  018F6023   SUBU T4, T4, T7
9D005C14  2468FFFE   ADDIU T0, V1, -2
9D005C18  01876021   ADDU T4, T4, A3
9D005C1C  018F6023   SUBU T4, T4, T7
9D005C20  3042FFFF   ANDI V0, V0, -1
9D005C24  0189001B   DIVU T4, T1
9D005C28  012001F4   TEQ T1, ZERO
9D005C2C  00002810   MFHI A1
9D005C30  00001812   MFLO V1
9D005C34  00006812   MFLO T5
9D005C38  706E7002   MUL T6, V1, T6
9D005C3C  00052C00   SLL A1, A1, 16
9D005C40  00A21025   OR V0, A1, V0
9D005C44  004E282B   SLTU A1, V0, T6
9D005C48  0189001B   DIVU T4, T1
9D005C4C  012001F4   TEQ T1, ZERO
9D005C50  50A00006   BEQL A1, ZERO, 0x9D005C6C
9D005C54  00084400   SLL T0, T0, 16
9D005C58  00471021   ADDU V0, V0, A3
9D005C5C  0047282B   SLTU A1, V0, A3
9D005C60  10A0004C   BEQ A1, ZERO, .LBE25
9D005C64  246DFFFF   ADDIU T5, V1, -1
9D005C68  00084400   SLL T0, T0, 16
9D005C6C  01A84025   OR T0, T5, T0
9D005C70  004E1023   SUBU V0, V0, T6
9D005D94  004E282B   SLTU A1, V0, T6
9D005D98  50A0FFB4   BEQL A1, ZERO, 0x9D005C6C
9D005D9C  00084400   SLL T0, T0, 16
9D005DA0  246DFFFE   ADDIU T5, V1, -2
9D005DA4  0B40171A   J 0x9D005C68
9D005DA8  00471021   ADDU V0, V0, A3
9D006010  00071C02   SRL V1, A3, 16
9D006014  0143001B   DIVU T2, V1
9D006018  006001F4   TEQ V1, ZERO
9D00601C  00004810   MFHI T1
9D006020  00006812   MFLO T5
9D006024  30EBFFFF   ANDI T3, A3, -1
9D006034  00057402   SRL T6, A1, 16
9D006038  00001012   MFLO V0
9D00603C  71AB6002   MUL T4, T5, T3
9D006040  00094C00   SLL T1, T1, 16
9D006044  012E4825   OR T1, T1, T6
9D006048  012C702B   SLTU T6, T1, T4
9D00604C  0143001B   DIVU T2, V1
9D006050  006001F4   TEQ V1, ZERO
9D006054  11C0000A   BEQ T6, ZERO, 0x9D006080
9D006058  01063004   SLLV A2, A2, T0
9D00605C  01274821   ADDU T1, T1, A3
9D006060  0127502B   SLTU T2, T1, A3
9D006064  15400006   BNE T2, ZERO, 0x9D006080
9D006068  25A2FFFF   ADDIU V0, T5, -1
9D00606C  012C502B   SLTU T2, T1, T4
9D006070  51400004   BEQL T2, ZERO, 0x9D006084
9D006074  012C4823   SUBU T1, T1, T4
9D006078  25A2FFFE   ADDIU V0, T5, -2
9D00607C  01274821   ADDU T1, T1, A3
9D006080  012C4823   SUBU T1, T1, T4
9D006084  30A5FFFF   ANDI A1, A1, -1
9D006088  0123001B   DIVU T1, V1
9D00608C  006001F4   TEQ V1, ZERO
9D006090  00006810   MFHI T5
9D006094  00006012   MFLO T4
9D006098  00005012   MFLO T2
9D00609C  718B5802   MUL T3, T4, T3
9D0060A0  000D6C00   SLL T5, T5, 16
9D0060A4  01A52825   OR A1, T5, A1
9D0060A8  00AB682B   SLTU T5, A1, T3
9D0060AC  0123001B   DIVU T1, V1
9D0060B0  006001F4   TEQ V1, ZERO
9D0060B4  51A0000B   BEQL T5, ZERO, 0x9D0060E4
9D0060B8  00021400   SLL V0, V0, 16
9D0060BC  00A72821   ADDU A1, A1, A3
9D0060C0  00A7182B   SLTU V1, A1, A3
9D0060C4  14600006   BNE V1, ZERO, 0x9D0060E0
9D0060C8  258AFFFF   ADDIU T2, T4, -1
9D0060CC  00AB182B   SLTU V1, A1, T3
9D0060D0  50600004   BEQL V1, ZERO, 0x9D0060E4
9D0060D4  00021400   SLL V0, V0, 16
9D0060D8  258AFFFE   ADDIU T2, T4, -2
9D0060DC  00A72821   ADDU A1, A1, A3
9D0060E0  00021400   SLL V0, V0, 16
9D0060E4  01421025   OR V0, T2, V0
9D0060E8  00AB2823   SUBU A1, A1, T3
9D005920  00460019   MULTU 0, V0, A2
9D005924  00003810   MFHI A3
9D005C74  01060019   MULTU 0, T0, A2
9D005C78  00004810   MFHI T1
9D005C90  00003012   MFLO A2
9D0060EC  00460019   MULTU 0, V0, A2
9D0060F0  00003810   MFHI A3
9D005928  00A7182B   SLTU V1, A1, A3
9D00592C  14600008   BNE V1, ZERO, 0x9D005950
9D005930  00003012   MFLO A2
9D005934  50A70003   BEQL A1, A3, 0x9D005944
9D005938  01042004   SLLV A0, A0, T0
9D005944  0086302B   SLTU A2, A0, A2
9D005948  50C0FF20   BEQL A2, ZERO, .LBE15
9D00594C  00001821   ADDU V1, ZERO, ZERO
9D005C7C  0049182B   SLTU V1, V0, T1
9D005C80  1460003E   BNE V1, ZERO, .LBB25
9D005C84  00004012   MFLO T0
9D005C88  1049004B   BEQ V0, T1, 0x9D005DB8
9D005C8C  00491823   SUBU V1, V0, T1
9D005DB8  0088182B   SLTU V1, A0, T0
9D005DBC  5460FFF0   BNEL V1, ZERO, 0x9D005D80
9D005DC0  01063023   SUBU A2, T0, A2
9D005DC4  00003012   MFLO A2
9D005DC8  0B401725   J .LBB24
9D005DCC  00001821   ADDU V1, ZERO, ZERO
9D0060F4  00A7182B   SLTU V1, A1, A3
9D0060F8  14600044   BNE V1, ZERO, 0x9D00620C
9D0060FC  00003012   MFLO A2
9D006100  10A7003F   BEQ A1, A3, 0x9D006200
9D006104  01042004   SLLV A0, A0, T0
9D006200  0086302B   SLTU A2, A0, A2
9D006204  10C0FFC0   BEQ A2, ZERO, 0x9D006108
9D006208  00000000   NOP
9D00593C  0B401573   J .LBE15
9D005940  00001821   ADDU V1, ZERO, ZERO
9D005950  2442FFFF   ADDIU V0, V0, -1
9D005954  0B401573   J .LBE15
9D005958  00001821   ADDU V1, ZERO, ZERO
9D006108  03E00008   JR RA
9D00610C  00001821   ADDU V1, ZERO, ZERO
9D00620C  0B401842   J 0x9D006108
9D006210  2442FFFF   ADDIU V0, V0, -1
9D005D7C  01063023   SUBU A2, T0, A2
9D005D80  01271823   SUBU V1, T1, A3
9D005D84  0106402B   SLTU T0, T0, A2
9D005D88  00681823   SUBU V1, V1, T0
9D005D8C  0B401725   J .LBB24
9D005D90  00431823   SUBU V1, V0, V1
9D005C94  00863023   SUBU A2, A0, A2
9D005C98  0086202B   SLTU A0, A0, A2
9D005C9C  00641823   SUBU V1, V1, A0
9D005CA0  01631004   SLLV V0, V1, T3
9D005CA4  01463006   SRLV A2, A2, T2
9D005CA8  00461025   OR V0, V0, A2
9D005CAC  01431806   SRLV V1, V1, T2
9D0054B8  04A00052   BLTZ A1, 0x9D005604
9D0054BC  00004821   ADDU T1, ZERO, ZERO
9D005604  00042023   SUBU A0, ZERO, A0
9D005608  0004102B   SLTU V0, ZERO, A0
9D00560C  00052823   SUBU A1, ZERO, A1
9D005610  00A22823   SUBU A1, A1, V0
9D0054C0  04E20057   BLTZL A3, 0x9D005620
9D0054C4  00063023   SUBU A2, ZERO, A2
9D005614  04E1FFAC   BGEZ A3, .LBB13
9D005618  2409FFFF   ADDIU T1, ZERO, -1
9D005628  00094827   NOR T1, ZERO, T1
9D00561C  00063023   SUBU A2, ZERO, A2
9D005620  0006102B   SLTU V0, ZERO, A2
9D005624  00073823   SUBU A3, ZERO, A3
9D00562C  0B401532   J .LBB13
9D005630  00E23823   SUBU A3, A3, V0
9D0055CC  11200005   BEQ T1, ZERO, 0x9D0055E4
9D0055D0  00000000   NOP
9D0055D4  00021023   SUBU V0, ZERO, V0
9D0055D8  0002202B   SLTU A0, ZERO, V0
9D0055DC  00031823   SUBU V1, ZERO, V1
9D0055E0  00641823   SUBU V1, V1, A0
9D0055E4  03E00008   JR RA
9D0055E8  00000000   NOP
9D005CB0  03E00008   JR RA
9D005CB4  00000000   NOP
9D006218  03E00008   JR RA
9D00621C  24020001   ADDIU V0, ZERO, 1
9D00BE20  27BDFFE0   ADDIU SP, SP, -32
9D00BE24  AFBF001C   SW RA, 28(SP)
9D00BE28  AFB00018   SW S0, 24(SP)
9D00BE2C  00808021   ADDU S0, A0, ZERO
9D00BE30  00A02021   ADDU A0, A1, ZERO
9D00BE34  2605FFFF   ADDIU A1, S0, -1
9D00BE38  00B0182B   SLTU V1, A1, S0
9D00BE3C  3C02001F   LUI V0, 31
9D00BE40  3442FFFF   ORI V0, V0, -1
9D00BE44  00821021   ADDU V0, A0, V0
9D00BE48  00621021   ADDU V0, V1, V0
9D00BE4C  3C030040   LUI V1, 64
9D00BE50  0043302B   SLTU A2, V0, V1
9D00BE54  14C0001E   BNE A2, ZERO, 0x9D00BED0
9D00BE58  2463FFFF   ADDIU V1, V1, -1
9D00BED0  1443FFE7   BNE V0, V1, 0x9D00BE70
9D00BED4  00000000   NOP
9D00BED8  2CA5FFFF   SLTIU A1, A1, -1
9D00BEDC  10A0FFE0   BEQ A1, ZERO, 0x9D00BE60
9D00BEE0  320207FF   ANDI V0, S0, 2047
9D00BEE4  0B402F9C   J 0x9D00BE70
9D00BEE8  00000000   NOP
9D00BE5C  320207FF   ANDI V0, S0, 2047
9D00BE60  10400003   BEQ V0, ZERO, 0x9D00BE70
9D00BE64  00000000   NOP
9D00BE68  7C105004   INS S0, ZERO, 0, 11
9D00BE6C  36100800   ORI S0, S0, 2048
9D00BE70  0F403468   JAL litodp
9D00BE74  00000000   NOP
9D00BE78  3C049D01   LUI A0, -25343
9D00BE7C  8C86E4B0   LW A2, -6992(A0)
9D00BE80  8C87E4B4   LW A3, -6988(A0)
9D00BE84  00402021   ADDU A0, V0, ZERO
9D00BE88  0F401DD4   JAL dpmul
9D00BE8C  00602821   ADDU A1, V1, ZERO
9D00BE90  02002021   ADDU A0, S0, ZERO
9D00BE94  AFA20010   SW V0, 16(SP)
9D00BE98  0F40367F   JAL __floatunsidf
9D00BE9C  AFA30014   SW V1, 20(SP)
9D00BEA0  00402021   ADDU A0, V0, ZERO
9D00BEA4  00602821   ADDU A1, V1, ZERO
9D00BEA8  8FA60010   LW A2, 16(SP)
9D00BEAC  0F40188C   JAL dpadd
9D00BEB0  8FA70014   LW A3, 20(SP)
9D00BEB4  00402021   ADDU A0, V0, ZERO
9D00BEB8  0F402C2F   JAL dptofp
9D00BEBC  00602821   ADDU A1, V1, ZERO
9D00BEC0  8FBF001C   LW RA, 28(SP)
9D00BEC4  8FB00018   LW S0, 24(SP)
9D00BEC8  03E00008   JR RA
9D00BECC  27BD0020   ADDIU SP, SP, 32
9D00D55C  27BDFFE0   ADDIU SP, SP, -32
9D00D560  AFBF001C   SW RA, 28(SP)
9D00D564  AFB00018   SW S0, 24(SP)
9D00D568  00808021   ADDU S0, A0, ZERO
9D00D56C  0F40367F   JAL __floatunsidf
9D00D570  00A02021   ADDU A0, A1, ZERO
9D00D574  3C049D01   LUI A0, -25343
9D00D578  8C86E4D0   LW A2, -6960(A0)
9D00D57C  8C87E4D4   LW A3, -6956(A0)
9D00D580  00402021   ADDU A0, V0, ZERO
9D00D584  0F401DD4   JAL dpmul
9D00D588  00602821   ADDU A1, V1, ZERO
9D00D58C  02002021   ADDU A0, S0, ZERO
9D00D590  AFA20010   SW V0, 16(SP)
9D00D594  0F40367F   JAL __floatunsidf
9D00D598  AFA30014   SW V1, 20(SP)
9D00D59C  00402021   ADDU A0, V0, ZERO
9D00D5A0  00602821   ADDU A1, V1, ZERO
9D00D5A4  8FA60010   LW A2, 16(SP)
9D00D5A8  0F40188C   JAL dpadd
9D00D5AC  8FA70014   LW A3, 20(SP)
9D00D5B0  8FBF001C   LW RA, 28(SP)
9D00D5B4  8FB00018   LW S0, 24(SP)
9D00D5B8  03E00008   JR RA
9D00D5BC  27BD0020   ADDIU SP, SP, 32
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PT37-JOB1/src/pic32m-gcc/gcc/libgcc/floatunsidf.c  --
9D00D9FC  27BDFFE8   ADDIU SP, SP, -24
9D00DA00  AFBF0014   SW RA, 20(SP)
9D00DA04  AFB00010   SW S0, 16(SP)
9D00DA08  0F403468   JAL litodp
9D00DA0C  00808021   ADDU S0, A0, ZERO
9D00DA10  06010008   BGEZ S0, 0x9D00DA34
9D00DA14  8FBF0014   LW RA, 20(SP)
9D00DA18  3C049D01   LUI A0, -25343
9D00DA1C  8C86E4B8   LW A2, -6984(A0)
9D00DA20  8C87E4BC   LW A3, -6980(A0)
9D00DA24  00402021   ADDU A0, V0, ZERO
9D00DA28  0F40188C   JAL dpadd
9D00DA2C  00602821   ADDU A1, V1, ZERO
9D00DA30  8FBF0014   LW RA, 20(SP)
9D00DA34  8FB00010   LW S0, 16(SP)
9D00DA38  03E00008   JR RA
9D00DA3C  27BD0018   ADDIU SP, SP, 24
